import { E as ElIcon } from "../../base-BXVDO6W4.js";
import { ref, onMounted, onBeforeUnmount, defineComponent, computed, watch, nextTick, createElementBlock, openBlock, normalizeStyle, normalizeClass, createCommentVNode, Fragment, renderList, createBlock, createSlots, withCtx, renderSlot, unref, createVNode } from "vue";
import { g as arrow_down_bold_default } from "../../index-CnlpUR18.js";
import Bubble from "../Bubble/index.js";
import loadingBg from "./loading.js";
import '../../index.css';/* empty css                                                                   */
import { _ as _export_sfc } from "../../_plugin-vue_export-helper-1tPrXgE0.js";
const useScrollDetector = (elementRef) => {
  const hasVertical = ref(false);
  const hasHorizontal = ref(false);
  const check = () => {
    const el = elementRef.value;
    if (!el)
      return;
    hasVertical.value = el.scrollHeight > el.clientHeight;
    hasHorizontal.value = el.scrollWidth > el.clientWidth;
  };
  onMounted(() => {
    check();
    const observer = new ResizeObserver(check);
    observer.observe(elementRef.value);
    onBeforeUnmount(() => observer.disconnect());
  });
  return {
    hasVertical,
    // 是否有纵向滚动条
    hasHorizontal,
    // 是否有横向滚动条
    check
    // 检查滚动条状态
  };
};
const threshold = 20;
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    list: { default: () => [] },
    maxHeight: { default: "500px" },
    triggerIndices: { default: "only-last" },
    alwaysShowScrollbar: { type: Boolean, default: false },
    backButtonThreshold: { default: 80 },
    showBackButton: { type: Boolean, default: true },
    backButtonPosition: { default: () => {
      return { bottom: "20px", left: "calc(50% - 19px)" };
    } },
    btnLoading: { type: Boolean, default: true },
    btnColor: { default: "#409EFF" },
    btnIconSize: { default: 24 },
    highlight: { type: Function, default: void 0 },
    mdPlugins: { default: void 0 }
  },
  emits: ["complete"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const scrollContainer = ref(null);
    const { hasVertical } = useScrollDetector(scrollContainer);
    const stopAutoScrollToBottom = ref(false);
    const lastScrollTop = ref(0);
    const accumulatedScrollUpDistance = ref(0);
    const resizeObserver = ref(null);
    const showBackToBottom = ref(false);
    const effectiveTriggerIndices = computed(() => {
      if (props.triggerIndices === "only-last") {
        const triggerIndices = props.list.filter((item) => item.typing).map((_, index) => index);
        return triggerIndices.length > 0 ? [triggerIndices[triggerIndices.length - 1]] : [];
      } else if (props.triggerIndices === "all") {
        return props.list.map((_, index) => index);
      } else if (Array.isArray(props.triggerIndices)) {
        const validIndices = getValidIndices(props.list, props.triggerIndices);
        return validIndices.length > 0 ? [validIndices[validIndices.length - 1]] : [];
      }
      return [];
    });
    function getValidIndices(list, indices) {
      const validIndices = [];
      for (let i = 0; i < indices.length; i++) {
        const index = indices[i];
        if (index < 0 || index >= list.length || !list[index].typing) ;
        else {
          validIndices.push(index);
        }
      }
      return validIndices;
    }
    watch(
      () => props.list.length,
      () => {
        if (props.list && props.list.length > 0) {
          nextTick(() => {
            autoScroll();
          });
        }
      },
      { immediate: true }
    );
    function scrollToTop() {
      stopAutoScrollToBottom.value = true;
      nextTick(() => {
        scrollContainer.value.scrollTop = 0;
      });
    }
    function scrollToBottom() {
      try {
        if (scrollContainer.value && scrollContainer.value.scrollHeight) {
          nextTick(() => {
            scrollContainer.value.scrollTop = scrollContainer.value.scrollHeight;
            stopAutoScrollToBottom.value = false;
          });
        }
      } catch (error) {
      }
    }
    function scrollToBubble(index) {
      const container = scrollContainer.value;
      if (!container)
        return;
      const bubbles = container.querySelectorAll(".el-bubble");
      if (index >= bubbles.length)
        return;
      stopAutoScrollToBottom.value = true;
      const targetBubble = bubbles[index];
      const containerRect = container.getBoundingClientRect();
      const bubbleRect = targetBubble.getBoundingClientRect();
      const scrollPosition = bubbleRect.top - containerRect.top + container.scrollTop;
      container.scrollTo({
        top: scrollPosition,
        behavior: "smooth"
      });
    }
    function autoScroll() {
      if (scrollContainer.value) {
        const listBubbles = scrollContainer.value.querySelectorAll(".el-bubble-content-wrapper");
        if (resizeObserver.value) {
          resizeObserver.value.disconnect();
        }
        const lastItem = listBubbles[listBubbles.length - 1];
        if (lastItem) {
          resizeObserver.value = new ResizeObserver(() => {
            if (!stopAutoScrollToBottom.value) {
              scrollToBottom();
            }
          });
          resizeObserver.value.observe(lastItem);
        }
      }
    }
    function handleBubbleComplete(index, instance) {
      if (effectiveTriggerIndices.value.includes(index)) {
        emits("complete", instance, index);
      }
    }
    function handleScroll() {
      if (scrollContainer.value) {
        const { scrollTop, scrollHeight, clientHeight } = scrollContainer.value;
        const distanceToBottom = scrollHeight - (scrollTop + clientHeight);
        showBackToBottom.value = props.showBackButton && distanceToBottom > props.backButtonThreshold;
        const isCloseToBottom = scrollTop + clientHeight >= scrollHeight - 30;
        const isScrollingUp = lastScrollTop.value > scrollTop;
        const isScrollingDown = lastScrollTop.value < scrollTop;
        const scrollDelta = lastScrollTop.value - scrollTop;
        lastScrollTop.value = scrollTop;
        if (isScrollingUp) {
          accumulatedScrollUpDistance.value += scrollDelta;
          if (accumulatedScrollUpDistance.value >= threshold) {
            if (!stopAutoScrollToBottom.value) {
              stopAutoScrollToBottom.value = true;
            }
            accumulatedScrollUpDistance.value = 0;
          }
        } else {
          accumulatedScrollUpDistance.value = 0;
        }
        if (isScrollingDown && isCloseToBottom) {
          if (stopAutoScrollToBottom.value) {
            stopAutoScrollToBottom.value = false;
          }
        }
      }
    }
    __expose({
      scrollToTop,
      scrollToBottom,
      scrollToBubble
    });
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      return openBlock(), createElementBlock("div", {
        ref_key: "scrollContainer",
        ref: scrollContainer,
        class: normalizeClass(["el-bubble-list", { "always-scrollbar": props.alwaysShowScrollbar }]),
        style: normalizeStyle({
          "--el-bubble-list-max-height": `${_ctx.maxHeight}`,
          "--el-bubble-list-btn-size": `${props.btnIconSize}px`
        }),
        onScroll: handleScroll
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, index) => {
          return openBlock(), createBlock(Bubble, {
            key: index,
            content: item.content,
            placement: item.placement,
            loading: item.loading,
            shape: item.shape,
            variant: item.variant,
            "is-markdown": item.isMarkdown,
            "is-fog": item.isFog,
            typing: item.typing,
            "max-width": item.maxWidth,
            avatar: item.avatar,
            "avatar-size": item.avatarSize,
            "avatar-gap": item.avatarGap,
            "avatar-shape": item.avatarShape,
            "avatar-icon": item.avatarIcon,
            "avatar-src-set": item.avatarSrcSet,
            "avatar-alt": item.avatarAlt,
            "avatar-fit": item.avatarFit,
            "no-style": item.noStyle,
            highlight: item.highlight ? item.highlight : props.highlight,
            "md-plugins": item.mdPlugins ? item.mdPlugins : props.mdPlugins,
            onFinish: (instance) => handleBubbleComplete(index, instance)
          }, createSlots({ _: 2 }, [
            _ctx.$slots.avatar ? {
              name: "avatar",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "avatar", { item }, void 0, true)
              ]),
              key: "0"
            } : void 0,
            _ctx.$slots.header ? {
              name: "header",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "header", { item }, void 0, true)
              ]),
              key: "1"
            } : void 0,
            _ctx.$slots.content ? {
              name: "content",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "content", { item }, void 0, true)
              ]),
              key: "2"
            } : void 0,
            _ctx.$slots.footer ? {
              name: "footer",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "footer", { item }, void 0, true)
              ]),
              key: "3"
            } : void 0,
            _ctx.$slots.loading ? {
              name: "loading",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "loading", { item }, void 0, true)
              ]),
              key: "4"
            } : void 0
          ]), 1032, ["content", "placement", "loading", "shape", "variant", "is-markdown", "is-fog", "typing", "max-width", "avatar", "avatar-size", "avatar-gap", "avatar-shape", "avatar-icon", "avatar-src-set", "avatar-alt", "avatar-fit", "no-style", "highlight", "md-plugins", "onFinish"]);
        }), 128)),
        unref(showBackToBottom) && unref(hasVertical) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["el-bubble-list-default-back-button", {
            "el-bubble-list-back-to-bottom-solt": _ctx.$slots.backToBottom
          }]),
          style: normalizeStyle({
            bottom: _ctx.backButtonPosition.bottom,
            left: _ctx.backButtonPosition.left
          }),
          onClick: scrollToBottom
        }, [
          renderSlot(_ctx.$slots, "backToBottom", {}, () => [
            createVNode(_component_el_icon, {
              class: "el-bubble-list-back-to-bottom-icon",
              style: normalizeStyle({ color: props.btnColor })
            }, {
              default: withCtx(() => [
                createVNode(unref(arrow_down_bold_default)),
                props.btnLoading ? (openBlock(), createBlock(loadingBg, {
                  key: 0,
                  class: "back-to-bottom-loading-svg-bg"
                })) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["style"])
          ], true)
        ], 6)) : createCommentVNode("", true)
      ], 38);
    };
  }
});
const BubbleList = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-2f7f5231"]]);
export {
  BubbleList as default
};
//# sourceMappingURL=index.js.map
