import { defineComponent, ref, computed, onMounted, nextTick, watch, createElementBlock, openBlock, createElementVNode, withDirectives, createCommentVNode, withModifiers, normalizeStyle, normalizeClass, unref, toDisplayString, vShow } from "vue";
import '../../index3.css';/* empty css                                                                   */
import { _ as _export_sfc } from "../../_plugin-vue_export-helper-1tPrXgE0.js";
function useContentEditable(targetRef) {
  const selectAll = () => {
    const element = targetRef.value;
    if (element) {
      const range = document.createRange();
      const sel = window.getSelection();
      range.selectNodeContents(element);
      sel == null ? void 0 : sel.removeAllRanges();
      sel == null ? void 0 : sel.addRange(range);
    }
  };
  const deselectAll = () => {
    const sel = window.getSelection();
    sel == null ? void 0 : sel.removeAllRanges();
  };
  const moveToStart = () => {
    const element = targetRef.value;
    if (element) {
      const range = document.createRange();
      const sel = window.getSelection();
      if (element.firstChild) {
        range.setStart(element.firstChild, 0);
        range.setEnd(element.firstChild, 0);
        sel == null ? void 0 : sel.removeAllRanges();
        sel == null ? void 0 : sel.addRange(range);
      }
    }
  };
  const moveToEnd = () => {
    var _a;
    const element = targetRef.value;
    if (element) {
      const range = document.createRange();
      const sel = window.getSelection();
      const lastChild = element.lastChild;
      const length = lastChild ? ((_a = lastChild.textContent) == null ? void 0 : _a.length) || 0 : 0;
      if (lastChild) {
        range.setStart(lastChild, length);
        range.setEnd(lastChild, length);
        sel == null ? void 0 : sel.removeAllRanges();
        sel == null ? void 0 : sel.addRange(range);
      }
    }
  };
  const focusElement = () => {
    const element = targetRef.value;
    element == null ? void 0 : element.focus();
  };
  const blurElement = () => {
    const element = targetRef.value;
    if (element) {
      element.blur();
      const sel = window.getSelection();
      sel == null ? void 0 : sel.removeAllRanges();
    }
  };
  return {
    selectAll,
    deselectAll,
    moveToStart,
    moveToEnd,
    focusElement,
    blurElement
  };
}
const _hoisted_1 = { class: "el-editor-input-wrapper" };
const _hoisted_2 = ["contenteditable"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    modelValue: { default: "" },
    disabled: { type: Boolean, default: false },
    readOnly: { type: Boolean, default: false },
    placeholder: { default: "" },
    rows: { default: 1 },
    autosize: { type: [Boolean, Object], default: () => {
      return {
        minRows: 1,
        maxRows: 5
      };
    } },
    inputStyle: {},
    validateEvent: { type: Boolean },
    submitType: { default: "enter" }
  },
  emits: [
    "update:modelValue",
    "change",
    "compositionstart",
    "compositionend",
    "keydown",
    "handleBlur",
    "handleFocus"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const editableElement = ref(null);
    const isComposing = ref(false);
    const lineHeight = ref(20);
    const paddingTop = ref(0);
    const paddingBottom = ref(0);
    const paddingLeft = ref(0);
    const paddingRight = ref(0);
    const borderWidth = ref(0);
    const {
      selectAll,
      deselectAll,
      moveToStart,
      moveToEnd,
      focusElement,
      blurElement
    } = useContentEditable(editableElement);
    const showPlaceholder = computed(() => {
      return !isComposing.value && !props.modelValue && !!props.placeholder;
    });
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
      });
    });
    onMounted(() => {
      if (editableElement.value) {
        const style = window.getComputedStyle(editableElement.value);
        lineHeight.value = Number.parseFloat(style.lineHeight) || 20;
        paddingTop.value = Number.parseFloat(style.paddingTop) || 0;
        paddingBottom.value = Number.parseFloat(style.paddingBottom) || 0;
        paddingLeft.value = Number.parseFloat(style.paddingLeft) || 0;
        paddingRight.value = Number.parseFloat(style.paddingRight) || 0;
        borderWidth.value = Number.parseFloat(style.borderTopWidth) + Number.parseFloat(style.borderBottomWidth) || 0;
        editableElement.value.textContent = props.modelValue;
        adjustHeight();
        observer.observe(editableElement.value, {
          childList: true,
          subtree: true
        });
      }
    });
    const mergedStyle = computed(() => {
      const minRows = typeof props.autosize === "object" ? props.autosize.minRows ?? props.rows : props.rows;
      return {
        minHeight: `${minRows * lineHeight.value + paddingTop.value + paddingBottom.value + borderWidth.value}px !important`,
        resize: "none",
        ...typeof props.inputStyle === "object" ? props.inputStyle : {}
      };
    });
    const mergedPlaceholderStyle = computed(() => {
      return {
        padding: `${paddingTop.value}px ${paddingRight.value}px ${paddingBottom.value}px ${paddingLeft.value}px`
      };
    });
    function adjustHeight() {
      if (!editableElement.value || !props.autosize)
        return;
      nextTick(() => {
        const el = editableElement.value;
        el.style.height = "auto";
        const scrollHeight = el.scrollHeight;
        if (typeof props.autosize === "object") {
          const maxRows = props.autosize.maxRows ?? Number.MAX_SAFE_INTEGER;
          const maxHeight = maxRows * lineHeight.value + paddingTop.value + paddingBottom.value;
          el.style.height = `${Math.min(scrollHeight, maxHeight)}px`;
        } else {
          el.style.height = `${scrollHeight}px`;
        }
      });
    }
    function handleInput() {
      const element = editableElement.value;
      if (!element)
        return;
      adjustHeight();
    }
    function handleCompositionStart(e) {
      isComposing.value = true;
      emits("compositionstart", e);
    }
    function handleCompositionEnd(e) {
      isComposing.value = false;
      handleInput();
      emits("compositionend", e);
    }
    function handleKeyDown(e) {
      emits("keydown", e);
      const element = editableElement.value;
      if (!element)
        return;
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0)
        return;
      const range = sel.getRangeAt(0);
      range.startContainer;
    }
    watch(() => props.modelValue, (newVal) => {
      if (!editableElement.value)
        return;
    });
    function focus(e) {
      emits("handleFocus", e);
      focusElement();
    }
    function blur(e) {
      emits("handleBlur", e);
      blurElement();
    }
    function select() {
      if (editableElement.value) {
        selectAll();
      }
    }
    function clear() {
      if (editableElement.value) {
        deselectAll();
      }
    }
    __expose({
      focus,
      blur,
      select,
      clear,
      selectAll,
      moveToStart,
      moveToEnd,
      editableElement
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createElementVNode("div", {
          ref_key: "editableElement",
          ref: editableElement,
          contenteditable: !_ctx.disabled && !_ctx.readOnly,
          class: normalizeClass(["el-editor-input el-textarea__inner", { "is-disabled": _ctx.disabled, "is-readonly": _ctx.readOnly }]),
          style: normalizeStyle(unref(mergedStyle)),
          onInput: handleInput,
          onBlur: blur,
          onFocus: focus,
          onKeydown: withModifiers(handleKeyDown, ["stop"]),
          onCompositionstart: handleCompositionStart,
          onCompositionend: handleCompositionEnd
        }, null, 46, _hoisted_2),
        _ctx.placeholder ? withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          class: "el-editor-input-placeholder",
          style: normalizeStyle(unref(mergedPlaceholderStyle))
        }, toDisplayString(_ctx.placeholder), 5)), [
          [vShow, unref(showPlaceholder)]
        ]) : createCommentVNode("", true)
      ]);
    };
  }
});
const EditorInput = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-0907e17f"]]);
export {
  EditorInput as default
};
//# sourceMappingURL=index.js.map
