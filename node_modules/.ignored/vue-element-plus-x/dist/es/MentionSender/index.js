import { k as isString, b as buildProps, a as definePropType, n as isFunction, _ as _export_sfc, u as useNamespace, w as withInstall, E as ElIcon } from "../../base-BXVDO6W4.js";
import { U as UPDATE_MODEL_EVENT, I as INPUT_EVENT } from "../../el-input-AN-kaimj.js";
import { c as castArray } from "../../el-tooltip-m3ef_CN2.js";
import '../../index12.css';import '../../el-popper.css';/* empty css                       */
/* empty css                                                                   */
import { defineComponent, ref, computed, watch, createElementBlock, openBlock, normalizeClass, unref, createCommentVNode, withDirectives, renderSlot, createVNode, withCtx, Fragment, renderList, withModifiers, createElementVNode, toDisplayString, vShow, createTextVNode, nextTick, mergeProps, createSlots, normalizeProps, guardReactiveProps, normalizeStyle, useSlots, getCurrentInstance, Transition, isRef, createBlock } from "vue";
import { c as useFormDisabled, f as useId, E as ElButton } from "../../el-button-v5lTrsRk.js";
import { i as brush_default, t as top_default, m as microphone_default } from "../../index-CnlpUR18.js";
import { _ as _export_sfc$1 } from "../../_plugin-vue_export-helper-1tPrXgE0.js";
import { i as isFirefox, a as inputProps, u as useFocusController, E as ElInput } from "../../index-CCQp41bd.js";
import { E as ElTooltip } from "../../index-CGA7RalZ.js";
import { E as ElScrollbar } from "../../index-2FqfStMI.js";
import { u as useLocale } from "../../index-B1Zzy14a.js";
import { s as scrollIntoView } from "../../scroll-D2njqSuW.js";
import { E as EVENT_CODE } from "../../index-CQYjZvuF.js";
import { p as pick } from "../../pick-BGaY59Y-.js";
const filterOption = (pattern, option) => {
  const lowerCase = pattern.toLowerCase();
  const label = option.label || option.value;
  return label.toLowerCase().includes(lowerCase);
};
const getMentionCtx = (inputEl, prefix, split) => {
  const { selectionEnd } = inputEl;
  if (selectionEnd === null)
    return;
  const inputValue = inputEl.value;
  const prefixArray = castArray(prefix);
  let splitIndex = -1;
  let mentionCtx;
  for (let i = selectionEnd - 1; i >= 0; --i) {
    const char = inputValue[i];
    if (char === split || char === "\n" || char === "\r") {
      splitIndex = i;
      continue;
    }
    if (prefixArray.includes(char)) {
      const end = splitIndex === -1 ? selectionEnd : splitIndex;
      const pattern = inputValue.slice(i + 1, end);
      mentionCtx = {
        pattern,
        start: i + 1,
        end,
        prefix: char,
        prefixIndex: i,
        splitIndex,
        selectionEnd
      };
      break;
    }
  }
  return mentionCtx;
};
const getCursorPosition = (element, options = {
  debug: false,
  useSelectionEnd: false
}) => {
  const selectionStart = element.selectionStart !== null ? element.selectionStart : 0;
  const selectionEnd = element.selectionEnd !== null ? element.selectionEnd : 0;
  const position = options.useSelectionEnd ? selectionEnd : selectionStart;
  const properties = [
    "direction",
    "boxSizing",
    "width",
    "height",
    "overflowX",
    "overflowY",
    "borderTopWidth",
    "borderRightWidth",
    "borderBottomWidth",
    "borderLeftWidth",
    "borderStyle",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "fontStretch",
    "fontSize",
    "fontSizeAdjust",
    "lineHeight",
    "fontFamily",
    "textAlign",
    "textTransform",
    "textIndent",
    "textDecoration",
    "letterSpacing",
    "wordSpacing",
    "tabSize",
    "MozTabSize"
  ];
  if (options.debug) {
    const el = document.querySelector("#input-textarea-caret-position-mirror-div");
    if (el == null ? void 0 : el.parentNode)
      el.parentNode.removeChild(el);
  }
  const div = document.createElement("div");
  div.id = "input-textarea-caret-position-mirror-div";
  document.body.appendChild(div);
  const style = div.style;
  const computed2 = window.getComputedStyle(element);
  const isInput = element.nodeName === "INPUT";
  style.whiteSpace = isInput ? "nowrap" : "pre-wrap";
  if (!isInput)
    style.wordWrap = "break-word";
  style.position = "absolute";
  if (!options.debug)
    style.visibility = "hidden";
  properties.forEach((prop) => {
    if (isInput && prop === "lineHeight") {
      if (computed2.boxSizing === "border-box") {
        const height = Number.parseInt(computed2.height);
        const outerHeight = Number.parseInt(computed2.paddingTop) + Number.parseInt(computed2.paddingBottom) + Number.parseInt(computed2.borderTopWidth) + Number.parseInt(computed2.borderBottomWidth);
        const targetHeight = outerHeight + Number.parseInt(computed2.lineHeight);
        if (height > targetHeight) {
          style.lineHeight = `${height - outerHeight}px`;
        } else if (height === targetHeight) {
          style.lineHeight = computed2.lineHeight;
        } else {
          style.lineHeight = "0";
        }
      } else {
        style.lineHeight = computed2.height;
      }
    } else {
      style[prop] = computed2[prop];
    }
  });
  if (isFirefox()) {
    if (element.scrollHeight > Number.parseInt(computed2.height)) {
      style.overflowY = "scroll";
    }
  } else {
    style.overflow = "hidden";
  }
  div.textContent = element.value.slice(0, Math.max(0, position));
  if (isInput && div.textContent) {
    div.textContent = div.textContent.replace(/\s/g, " ");
  }
  const span = document.createElement("span");
  span.textContent = element.value.slice(Math.max(0, position)) || ".";
  span.style.position = "relative";
  span.style.left = `${-element.scrollLeft}px`;
  span.style.top = `${-element.scrollTop}px`;
  div.appendChild(span);
  const relativePosition = {
    top: span.offsetTop + Number.parseInt(computed2.borderTopWidth),
    left: span.offsetLeft + Number.parseInt(computed2.borderLeftWidth),
    height: Number.parseInt(computed2.fontSize) * 1.5
  };
  if (options.debug) {
    span.style.backgroundColor = "#aaa";
  } else {
    document.body.removeChild(div);
  }
  if (relativePosition.left >= element.clientWidth) {
    relativePosition.left = element.clientWidth;
  }
  return relativePosition;
};
const mentionProps = buildProps({
  ...inputProps,
  options: {
    type: definePropType(Array),
    default: () => []
  },
  prefix: {
    type: definePropType([String, Array]),
    default: "@",
    validator: (val) => {
      if (isString(val))
        return val.length === 1;
      return val.every((v) => isString(v) && v.length === 1);
    }
  },
  split: {
    type: String,
    default: " ",
    validator: (val) => val.length === 1
  },
  filterOption: {
    type: definePropType([Boolean, Function]),
    default: () => filterOption,
    validator: (val) => {
      if (val === false)
        return true;
      return isFunction(val);
    }
  },
  placement: {
    type: definePropType(String),
    default: "bottom"
  },
  showArrow: Boolean,
  offset: {
    type: Number,
    default: 0
  },
  whole: Boolean,
  checkIsWhole: {
    type: definePropType(Function)
  },
  modelValue: String,
  loading: Boolean,
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  }
});
const mentionEmits = {
  [UPDATE_MODEL_EVENT]: (value) => isString(value),
  input: (value) => isString(value),
  search: (pattern, prefix) => isString(pattern) && isString(prefix),
  select: (option, prefix) => isString(option.value) && isString(prefix),
  focus: (evt) => evt instanceof FocusEvent,
  blur: (evt) => evt instanceof FocusEvent
};
const mentionDropdownProps = buildProps({
  options: {
    type: definePropType(Array),
    default: () => []
  },
  loading: Boolean,
  disabled: Boolean,
  contentId: String,
  ariaLabel: String
});
const mentionDropdownEmits = {
  select: (option) => isString(option.value)
};
const __default__$1 = defineComponent({
  name: "ElMentionDropdown"
});
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  ...__default__$1,
  props: mentionDropdownProps,
  emits: mentionDropdownEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns = useNamespace("mention");
    const { t } = useLocale();
    const hoveringIndex = ref(-1);
    const scrollbarRef = ref();
    const optionRefs = ref();
    const dropdownRef = ref();
    const optionkls = (item, index) => [
      ns.be("dropdown", "item"),
      ns.is("hovering", hoveringIndex.value === index),
      ns.is("disabled", item.disabled || props.disabled)
    ];
    const handleSelect = (item) => {
      if (item.disabled || props.disabled)
        return;
      emit("select", item);
    };
    const handleMouseEnter = (index) => {
      hoveringIndex.value = index;
    };
    const filteredAllDisabled = computed(() => props.disabled || props.options.every((item) => item.disabled));
    const hoverOption = computed(() => props.options[hoveringIndex.value]);
    const selectHoverOption = () => {
      if (!hoverOption.value)
        return;
      emit("select", hoverOption.value);
    };
    const navigateOptions = (direction) => {
      const { options } = props;
      if (options.length === 0 || filteredAllDisabled.value)
        return;
      if (direction === "next") {
        hoveringIndex.value++;
        if (hoveringIndex.value === options.length) {
          hoveringIndex.value = 0;
        }
      } else if (direction === "prev") {
        hoveringIndex.value--;
        if (hoveringIndex.value < 0) {
          hoveringIndex.value = options.length - 1;
        }
      }
      const option = options[hoveringIndex.value];
      if (option.disabled) {
        navigateOptions(direction);
        return;
      }
      nextTick(() => scrollToOption(option));
    };
    const scrollToOption = (option) => {
      var _a, _b, _c, _d;
      const { options } = props;
      const index = options.findIndex((item) => item.value === option.value);
      const target = (_a = optionRefs.value) == null ? void 0 : _a[index];
      if (target) {
        const menu = (_c = (_b = dropdownRef.value) == null ? void 0 : _b.querySelector) == null ? void 0 : _c.call(_b, `.${ns.be("dropdown", "wrap")}`);
        if (menu) {
          scrollIntoView(menu, target);
        }
      }
      (_d = scrollbarRef.value) == null ? void 0 : _d.handleScroll();
    };
    const resetHoveringIndex = () => {
      if (filteredAllDisabled.value || props.options.length === 0) {
        hoveringIndex.value = -1;
      } else {
        hoveringIndex.value = 0;
      }
    };
    watch(() => props.options, resetHoveringIndex, {
      immediate: true
    });
    expose({
      hoveringIndex,
      navigateOptions,
      selectHoverOption,
      hoverOption
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "dropdownRef",
        ref: dropdownRef,
        class: normalizeClass(unref(ns).b("dropdown"))
      }, [
        _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(ns).be("dropdown", "header"))
        }, [
          renderSlot(_ctx.$slots, "header")
        ], 2)) : createCommentVNode("v-if", true),
        withDirectives(createVNode(unref(ElScrollbar), {
          id: _ctx.contentId,
          ref_key: "scrollbarRef",
          ref: scrollbarRef,
          tag: "ul",
          "wrap-class": unref(ns).be("dropdown", "wrap"),
          "view-class": unref(ns).be("dropdown", "list"),
          role: "listbox",
          "aria-label": _ctx.ariaLabel,
          "aria-orientation": "vertical"
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (item, index) => {
              return openBlock(), createElementBlock("li", {
                id: `${_ctx.contentId}-${index}`,
                ref_for: true,
                ref_key: "optionRefs",
                ref: optionRefs,
                key: index,
                class: normalizeClass(optionkls(item, index)),
                role: "option",
                "aria-disabled": item.disabled || _ctx.disabled || void 0,
                "aria-selected": hoveringIndex.value === index,
                onMousemove: ($event) => handleMouseEnter(index),
                onClick: withModifiers(($event) => handleSelect(item), ["stop"])
              }, [
                renderSlot(_ctx.$slots, "label", {
                  item,
                  index
                }, () => {
                  var _a;
                  return [
                    createElementVNode("span", null, toDisplayString((_a = item.label) != null ? _a : item.value), 1)
                  ];
                })
              ], 42, ["id", "aria-disabled", "aria-selected", "onMousemove", "onClick"]);
            }), 128))
          ]),
          _: 3
        }, 8, ["id", "wrap-class", "view-class", "aria-label"]), [
          [vShow, _ctx.options.length > 0 && !_ctx.loading]
        ]),
        _ctx.loading ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(unref(ns).be("dropdown", "loading"))
        }, [
          renderSlot(_ctx.$slots, "loading", {}, () => [
            createTextVNode(toDisplayString(unref(t)("el.mention.loading")), 1)
          ])
        ], 2)) : createCommentVNode("v-if", true),
        _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(unref(ns).be("dropdown", "footer"))
        }, [
          renderSlot(_ctx.$slots, "footer")
        ], 2)) : createCommentVNode("v-if", true)
      ], 2);
    };
  }
});
var ElMentionDropdown = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "mention-dropdown.vue"]]);
const __default__ = defineComponent({
  name: "ElMention",
  inheritAttrs: false
});
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  ...__default__,
  props: mentionProps,
  emits: mentionEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const passInputProps = computed(() => pick(props, Object.keys(inputProps)));
    const ns = useNamespace("mention");
    const disabled = useFormDisabled();
    const contentId = useId();
    const elInputRef = ref();
    const tooltipRef = ref();
    const dropdownRef = ref();
    const visible = ref(false);
    const cursorStyle = ref();
    const mentionCtx = ref();
    const computedPlacement = computed(() => props.showArrow ? props.placement : `${props.placement}-start`);
    const computedFallbackPlacements = computed(() => props.showArrow ? ["bottom", "top"] : ["bottom-start", "top-start"]);
    const filteredOptions = computed(() => {
      const { filterOption: filterOption2, options } = props;
      if (!mentionCtx.value || !filterOption2)
        return options;
      return options.filter((option) => filterOption2(mentionCtx.value.pattern, option));
    });
    const dropdownVisible = computed(() => {
      return visible.value && (!!filteredOptions.value.length || props.loading);
    });
    const hoveringId = computed(() => {
      var _a;
      return `${contentId.value}-${(_a = dropdownRef.value) == null ? void 0 : _a.hoveringIndex}`;
    });
    const handleInputChange = (value) => {
      emit(UPDATE_MODEL_EVENT, value);
      emit(INPUT_EVENT, value);
      syncAfterCursorMove();
    };
    const handleInputKeyDown = (event) => {
      var _a, _b, _c, _d;
      if (!("code" in event) || ((_a = elInputRef.value) == null ? void 0 : _a.isComposing))
        return;
      switch (event.code) {
        case EVENT_CODE.left:
        case EVENT_CODE.right:
          syncAfterCursorMove();
          break;
        case EVENT_CODE.up:
        case EVENT_CODE.down:
          if (!visible.value)
            return;
          event.preventDefault();
          (_b = dropdownRef.value) == null ? void 0 : _b.navigateOptions(event.code === EVENT_CODE.up ? "prev" : "next");
          break;
        case EVENT_CODE.enter:
        case EVENT_CODE.numpadEnter:
          if (!visible.value)
            return;
          event.preventDefault();
          if ((_c = dropdownRef.value) == null ? void 0 : _c.hoverOption) {
            (_d = dropdownRef.value) == null ? void 0 : _d.selectHoverOption();
          } else {
            visible.value = false;
          }
          break;
        case EVENT_CODE.esc:
          if (!visible.value)
            return;
          event.preventDefault();
          visible.value = false;
          break;
        case EVENT_CODE.backspace:
          if (props.whole && mentionCtx.value) {
            const { splitIndex, selectionEnd, pattern, prefixIndex, prefix } = mentionCtx.value;
            const inputEl = getInputEl();
            if (!inputEl)
              return;
            const inputValue = inputEl.value;
            const matchOption = props.options.find((item) => item.value === pattern);
            const isWhole = isFunction(props.checkIsWhole) ? props.checkIsWhole(pattern, prefix) : matchOption;
            if (isWhole && splitIndex !== -1 && splitIndex + 1 === selectionEnd) {
              event.preventDefault();
              const newValue = inputValue.slice(0, prefixIndex) + inputValue.slice(splitIndex + 1);
              emit(UPDATE_MODEL_EVENT, newValue);
              const newSelectionEnd = prefixIndex;
              nextTick(() => {
                inputEl.selectionStart = newSelectionEnd;
                inputEl.selectionEnd = newSelectionEnd;
                syncDropdownVisible();
              });
            }
          }
      }
    };
    const { wrapperRef } = useFocusController(elInputRef, {
      beforeFocus() {
        return disabled.value;
      },
      afterFocus() {
        syncAfterCursorMove();
      },
      beforeBlur(event) {
        var _a;
        return (_a = tooltipRef.value) == null ? void 0 : _a.isFocusInsideContent(event);
      },
      afterBlur() {
        visible.value = false;
      }
    });
    const handleInputMouseDown = () => {
      syncAfterCursorMove();
    };
    const handleSelect = (item) => {
      if (!mentionCtx.value)
        return;
      const inputEl = getInputEl();
      if (!inputEl)
        return;
      const inputValue = inputEl.value;
      const { split } = props;
      const newEndPart = inputValue.slice(mentionCtx.value.end);
      const alreadySeparated = newEndPart.startsWith(split);
      const newMiddlePart = `${item.value}${alreadySeparated ? "" : split}`;
      const newValue = inputValue.slice(0, mentionCtx.value.start) + newMiddlePart + newEndPart;
      emit(UPDATE_MODEL_EVENT, newValue);
      emit(INPUT_EVENT, newValue);
      emit("select", item, mentionCtx.value.prefix);
      const newSelectionEnd = mentionCtx.value.start + newMiddlePart.length + (alreadySeparated ? 1 : 0);
      nextTick(() => {
        inputEl.selectionStart = newSelectionEnd;
        inputEl.selectionEnd = newSelectionEnd;
        inputEl.focus();
        syncDropdownVisible();
      });
    };
    const getInputEl = () => {
      var _a, _b;
      return props.type === "textarea" ? (_a = elInputRef.value) == null ? void 0 : _a.textarea : (_b = elInputRef.value) == null ? void 0 : _b.input;
    };
    const syncAfterCursorMove = () => {
      setTimeout(() => {
        syncCursor();
        syncDropdownVisible();
        nextTick(() => {
          var _a;
          return (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper();
        });
      }, 0);
    };
    const syncCursor = () => {
      const inputEl = getInputEl();
      if (!inputEl)
        return;
      const caretPosition = getCursorPosition(inputEl);
      const inputRect = inputEl.getBoundingClientRect();
      const elInputRect = elInputRef.value.$el.getBoundingClientRect();
      cursorStyle.value = {
        position: "absolute",
        width: 0,
        height: `${caretPosition.height}px`,
        left: `${caretPosition.left + inputRect.left - elInputRect.left}px`,
        top: `${caretPosition.top + inputRect.top - elInputRect.top}px`
      };
    };
    const syncDropdownVisible = () => {
      const inputEl = getInputEl();
      if (document.activeElement !== inputEl) {
        visible.value = false;
        return;
      }
      const { prefix, split } = props;
      mentionCtx.value = getMentionCtx(inputEl, prefix, split);
      if (mentionCtx.value && mentionCtx.value.splitIndex === -1) {
        visible.value = true;
        emit("search", mentionCtx.value.pattern, mentionCtx.value.prefix);
        return;
      }
      visible.value = false;
    };
    expose({
      input: elInputRef,
      tooltip: tooltipRef,
      dropdownVisible
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "wrapperRef",
        ref: wrapperRef,
        class: normalizeClass(unref(ns).b())
      }, [
        createVNode(unref(ElInput), mergeProps(mergeProps(unref(passInputProps), _ctx.$attrs), {
          ref_key: "elInputRef",
          ref: elInputRef,
          "model-value": _ctx.modelValue,
          disabled: unref(disabled),
          role: unref(dropdownVisible) ? "combobox" : void 0,
          "aria-activedescendant": unref(dropdownVisible) ? unref(hoveringId) || "" : void 0,
          "aria-controls": unref(dropdownVisible) ? unref(contentId) : void 0,
          "aria-expanded": unref(dropdownVisible) || void 0,
          "aria-label": _ctx.ariaLabel,
          "aria-autocomplete": unref(dropdownVisible) ? "none" : void 0,
          "aria-haspopup": unref(dropdownVisible) ? "listbox" : void 0,
          onInput: handleInputChange,
          onKeydown: handleInputKeyDown,
          onMousedown: handleInputMouseDown
        }), createSlots({
          _: 2
        }, [
          renderList(_ctx.$slots, (_, name) => {
            return {
              name,
              fn: withCtx((slotProps) => [
                renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotProps)))
              ])
            };
          })
        ]), 1040, ["model-value", "disabled", "role", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label", "aria-autocomplete", "aria-haspopup"]),
        createVNode(unref(ElTooltip), {
          ref_key: "tooltipRef",
          ref: tooltipRef,
          visible: unref(dropdownVisible),
          "popper-class": [unref(ns).e("popper"), _ctx.popperClass],
          "popper-options": _ctx.popperOptions,
          placement: unref(computedPlacement),
          "fallback-placements": unref(computedFallbackPlacements),
          effect: "light",
          pure: "",
          offset: _ctx.offset,
          "show-arrow": _ctx.showArrow
        }, {
          default: withCtx(() => [
            createElementVNode("div", {
              style: normalizeStyle(cursorStyle.value)
            }, null, 4)
          ]),
          content: withCtx(() => {
            var _a;
            return [
              createVNode(ElMentionDropdown, {
                ref_key: "dropdownRef",
                ref: dropdownRef,
                options: unref(filteredOptions),
                disabled: unref(disabled),
                loading: _ctx.loading,
                "content-id": unref(contentId),
                "aria-label": _ctx.ariaLabel,
                onSelect: handleSelect,
                onClick: withModifiers((_a = elInputRef.value) == null ? void 0 : _a.focus, ["stop"])
              }, createSlots({
                _: 2
              }, [
                renderList(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: withCtx((slotProps) => [
                      renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotProps)))
                    ])
                  };
                })
              ]), 1032, ["options", "disabled", "loading", "content-id", "aria-label", "onClick"])
            ];
          }),
          _: 3
        }, 8, ["visible", "popper-class", "popper-options", "placement", "fallback-placements", "offset", "show-arrow"])
      ], 2);
    };
  }
});
var Mention = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "mention.vue"]]);
const ElMention = withInstall(Mention);
const _hoisted_1$7 = { class: "el-send-button" };
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "index",
  emits: ["clear"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      const _component_el_button = ElButton;
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createVNode(_component_el_button, {
          circle: "",
          onClick: _cache[0] || (_cache[0] = ($event) => emit("clear"))
        }, {
          default: withCtx(() => [
            createVNode(_component_el_icon, null, {
              default: withCtx(() => [
                createVNode(unref(brush_default))
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]);
    };
  }
});
const ClearButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["__scopeId", "data-v-f14235eb"]]);
const _sfc_main$6 = {};
const _hoisted_1$6 = {
  viewBox: "0 0 1000 1000",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$6, _cache[0] || (_cache[0] = [
    createElementVNode("title", null, "Loading", -1),
    createElementVNode("rect", {
      fill: "currentColor",
      height: "250",
      rx: "24",
      ry: "24",
      width: "250",
      x: "375",
      y: "375"
    }, null, -1),
    createElementVNode("circle", {
      cx: "500",
      cy: "500",
      fill: "none",
      r: "450",
      stroke: "currentColor",
      "stroke-width": "100",
      opacity: "0.45"
    }, null, -1),
    createElementVNode("circle", {
      cx: "500",
      cy: "500",
      fill: "none",
      r: "450",
      stroke: "currentColor",
      "stroke-width": "100",
      "stroke-dasharray": "600 9999999"
    }, [
      createElementVNode("animateTransform", {
        attributeName: "transform",
        dur: "1s",
        from: "0 500 500",
        repeatCount: "indefinite",
        to: "360 500 500",
        type: "rotate"
      })
    ], -1)
  ]));
}
const loading$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["render", _sfc_render]]);
const _hoisted_1$5 = { class: "el-send-button" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "index",
  emits: ["cancel"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    return (_ctx, _cache) => {
      const _component_el_button = ElButton;
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        createVNode(_component_el_button, {
          circle: "",
          onClick: _cache[0] || (_cache[0] = ($event) => emits("cancel"))
        }, {
          default: withCtx(() => [
            createVNode(loading$1, { class: "loading-svg" })
          ]),
          _: 1
        })
      ]);
    };
  }
});
const LoadingButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["__scopeId", "data-v-c1944c77"]]);
const _hoisted_1$4 = { class: "el-send-button" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["submit"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      const _component_el_button = ElButton;
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createVNode(_component_el_button, {
          circle: "",
          disabled: props.disabled,
          onClick: _cache[0] || (_cache[0] = ($event) => emits("submit"))
        }, {
          default: withCtx(() => [
            createVNode(_component_el_icon, null, {
              default: withCtx(() => [
                createVNode(unref(top_default))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["disabled"])
      ]);
    };
  }
});
const _hoisted_1$3 = { class: "el-send-button" };
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      const _component_el_button = ElButton;
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createVNode(_component_el_button, { circle: "" }, {
          default: withCtx(() => [
            createVNode(_component_el_icon, null, {
              default: withCtx(() => [
                createVNode(unref(microphone_default))
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]);
    };
  }
});
const _hoisted_1$2 = ["viewBox"];
const _hoisted_2$1 = ["x", "y"];
const _hoisted_3$1 = ["values", "dur", "begin"];
const _hoisted_4$1 = ["values", "dur", "begin"];
const SIZE = 1e3;
const COUNT = 4;
const RECT_WIDTH = 140;
const RECT_HEIGHT_MIN = 250;
const RECT_HEIGHT_MAX = 500;
const DURATION = 0.8;
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "loading",
  props: {
    className: { default: "" }
  },
  setup(__props) {
    const RECT_RADIUS = RECT_WIDTH / 2;
    const rects = computed(() => {
      const dest = (SIZE - RECT_WIDTH * COUNT) / (COUNT - 1);
      return Array.from({ length: COUNT }).map((_, index) => {
        const x = index * (dest + RECT_WIDTH);
        const yMin = SIZE / 2 - RECT_HEIGHT_MIN / 2;
        const yMax = SIZE / 2 - RECT_HEIGHT_MAX / 2;
        return { x, yMin, yMax };
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("svg", {
        class: normalizeClass(_ctx.className),
        color: "currentColor",
        viewBox: `0 0 ${SIZE} ${SIZE}`,
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink"
      }, [
        _cache[0] || (_cache[0] = createElementVNode("title", null, "Speech Recording", -1)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(rects.value, (item, index) => {
          return openBlock(), createElementBlock("rect", {
            key: index,
            fill: "currentColor",
            rx: RECT_RADIUS,
            ry: RECT_RADIUS,
            height: RECT_HEIGHT_MIN,
            width: RECT_WIDTH,
            x: item.x,
            y: item.yMin
          }, [
            createElementVNode("animate", {
              attributeName: "height",
              values: `${RECT_HEIGHT_MIN}; ${RECT_HEIGHT_MAX}; ${RECT_HEIGHT_MIN}`,
              keyTimes: "0; 0.5; 1",
              dur: `${DURATION}s`,
              begin: `${DURATION / COUNT * index}s`,
              repeatCount: "indefinite"
            }, null, 8, _hoisted_3$1),
            createElementVNode("animate", {
              attributeName: "y",
              values: `${item.yMin}; ${item.yMax}; ${item.yMin}`,
              keyTimes: "0; 0.5; 1",
              dur: `${DURATION}s`,
              begin: `${DURATION / COUNT * index}s`,
              repeatCount: "indefinite"
            }, null, 8, _hoisted_4$1)
          ], 8, _hoisted_2$1);
        }), 128))
      ], 10, _hoisted_1$2);
    };
  }
});
const loading = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["__scopeId", "data-v-fc6a109c"]]);
const _hoisted_1$1 = { class: "el-send-button" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_el_button = ElButton;
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createVNode(_component_el_button, { circle: "" }, {
          default: withCtx(() => [
            createVNode(loading, { class: "loading-svg" })
          ]),
          _: 1
        })
      ]);
    };
  }
});
const SpeechLoadingButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["__scopeId", "data-v-afb4902e"]]);
const _hoisted_1 = {
  key: 0,
  class: "el-sender-header-wrap"
};
const _hoisted_2 = {
  key: 0,
  class: "el-sender-header"
};
const _hoisted_3 = {
  key: 0,
  class: "el-sender-prefix"
};
const _hoisted_4 = {
  key: 1,
  class: "el-sender-action-list"
};
const _hoisted_5 = { class: "el-sender-action-list-presets" };
const _hoisted_6 = {
  key: 2,
  class: "el-sender-updown-wrap"
};
const _hoisted_7 = {
  key: 0,
  class: "el-sender-prefix"
};
const _hoisted_8 = { class: "el-sender-action-list" };
const _hoisted_9 = { class: "el-sender-action-list-presets" };
const _hoisted_10 = {
  key: 0,
  class: "el-sender-footer"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    modelValue: { default: "" },
    placeholder: { default: "请输入内容" },
    autoSize: { default: () => ({
      minRows: 1,
      maxRows: 6
    }) },
    readOnly: { type: Boolean },
    disabled: { type: Boolean },
    loading: { type: Boolean },
    clearable: { type: Boolean },
    allowSpeech: { type: Boolean },
    submitType: { default: "enter" },
    headerAnimationTimer: { default: 300 },
    inputWidth: { default: "100%" },
    variant: { default: "default" },
    showUpdown: { type: Boolean, default: true },
    submitBtnDisabled: { type: Boolean, default: void 0 },
    inputStyle: { default: "" },
    options: { default: () => [] },
    filterOption: { type: Function, default: () => true },
    whole: { type: Boolean, default: false },
    checkIsWhole: { type: Function, default: () => true },
    triggerLoading: { type: Boolean, default: false },
    triggerStrings: { default: () => [] },
    triggerSplit: { default: " " },
    triggerPopoverPlacement: { default: "top" },
    triggerPopoverOffset: { default: 20 }
  },
  emits: ["update:modelValue", "submit", "cancel", "recordingChange", "search", "select"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const internalValue = computed({
      get() {
        return props.modelValue;
      },
      set(val) {
        if (props.readOnly || props.disabled)
          return;
        emits("update:modelValue", val);
      }
    });
    const instance = getCurrentInstance();
    const hasOnRecordingChangeListener = computed(() => {
      var _a;
      return !!((_a = instance == null ? void 0 : instance.vnode.props) == null ? void 0 : _a.onRecordingChange);
    });
    const senderRef = ref();
    const inputRef = ref();
    const isSubmitDisabled = computed(() => {
      if (typeof props.submitBtnDisabled === "boolean") {
        return props.submitBtnDisabled;
      }
      return !internalValue.value;
    });
    function onContentMouseDown(e) {
      if (e.target !== senderRef.value.querySelector(`.el-textarea__inner`)) {
        e.preventDefault();
      }
      inputRef.value.input.focus();
    }
    const visiableHeader = ref(false);
    function openHeader() {
      if (!slots.header)
        return false;
      if (props.readOnly)
        return false;
      visiableHeader.value = true;
    }
    function closeHeader() {
      if (!slots.header)
        return;
      if (props.readOnly)
        return;
      visiableHeader.value = false;
    }
    const recognition = ref(null);
    const speechLoading = ref(false);
    function startRecognition() {
      if (props.readOnly)
        return;
      if (hasOnRecordingChangeListener.value) {
        speechLoading.value = true;
        emits("recordingChange", true);
        return;
      }
      if ("webkitSpeechRecognition" in window) {
        recognition.value = new webkitSpeechRecognition();
        recognition.value.continuous = true;
        recognition.value.interimResults = true;
        recognition.value.lang = "zh-CN";
        recognition.value.onresult = (event) => {
          let results = "";
          for (let i = 0; i <= event.resultIndex; i++) {
            results += event.results[i][0].transcript;
          }
          if (!props.readOnly) {
            internalValue.value = results;
          }
        };
        recognition.value.onstart = () => {
          speechLoading.value = true;
        };
        recognition.value.onend = () => {
          speechLoading.value = false;
        };
        recognition.value.onerror = (event) => {
          speechLoading.value = false;
        };
        recognition.value.start();
      }
    }
    function stopRecognition() {
      if (hasOnRecordingChangeListener.value) {
        speechLoading.value = false;
        emits("recordingChange", false);
        return;
      }
      if (recognition.value) {
        recognition.value.stop();
        speechLoading.value = false;
      }
    }
    function submit() {
      if (props.readOnly || props.loading || props.disabled || isSubmitDisabled.value)
        return;
      emits("submit", internalValue.value);
    }
    function cancel() {
      if (props.readOnly)
        return;
      emits("cancel", internalValue.value);
    }
    function clear() {
      if (props.readOnly)
        return;
      inputRef.value.input.clear();
      internalValue.value = "";
    }
    function handleKeyDown(e) {
      if (props.readOnly)
        return;
      if (props.submitType === "enter") {
        if (e.shiftKey && e.keyCode === 13) {
          e.preventDefault();
          const cursorPosition = e.target.selectionStart;
          const textBeforeCursor = internalValue.value.slice(0, cursorPosition);
          const textAfterCursor = internalValue.value.slice(cursorPosition);
          internalValue.value = `${textBeforeCursor}
${textAfterCursor}`;
          e.target.setSelectionRange(cursorPosition + 1, cursorPosition + 1);
        } else if (e.keyCode === 13 && !e.shiftKey) {
          e.preventDefault();
          submit();
        }
      } else if (props.submitType === "shiftEnter") {
        if (e.shiftKey && e.keyCode === 13) {
          e.preventDefault();
          submit();
        } else if (e.keyCode === 13 && !e.shiftKey) {
          e.preventDefault();
          const cursorPosition = e.target.selectionStart;
          const textBeforeCursor = internalValue.value.slice(0, cursorPosition);
          const textAfterCursor = internalValue.value.slice(cursorPosition);
          internalValue.value = `${textBeforeCursor}
${textAfterCursor}`;
          e.target.setSelectionRange(cursorPosition + 1, cursorPosition + 1);
        }
      }
    }
    function blur() {
      if (props.readOnly) {
        return false;
      }
      inputRef.value.input.blur();
    }
    function focus(type = "all") {
      if (props.readOnly) {
        return false;
      }
      if (type === "all") {
        inputRef.value.input.select();
      } else if (type === "start") {
        focusToStart();
      } else if (type === "end") {
        focusToEnd();
      }
    }
    function focusToStart() {
      if (inputRef.value) {
        const textarea = inputRef.value.input.$el.querySelector("textarea");
        if (textarea) {
          textarea.focus();
          textarea.setSelectionRange(0, 0);
        }
      }
    }
    function focusToEnd() {
      if (inputRef.value) {
        const textarea = inputRef.value.input.$el.querySelector("textarea");
        if (textarea) {
          textarea.focus();
          textarea.setSelectionRange(internalValue.value.length, internalValue.value.length);
        }
      }
    }
    function handleSearch(pattern, prefix) {
      emits("search", pattern, prefix);
    }
    function handleSelect(option, prefix) {
      emits("select", option, prefix);
    }
    __expose({
      openHeader,
      // 打开头部
      closeHeader,
      // 关闭头部
      clear,
      // 清空输入框
      blur,
      // 失去焦点
      focus,
      // 获取焦点
      // 按钮操作
      submit,
      cancel,
      startRecognition,
      stopRecognition
    });
    return (_ctx, _cache) => {
      const _component_el_mention = ElMention;
      return openBlock(), createElementBlock("div", {
        class: "el-sender-wrap",
        style: normalizeStyle({ cursor: _ctx.disabled ? "not-allowed" : "default" })
      }, [
        createElementVNode("div", {
          ref_key: "senderRef",
          ref: senderRef,
          class: normalizeClass(["el-sender", {
            "el-sender-disabled": _ctx.disabled
          }]),
          style: normalizeStyle({
            "--el-box-shadow-tertiary": "0 1px 2px 0 rgba(0, 0, 0, 0.03), 0 1px 6px -1px rgba(0, 0, 0, 0.02), 0 2px 4px 0 rgba(0, 0, 0, 0.02)",
            "--el-sender-input-input-font-size": "14px",
            "--el-sender-header-animation-duration": `${_ctx.headerAnimationTimer}ms`
          })
        }, [
          createVNode(Transition, { name: "slide" }, {
            default: withCtx(() => [
              unref(visiableHeader) ? (openBlock(), createElementBlock("div", _hoisted_1, [
                _ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_2, [
                  renderSlot(_ctx.$slots, "header", {}, void 0, true)
                ])) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ]),
            _: 3
          }),
          createElementVNode("div", {
            class: normalizeClass(["el-sender-content", { "content-variant-updown": props.variant === "updown" }]),
            onMousedown: onContentMouseDown
          }, [
            _ctx.$slots.prefix && props.variant === "default" ? (openBlock(), createElementBlock("div", _hoisted_3, [
              renderSlot(_ctx.$slots, "prefix", {}, void 0, true)
            ])) : createCommentVNode("", true),
            createVNode(_component_el_mention, {
              ref_key: "inputRef",
              ref: inputRef,
              modelValue: unref(internalValue),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(internalValue) ? internalValue.value = $event : null),
              class: "el-sender-input",
              "input-style": props.inputStyle || {
                "resize": "none",
                "max-height": "176px",
                "max-width": _ctx.inputWidth
              },
              rows: 1,
              autosize: _ctx.autoSize,
              type: "textarea",
              "validate-event": false,
              placeholder: _ctx.placeholder,
              "read-only": _ctx.readOnly || _ctx.disabled,
              disabled: _ctx.disabled,
              options: props.options,
              "filter-option": props.filterOption,
              whole: props.whole,
              "check-is-whole": props.checkIsWhole,
              loading: props.triggerLoading,
              prefix: props.triggerStrings,
              split: props.triggerSplit,
              placement: props.triggerPopoverPlacement,
              offset: props.triggerPopoverOffset,
              onKeydown: withModifiers(handleKeyDown, ["stop"]),
              onSearch: handleSearch,
              onSelect: handleSelect
            }, createSlots({ _: 2 }, [
              _ctx.$slots["trigger-label"] ? {
                name: "label",
                fn: withCtx(({ item, index }) => [
                  renderSlot(_ctx.$slots, "trigger-label", {
                    item,
                    index
                  }, void 0, true)
                ]),
                key: "0"
              } : void 0,
              _ctx.$slots["trigger-loading"] ? {
                name: "loading",
                fn: withCtx(() => [
                  renderSlot(_ctx.$slots, "trigger-loading", {}, void 0, true)
                ]),
                key: "1"
              } : void 0,
              _ctx.$slots["trigger-header"] ? {
                name: "header",
                fn: withCtx(() => [
                  renderSlot(_ctx.$slots, "trigger-header", {}, void 0, true)
                ]),
                key: "2"
              } : void 0,
              _ctx.$slots["trigger-footer"] ? {
                name: "footer",
                fn: withCtx(() => [
                  renderSlot(_ctx.$slots, "trigger-footer", {}, void 0, true)
                ]),
                key: "3"
              } : void 0
            ]), 1032, ["modelValue", "input-style", "autosize", "placeholder", "read-only", "disabled", "options", "filter-option", "whole", "check-is-whole", "loading", "prefix", "split", "placement", "offset"]),
            props.variant === "default" ? (openBlock(), createElementBlock("div", _hoisted_4, [
              renderSlot(_ctx.$slots, "action-list", {}, () => [
                createElementVNode("div", _hoisted_5, [
                  !_ctx.loading ? (openBlock(), createBlock(unref(_sfc_main$4), {
                    key: 0,
                    disabled: unref(isSubmitDisabled),
                    onSubmit: submit
                  }, null, 8, ["disabled"])) : createCommentVNode("", true),
                  _ctx.loading ? (openBlock(), createBlock(unref(LoadingButton), {
                    key: 1,
                    onCancel: cancel
                  })) : createCommentVNode("", true),
                  !unref(speechLoading) && _ctx.allowSpeech ? (openBlock(), createBlock(unref(_sfc_main$3), {
                    key: 2,
                    onClick: startRecognition
                  })) : createCommentVNode("", true),
                  unref(speechLoading) && _ctx.allowSpeech ? (openBlock(), createBlock(unref(SpeechLoadingButton), {
                    key: 3,
                    onClick: stopRecognition
                  })) : createCommentVNode("", true),
                  _ctx.clearable ? (openBlock(), createBlock(unref(ClearButton), {
                    key: 4,
                    onClear: clear
                  })) : createCommentVNode("", true)
                ])
              ], true)
            ])) : createCommentVNode("", true),
            props.variant === "updown" && props.showUpdown ? (openBlock(), createElementBlock("div", _hoisted_6, [
              _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", _hoisted_7, [
                renderSlot(_ctx.$slots, "prefix", {}, void 0, true)
              ])) : createCommentVNode("", true),
              createElementVNode("div", _hoisted_8, [
                renderSlot(_ctx.$slots, "action-list", {}, () => [
                  createElementVNode("div", _hoisted_9, [
                    !_ctx.loading ? (openBlock(), createBlock(unref(_sfc_main$4), {
                      key: 0,
                      disabled: unref(isSubmitDisabled),
                      onSubmit: submit
                    }, null, 8, ["disabled"])) : createCommentVNode("", true),
                    _ctx.loading ? (openBlock(), createBlock(unref(LoadingButton), {
                      key: 1,
                      onCancel: cancel
                    })) : createCommentVNode("", true),
                    !unref(speechLoading) && _ctx.allowSpeech ? (openBlock(), createBlock(unref(_sfc_main$3), {
                      key: 2,
                      onClick: startRecognition
                    })) : createCommentVNode("", true),
                    unref(speechLoading) && _ctx.allowSpeech ? (openBlock(), createBlock(unref(SpeechLoadingButton), {
                      key: 3,
                      onClick: stopRecognition
                    })) : createCommentVNode("", true),
                    _ctx.clearable ? (openBlock(), createBlock(unref(ClearButton), {
                      key: 4,
                      onClear: clear
                    })) : createCommentVNode("", true)
                  ])
                ], true)
              ])
            ])) : createCommentVNode("", true)
          ], 34),
          createVNode(Transition, { name: "slide" }, {
            default: withCtx(() => [
              _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_10, [
                renderSlot(_ctx.$slots, "footer", {}, void 0, true)
              ])) : createCommentVNode("", true)
            ]),
            _: 3
          })
        ], 6)
      ], 4);
    };
  }
});
const MentionSender = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["__scopeId", "data-v-c9126f82"]]);
export {
  MentionSender as default
};
//# sourceMappingURL=index.js.map
