var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _instance, _transformer, _baseURL, _baseOptions, _onAbort, _onMessage, _onError, _onOpen, _type, _controller, _onFinish, _messages, _XRequest_instances, sendWithFetch_fn, sendWithSSE_fn;
import { ref } from "vue";
class XRequest {
  constructor({ baseURL, onAbort, onMessage, onError, baseOptions, transformer, type, onFinish, ...props } = {}) {
    __privateAdd(this, _XRequest_instances);
    __privateAdd(this, _instance, null);
    __privateAdd(this, _transformer);
    __privateAdd(this, _baseURL);
    __privateAdd(this, _baseOptions);
    __privateAdd(this, _onAbort);
    __privateAdd(this, _onMessage);
    __privateAdd(this, _onError);
    __privateAdd(this, _onOpen);
    __privateAdd(this, _type, "sse");
    __privateAdd(this, _controller, null);
    __privateAdd(this, _onFinish);
    __privateAdd(this, _messages, []);
    __privateSet(this, _baseURL, baseURL ?? "");
    __privateSet(this, _baseOptions, baseOptions ?? {});
    onAbort && __privateSet(this, _onAbort, onAbort);
    onMessage && __privateSet(this, _onMessage, onMessage);
    onError && __privateSet(this, _onError, onError);
    onFinish && __privateSet(this, _onFinish, onFinish);
    props.onOpen && __privateSet(this, _onOpen, props.onOpen);
    transformer && __privateSet(this, _transformer, transformer);
    type && __privateSet(this, _type, type);
    this.abort = this.abort.bind(this);
    this.send = this.send.bind(this);
  }
  send(url, options = {}) {
    switch (__privateGet(this, _type)) {
      case "fetch":
        __privateMethod(this, _XRequest_instances, sendWithFetch_fn).call(this, url, options);
        break;
      default:
        __privateMethod(this, _XRequest_instances, sendWithSSE_fn).call(this, url, options);
    }
    return this;
  }
  abort() {
    var _a, _b, _c, _d;
    (_b = (_a = __privateGet(this, _instance)) == null ? void 0 : _a.close) == null ? void 0 : _b.call(_a);
    __privateSet(this, _instance, null);
    (_c = __privateGet(this, _controller)) == null ? void 0 : _c.abort();
    __privateSet(this, _controller, null);
    (_d = __privateGet(this, _onAbort)) == null ? void 0 : _d.call(this, __privateGet(this, _messages));
    __privateSet(this, _messages, []);
  }
}
_instance = new WeakMap();
_transformer = new WeakMap();
_baseURL = new WeakMap();
_baseOptions = new WeakMap();
_onAbort = new WeakMap();
_onMessage = new WeakMap();
_onError = new WeakMap();
_onOpen = new WeakMap();
_type = new WeakMap();
_controller = new WeakMap();
_onFinish = new WeakMap();
_messages = new WeakMap();
_XRequest_instances = new WeakSet();
sendWithFetch_fn = function(url, options = {}) {
  __privateSet(this, _controller, new AbortController());
  const signal = __privateGet(this, _controller).signal;
  const fetchOptions = {
    ...options,
    signal
  };
  return fetch(__privateGet(this, _baseURL) + url, fetchOptions).then((res) => res.body).then(async (body) => {
    var _a, _b, _c, _d;
    if (!body)
      return Promise.reject(new Error("Response body is null in stream mode"));
    const reader = body.getReader();
    const decoder = new TextDecoder("utf-8");
    let done = false;
    while (!done) {
      const { value, done: streamDone } = await reader.read();
      done = streamDone;
      if (streamDone) {
        (_a = __privateGet(this, _onFinish)) == null ? void 0 : _a.call(this, __privateGet(this, _messages));
        return;
      }
      if (value) {
        const chunk = decoder.decode(value, { stream: true });
        const chunkUse = chunk.startsWith("data: ") ? chunk.slice(6) : chunk;
        try {
          const res = __privateGet(this, _transformer) ? __privateGet(this, _transformer).call(this, chunkUse) : chunkUse;
          __privateGet(this, _messages).push(res);
          (_b = __privateGet(this, _onMessage)) == null ? void 0 : _b.call(this, res);
        } catch (error) {
          (_c = __privateGet(this, _onError)) == null ? void 0 : _c.call(this, error);
          (_d = __privateGet(this, _controller)) == null ? void 0 : _d.abort();
          return Promise.reject(error);
        }
      }
    }
  }).catch((err) => {
    var _a, _b, _c;
    if (err.name === "AbortError") {
      (_a = __privateGet(this, _onAbort)) == null ? void 0 : _a.call(this, __privateGet(this, _messages));
      return;
    }
    (_b = __privateGet(this, _onError)) == null ? void 0 : _b.call(this, err);
    (_c = __privateGet(this, _controller)) == null ? void 0 : _c.abort();
  });
};
sendWithSSE_fn = function(url, options = {}) {
  const es = new EventSource(__privateGet(this, _baseURL) + url, { ...__privateGet(this, _baseOptions), ...options });
  es.onmessage = (e) => {
    var _a;
    const res = __privateGet(this, _transformer) ? __privateGet(this, _transformer).call(this, e.data) : e;
    (_a = __privateGet(this, _onMessage)) == null ? void 0 : _a.call(this, res);
  };
  es.onopen = () => {
    var _a;
    (_a = __privateGet(this, _onOpen)) == null ? void 0 : _a.call(this);
  };
  es.onerror = (ev) => {
    var _a, _b;
    if (es.readyState === EventSource.CLOSED) {
      (_a = __privateGet(this, _onFinish)) == null ? void 0 : _a.call(this, __privateGet(this, _messages));
    } else {
      (_b = __privateGet(this, _onError)) == null ? void 0 : _b.call(this, es, ev);
    }
    this.abort();
  };
  __privateSet(this, _instance, es);
  return es;
};
function useSend({ onAbort, sendHandler, abortHandler } = {}) {
  const loading = ref(false);
  const handleSend = (...args) => {
    if (loading.value)
      return;
    sendHandler == null ? void 0 : sendHandler(...args);
    loading.value = true;
  };
  const handleAbort = () => {
    loading.value = false;
    abortHandler == null ? void 0 : abortHandler();
    onAbort == null ? void 0 : onAbort();
  };
  const handleFinish = () => {
    loading.value = false;
  };
  return {
    loading,
    abort: handleAbort,
    send: handleSend,
    finish: handleFinish
  };
}
export {
  XRequest,
  useSend
};
//# sourceMappingURL=useSend.js.map
