export type PropertyKey = string | number | symbol;
export type AnyObject<T = any> = Record<PropertyKey, T>;
type WhiteSpace = ' ' | '\n' | '\t' | '\r' | '\f' | '\v';
type TrimLeft<S extends string> = S extends `${WhiteSpace}${infer R}` ? TrimLeft<R> : S;
type TrimRight<S extends string> = S extends `${infer R}${WhiteSpace}` ? TrimRight<R> : S;
type Trim<S extends string = string> = TrimLeft<TrimRight<S>>;
type FilterEnumKeys<E> = {
    [K in keyof E]: E[K] extends EnumItem ? K : never;
}[keyof E];
export type EnumValue<E> = E[FilterEnumKeys<E>] extends EnumItem<infer V> ? V : never;
export type EnumLabel<E, K extends keyof E = FilterEnumKeys<E>> = E[K] extends EnumItem<any, infer L> ? L : never;
export type EnumOption<E> = E[FilterEnumKeys<E>];
export type EnumValues<E> = EnumValue<E>[];
type DefaultLabel = string | ((...args: any[]) => string);
export interface EnumImpl<T extends Record<string, EnumItem>> {
    options: (T[keyof T])[];
    dict: Record<EnumValue<T>, EnumLabel<T> | undefined>;
    has: (value: EnumValue<T> | string | number) => boolean;
    get: (value: EnumValue<T>) => EnumItem<EnumValue<T>, EnumLabel<T>> | undefined;
}
declare class EnumItem<V extends number | string = number | string, L = DefaultLabel, E extends AnyObject = AnyObject> {
    readonly value: V;
    readonly label?: L | undefined;
    readonly extra?: E | undefined;
    constructor(value: V, label?: L | undefined, extra?: E | undefined);
}
declare class Enum<T extends Record<string, EnumItem>> {
    #private;
    private constructor();
    static create<T extends Record<string, EnumItem>>(defs: T): T & EnumImpl<T>;
    static Item<V extends number | Trim = number | Trim, L extends DefaultLabel = DefaultLabel, E extends AnyObject = AnyObject>(value?: V, label?: L, extra?: E): EnumItem<V, L, E>;
}
export default Enum;
