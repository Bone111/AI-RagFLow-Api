const e=({splitSeparator:e=`

`,lineSeparator:t=void 0,trim:i=!0,json:a=!1,prefix:o=``,doneSymbol:s=void 0}={})=>({name:`sse`,async beforeStream(c,l){var u;if(!((u=l.extra)?.sseAble??!0))return c;let d=new TextDecoderStream,f=new n({splitSeparator:e}),p=new r({splitSeparator:t,trim:i,json:a,prefix:o,doneSymbol:s});return c.pipeThrough(d).pipeThrough(f).pipeThrough(p)}}),t=e=>(e??``).trim()!==``;var n=class extends TransformStream{constructor({splitSeparator:e=`

`}={}){let n=``,r={transform(r,i){n+=r;let a=n.split(e);a.slice(0,-1).forEach(e=>{t(e)&&i.enqueue(e)}),n=a[a.length-1]},flush(e){t(n)&&e.enqueue(n)}};super(r)}},r=class extends TransformStream{constructor({splitSeparator:e=void 0,trim:t=!0,json:n=!1,prefix:r=``,doneSymbol:i=void 0}={}){let a=(e,t)=>t?e.trim():e,o=e=>!!i&&e.slice(r.length).trim()===i,s={transform(i,s){let c=e?i.split(e):[i];for(let e of c)if(n)try{let t=JSON.parse(e.slice(r.length).trim());s.enqueue(t)}catch{o(e)?s.terminate():s.enqueue(a(e,t))}else o(e)?s.terminate():s.enqueue(a(e,t))}};super(s)}};Object.defineProperty(exports,`sseTextDecoderPlugin`,{enumerable:!0,get:function(){return e}});