import { b as buildProps, a as definePropType, j as isNumber, _ as _export_sfc, u as useNamespace, k as isString, e as addUnit, E as ElIcon, w as withInstall } from "../../base-BXVDO6W4.js";
import '../../index8.css';/* empty css                                                                   */
import { defineComponent, ref, computed, watch, createElementBlock, openBlock, normalizeStyle, normalizeClass, unref, createBlock, renderSlot, withCtx, resolveDynamicComponent, onUnmounted, createCommentVNode, createElementVNode, createVNode, Fragment, renderList } from "vue";
import { T as Typewriter } from "../../index-CD6jtNKK.js";
import { i as iconPropType, c as componentSizes } from "../../icon-ql50nNgG.js";
import { _ as _export_sfc$1 } from "../../_plugin-vue_export-helper-1tPrXgE0.js";
const avatarProps = buildProps({
  size: {
    type: [Number, String],
    values: componentSizes,
    default: "",
    validator: (val) => isNumber(val)
  },
  shape: {
    type: String,
    values: ["circle", "square"],
    default: "circle"
  },
  icon: {
    type: iconPropType
  },
  src: {
    type: String,
    default: ""
  },
  alt: String,
  srcSet: String,
  fit: {
    type: definePropType(String),
    default: "cover"
  }
});
const avatarEmits = {
  error: (evt) => evt instanceof Event
};
const __default__ = defineComponent({
  name: "ElAvatar"
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...__default__,
  props: avatarProps,
  emits: avatarEmits,
  setup(__props, { emit }) {
    const props = __props;
    const ns = useNamespace("avatar");
    const hasLoadError = ref(false);
    const avatarClass = computed(() => {
      const { size, icon, shape } = props;
      const classList = [ns.b()];
      if (isString(size))
        classList.push(ns.m(size));
      if (icon)
        classList.push(ns.m("icon"));
      if (shape)
        classList.push(ns.m(shape));
      return classList;
    });
    const sizeStyle = computed(() => {
      const { size } = props;
      return isNumber(size) ? ns.cssVarBlock({
        size: addUnit(size) || ""
      }) : void 0;
    });
    const fitStyle = computed(() => ({
      objectFit: props.fit
    }));
    watch(() => props.src, () => hasLoadError.value = false);
    function handleError(e) {
      hasLoadError.value = true;
      emit("error", e);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        class: normalizeClass(unref(avatarClass)),
        style: normalizeStyle(unref(sizeStyle))
      }, [
        (_ctx.src || _ctx.srcSet) && !hasLoadError.value ? (openBlock(), createElementBlock("img", {
          key: 0,
          src: _ctx.src,
          alt: _ctx.alt,
          srcset: _ctx.srcSet,
          style: normalizeStyle(unref(fitStyle)),
          onError: handleError
        }, null, 44, ["src", "alt", "srcset"])) : _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
          ]),
          _: 1
        })) : renderSlot(_ctx.$slots, "default", { key: 2 })
      ], 6);
    };
  }
});
var Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__file", "avatar.vue"]]);
const ElAvatar = withInstall(Avatar);
const _hoisted_1 = {
  key: 0,
  class: "el-bubble-avatar el-bubble-avatar-size"
};
const _hoisted_2 = {
  key: 1,
  class: "el-bubble-avatar-placeholder"
};
const _hoisted_3 = {
  key: 2,
  class: "el-bubble-avatar"
};
const _hoisted_4 = { class: "el-bubble-content-wrapper" };
const _hoisted_5 = {
  key: 0,
  class: "el-bubble-header"
};
const _hoisted_6 = {
  key: 2,
  class: "el-bubble-loading-wrap"
};
const _hoisted_7 = {
  key: 3,
  class: "el-bubble-loading-wrap"
};
const _hoisted_8 = {
  key: 1,
  class: "el-bubble-footer"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    content: { default: "" },
    reasoning_content: { default: "" },
    placement: { default: "start" },
    avatar: { default: "" },
    loading: { type: Boolean },
    shape: {},
    variant: { default: "filled" },
    isMarkdown: { type: Boolean },
    typing: { type: [Boolean, Object] },
    isFog: { type: [Boolean, Object] },
    maxWidth: { default: "500px" },
    avatarSize: { default: "" },
    avatarGap: { default: "12px" },
    avatarShape: { default: "circle" },
    avatarIcon: { default: "" },
    avatarSrcSet: { default: "" },
    avatarAlt: { default: "" },
    avatarFit: { default: "cover" },
    noStyle: { type: Boolean, default: false },
    highlight: { type: Function, default: void 0 },
    mdPlugins: { default: void 0 }
  },
  emits: ["start", "finish", "writing", "avatarError"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const internalDestroyed = ref(false);
    const isTypingClass = ref(false);
    watch(() => props.content, (newVal, oldVal) => {
      if (newVal !== oldVal && internalDestroyed.value) {
        restart();
      }
    });
    const typewriterRef = ref();
    const instance = {
      interrupt,
      continue: continueTyping,
      restart,
      destroy,
      renderedContent: computed(() => {
        var _a;
        return internalDestroyed.value ? "" : ((_a = typewriterRef.value) == null ? void 0 : _a.renderedContent.value) || "";
      }),
      isTyping: computed(
        () => {
          var _a;
          return !internalDestroyed.value && (((_a = typewriterRef.value) == null ? void 0 : _a.isTyping.value) || false);
        }
      ),
      progress: computed(
        () => {
          var _a;
          return internalDestroyed.value ? 0 : ((_a = typewriterRef.value) == null ? void 0 : _a.progress.value) || 0;
        }
      )
    };
    const _step = computed(() => {
      if (typeof props.typing === "object" && props.typing.step)
        return props.typing.step;
      else
        return 2;
    });
    const _suffix = computed(() => {
      if (typeof props.typing === "object" && props.typing.suffix)
        return props.typing.suffix;
      else
        return "|";
    });
    const _interval = computed(() => {
      if (typeof props.typing === "object" && props.typing.interval)
        return props.typing.interval;
      else
        return 50;
    });
    const _typing = computed(() => {
      if (typeof props.typing === "undefined") {
        return false;
      } else if (typeof props.typing === "boolean") {
        return props.typing;
      } else {
        return {
          suffix: _suffix.value,
          step: _step.value,
          interval: _interval.value
        };
      }
    });
    function onStart(instance2) {
      emits("start", instance2);
    }
    function onFinish(instance2) {
      isTypingClass.value = false;
      emits("finish", instance2);
    }
    function onWriting(instance2) {
      isTypingClass.value = true;
      emits("writing", instance2);
    }
    function avatarError(e) {
      emits("avatarError", e);
    }
    function interrupt() {
      var _a;
      (_a = typewriterRef.value) == null ? void 0 : _a.interrupt();
    }
    function continueTyping() {
      var _a;
      (_a = typewriterRef.value) == null ? void 0 : _a.continue();
    }
    function restart() {
      var _a;
      internalDestroyed.value = false;
      (_a = typewriterRef.value) == null ? void 0 : _a.restart();
    }
    function destroy() {
      var _a;
      (_a = typewriterRef.value) == null ? void 0 : _a.destroy();
      internalDestroyed.value = true;
    }
    const dots = [1, 2, 3];
    onUnmounted(instance.destroy);
    __expose(instance);
    return (_ctx, _cache) => {
      const _component_el_avatar = ElAvatar;
      return !unref(internalDestroyed) ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["el-bubble", {
          "el-bubble-start": _ctx.placement === "start",
          "el-bubble-end": _ctx.placement === "end",
          "el-bubble-no-style": _ctx.noStyle,
          "el-bubble-is-typing": unref(isTypingClass)
          // 新增动态类名
        }]),
        style: normalizeStyle({
          "--el-box-shadow-tertiary": `0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)`,
          "--bubble-content-max-width": `${_ctx.maxWidth}`,
          "--el-bubble-avatar-placeholder-width": `${_ctx.$slots.avatar ? "" : _ctx.avatarSize}`,
          "--el-bubble-avatar-placeholder-height": `${_ctx.$slots.avatar ? "" : _ctx.avatarSize}`,
          "--el-bubble-avatar-placeholder-gap": `${_ctx.avatarGap}`
        })
      }, [
        !_ctx.$slots.avatar && _ctx.avatar ? (openBlock(), createElementBlock("div", _hoisted_1, [
          createVNode(_component_el_avatar, {
            size: 0,
            src: _ctx.avatar,
            shape: _ctx.avatarShape,
            icon: _ctx.avatarIcon,
            "src-set": _ctx.avatarSrcSet,
            alt: _ctx.avatarFit,
            onError: avatarError
          }, null, 8, ["src", "shape", "icon", "src-set", "alt"])
        ])) : createCommentVNode("", true),
        !_ctx.$slots.avatar && !_ctx.avatar && _ctx.avatarSize ? (openBlock(), createElementBlock("div", _hoisted_2)) : createCommentVNode("", true),
        _ctx.$slots.avatar ? (openBlock(), createElementBlock("div", _hoisted_3, [
          renderSlot(_ctx.$slots, "avatar", {}, void 0, true)
        ])) : createCommentVNode("", true),
        createElementVNode("div", _hoisted_4, [
          _ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_5, [
            renderSlot(_ctx.$slots, "header", {}, void 0, true)
          ])) : createCommentVNode("", true),
          createElementVNode("div", {
            class: normalizeClass(["el-bubble-content", {
              "el-bubble-content-loading": _ctx.loading,
              "el-bubble-content-round": _ctx.shape === "round",
              "el-bubble-content-corner": _ctx.shape === "corner",
              "el-bubble-content-filled": _ctx.variant === "filled",
              "el-bubble-content-borderless": _ctx.variant === "borderless",
              "el-bubble-content-outlined": _ctx.variant === "outlined",
              "el-bubble-content-shadow": _ctx.variant === "shadow"
            }])
          }, [
            !_ctx.loading ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["el-typewriter", {
                "no-content": !_ctx.content
              }])
            }, [
              !_ctx.$slots.content && _ctx.content ? (openBlock(), createBlock(Typewriter, {
                key: 0,
                ref_key: "typewriterRef",
                ref: typewriterRef,
                typing: unref(_typing),
                content: _ctx.content,
                "is-markdown": _ctx.isMarkdown,
                "is-fog": props.isFog,
                highlight: props.highlight,
                "md-plugins": props.mdPlugins,
                onStart,
                onWriting,
                onFinish
              }, null, 8, ["typing", "content", "is-markdown", "is-fog", "highlight", "md-plugins"])) : createCommentVNode("", true)
            ], 2)) : createCommentVNode("", true),
            !unref(internalDestroyed) && _ctx.$slots.content && !_ctx.loading ? renderSlot(_ctx.$slots, "content", { key: 1 }, void 0, true) : createCommentVNode("", true),
            _ctx.loading && !_ctx.$slots.loading ? (openBlock(), createElementBlock("div", _hoisted_6, [
              (openBlock(), createElementBlock(Fragment, null, renderList(dots, (_, index) => {
                return createElementVNode("div", {
                  key: index,
                  class: "dot",
                  style: normalizeStyle({ animationDelay: `${index * 0.2}s` })
                }, null, 4);
              }), 64))
            ])) : createCommentVNode("", true),
            _ctx.loading && _ctx.$slots.loading ? (openBlock(), createElementBlock("div", _hoisted_7, [
              renderSlot(_ctx.$slots, "loading", {}, void 0, true)
            ])) : createCommentVNode("", true)
          ], 2),
          _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_8, [
            renderSlot(_ctx.$slots, "footer", {}, void 0, true)
          ])) : createCommentVNode("", true)
        ])
      ], 6)) : createCommentVNode("", true);
    };
  }
});
const Bubble = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["__scopeId", "data-v-7186c661"]]);
export {
  Bubble as default
};
//# sourceMappingURL=index.js.map
