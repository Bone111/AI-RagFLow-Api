import { n as isFunction, b as buildProps, a as definePropType, _ as _export_sfc, E as ElIcon, u as useNamespace, e as addUnit, w as withInstall, D as withNoopInstall } from "../../base-BXVDO6W4.js";
import { E as ElButton, b as useFormSize, f as useId } from "../../el-button-v5lTrsRk.js";
import { c as castArray } from "../../el-tooltip-m3ef_CN2.js";
import { defineComponent, renderSlot, ref, inject, computed, unref, provide, toRef, readonly, watch, resolveComponent, createBlock, openBlock, withCtx, createVNode, normalizeProps, guardReactiveProps, createElementBlock, normalizeClass, createCommentVNode, createSlots, mergeProps, getCurrentInstance, onBeforeUnmount, nextTick, Fragment, createElementVNode, withModifiers, resolveDynamicComponent, normalizeStyle, useSlots, toRefs, toDisplayString, renderList, createTextVNode, h, mergeModels, useModel, onMounted, withDirectives, vShow, markRaw } from "vue";
import { D as arrow_down_default, E as more_filled_default, l as loading_default, t as top_default, F as edit_default, A as delete_default } from "../../index-CnlpUR18.js";
import { g as get } from "../../index.vue_vue_type_style_index_0_scoped_499173a8_lang-Dspc3KiZ.js";
import '../../el-popper.css';/* empty css                       */
import { c as composeEventHandlers, O as OnlyChild, E as ElTooltip, w as whenMouse } from "../../index-CGA7RalZ.js";
import { E as ElScrollbar } from "../../index-2FqfStMI.js";
import { u as useEventListener, E as EVENT_CODE, F as FOCUS_TRAP_INJECTION_KEY } from "../../index-CQYjZvuF.js";
import { c as createCollectionWithScope, d as dropdownProps, E as ElCollection$1, a as dropdownItemProps, C as COLLECTION_ITEM_INJECTION_KEY$1, b as COLLECTION_ITEM_SIGN, e as ElCollectionItem$1, f as dropdownMenuProps, g as COLLECTION_INJECTION_KEY$1, F as FIRST_LAST_KEYS, L as LAST_KEYS } from "../../dropdown-BZbCs6iC.js";
import { u as useLocale } from "../../index-B1Zzy14a.js";
import { _ as _export_sfc$1 } from "../../_plugin-vue_export-helper-1tPrXgE0.js";
const composeRefs = (...refs) => {
  return (el) => {
    refs.forEach((ref2) => {
      if (isFunction(ref2)) {
        ref2(el);
      } else {
        ref2.value = el;
      }
    });
  };
};
const rovingFocusGroupProps = buildProps({
  style: { type: definePropType([String, Array, Object]) },
  currentTabId: {
    type: definePropType(String)
  },
  defaultCurrentTabId: String,
  loop: Boolean,
  dir: {
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  },
  orientation: {
    type: definePropType(String)
  },
  onBlur: Function,
  onFocus: Function,
  onMousedown: Function
});
const {
  ElCollection,
  ElCollectionItem,
  COLLECTION_INJECTION_KEY,
  COLLECTION_ITEM_INJECTION_KEY
} = createCollectionWithScope("RovingFocusGroup");
const ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
const ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");
const MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
const getDirectionAwareKey = (key, dir) => {
  return key;
};
const getFocusIntent = (event, orientation, dir) => {
  const key = getDirectionAwareKey(event.code);
  return MAP_KEY_TO_FOCUS_INTENT[key];
};
const reorderArray = (array, atIdx) => {
  return array.map((_, idx) => array[(idx + atIdx) % array.length]);
};
const focusFirst = (elements) => {
  const { activeElement: prevActive } = document;
  for (const element of elements) {
    if (element === prevActive)
      return;
    element.focus();
    if (prevActive !== document.activeElement)
      return;
  }
};
const CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
const ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
const EVT_OPTS = { bubbles: false, cancelable: true };
const _sfc_main$8 = defineComponent({
  name: "ElRovingFocusGroupImpl",
  inheritAttrs: false,
  props: rovingFocusGroupProps,
  emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
  setup(props, { emit }) {
    var _a;
    const currentTabbedId = ref((_a = props.currentTabId || props.defaultCurrentTabId) != null ? _a : null);
    const isBackingOut = ref(false);
    const isClickFocus = ref(false);
    const rovingFocusGroupRef = ref();
    const { getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
    const rovingFocusGroupRootStyle = computed(() => {
      return [
        {
          outline: "none"
        },
        props.style
      ];
    });
    const onItemFocus = (tabbedId) => {
      emit(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
    };
    const onItemShiftTab = () => {
      isBackingOut.value = true;
    };
    const onMousedown = composeEventHandlers((e) => {
      var _a2;
      (_a2 = props.onMousedown) == null ? void 0 : _a2.call(props, e);
    }, () => {
      isClickFocus.value = true;
    });
    const onFocus = composeEventHandlers((e) => {
      var _a2;
      (_a2 = props.onFocus) == null ? void 0 : _a2.call(props, e);
    }, (e) => {
      const isKeyboardFocus = !unref(isClickFocus);
      const { target, currentTarget } = e;
      if (target === currentTarget && isKeyboardFocus && !unref(isBackingOut)) {
        const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
        currentTarget == null ? void 0 : currentTarget.dispatchEvent(entryFocusEvt);
        if (!entryFocusEvt.defaultPrevented) {
          const items = getItems().filter((item) => item.focusable);
          const activeItem = items.find((item) => item.active);
          const currentItem = items.find((item) => item.id === unref(currentTabbedId));
          const candidates = [activeItem, currentItem, ...items].filter(Boolean);
          const candidateNodes = candidates.map((item) => item.ref);
          focusFirst(candidateNodes);
        }
      }
      isClickFocus.value = false;
    });
    const onBlur = composeEventHandlers((e) => {
      var _a2;
      (_a2 = props.onBlur) == null ? void 0 : _a2.call(props, e);
    }, () => {
      isBackingOut.value = false;
    });
    const handleEntryFocus = (...args) => {
      emit("entryFocus", ...args);
    };
    provide(ROVING_FOCUS_GROUP_INJECTION_KEY, {
      currentTabbedId: readonly(currentTabbedId),
      loop: toRef(props, "loop"),
      tabIndex: computed(() => {
        return unref(isBackingOut) ? -1 : 0;
      }),
      rovingFocusGroupRef,
      rovingFocusGroupRootStyle,
      orientation: toRef(props, "orientation"),
      dir: toRef(props, "dir"),
      onItemFocus,
      onItemShiftTab,
      onBlur,
      onFocus,
      onMousedown
    });
    watch(() => props.currentTabId, (val) => {
      currentTabbedId.value = val != null ? val : null;
    });
    useEventListener(rovingFocusGroupRef, ENTRY_FOCUS_EVT, handleEntryFocus);
  }
});
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default");
}
var ElRovingFocusGroupImpl = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$6], ["__file", "roving-focus-group-impl.vue"]]);
const _sfc_main$7 = defineComponent({
  name: "ElRovingFocusGroup",
  components: {
    ElFocusGroupCollection: ElCollection,
    ElRovingFocusGroupImpl
  }
});
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_roving_focus_group_impl = resolveComponent("el-roving-focus-group-impl");
  const _component_el_focus_group_collection = resolveComponent("el-focus-group-collection");
  return openBlock(), createBlock(_component_el_focus_group_collection, null, {
    default: withCtx(() => [
      createVNode(_component_el_roving_focus_group_impl, normalizeProps(guardReactiveProps(_ctx.$attrs)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)
    ]),
    _: 3
  });
}
var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$5], ["__file", "roving-focus-group.vue"]]);
const DROPDOWN_INJECTION_KEY = Symbol("elDropdown");
const { ButtonGroup: ElButtonGroup } = ElButton;
const _sfc_main$6 = defineComponent({
  name: "ElDropdown",
  components: {
    ElButton,
    ElButtonGroup,
    ElScrollbar,
    ElDropdownCollection: ElCollection$1,
    ElTooltip,
    ElRovingFocusGroup,
    ElOnlyChild: OnlyChild,
    ElIcon,
    ArrowDown: arrow_down_default
  },
  props: dropdownProps,
  emits: ["visible-change", "click", "command"],
  setup(props, { emit }) {
    const _instance = getCurrentInstance();
    const ns = useNamespace("dropdown");
    const { t } = useLocale();
    const triggeringElementRef = ref();
    const referenceElementRef = ref();
    const popperRef = ref();
    const contentRef = ref();
    const scrollbar = ref(null);
    const currentTabId = ref(null);
    const isUsingKeyboard = ref(false);
    const wrapStyle = computed(() => ({
      maxHeight: addUnit(props.maxHeight)
    }));
    const dropdownTriggerKls = computed(() => [ns.m(dropdownSize.value)]);
    const trigger = computed(() => castArray(props.trigger));
    const defaultTriggerId = useId().value;
    const triggerId = computed(() => props.id || defaultTriggerId);
    watch([triggeringElementRef, trigger], ([triggeringElement, trigger2], [prevTriggeringElement]) => {
      var _a, _b, _c;
      if ((_a = prevTriggeringElement == null ? void 0 : prevTriggeringElement.$el) == null ? void 0 : _a.removeEventListener) {
        prevTriggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
      }
      if ((_b = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _b.removeEventListener) {
        triggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
      }
      if (((_c = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _c.addEventListener) && trigger2.includes("hover")) {
        triggeringElement.$el.addEventListener("pointerenter", onAutofocusTriggerEnter);
      }
    }, { immediate: true });
    onBeforeUnmount(() => {
      var _a, _b;
      if ((_b = (_a = triggeringElementRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.removeEventListener) {
        triggeringElementRef.value.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
      }
    });
    function handleClick() {
      handleClose();
    }
    function handleClose() {
      var _a;
      (_a = popperRef.value) == null ? void 0 : _a.onClose();
    }
    function handleOpen() {
      var _a;
      (_a = popperRef.value) == null ? void 0 : _a.onOpen();
    }
    const dropdownSize = useFormSize();
    function commandHandler(...args) {
      emit("command", ...args);
    }
    function onAutofocusTriggerEnter() {
      var _a, _b;
      (_b = (_a = triggeringElementRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.focus();
    }
    function onItemEnter() {
    }
    function onItemLeave() {
      const contentEl = unref(contentRef);
      trigger.value.includes("hover") && (contentEl == null ? void 0 : contentEl.focus());
      currentTabId.value = null;
    }
    function handleCurrentTabIdChange(id) {
      currentTabId.value = id;
    }
    function handleEntryFocus(e) {
      if (!isUsingKeyboard.value) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
    }
    function handleBeforeShowTooltip() {
      emit("visible-change", true);
    }
    function handleShowTooltip(event) {
      var _a;
      if ((event == null ? void 0 : event.type) === "keydown") {
        (_a = contentRef.value) == null ? void 0 : _a.focus();
      }
    }
    function handleBeforeHideTooltip() {
      emit("visible-change", false);
    }
    provide(DROPDOWN_INJECTION_KEY, {
      contentRef,
      role: computed(() => props.role),
      triggerId,
      isUsingKeyboard,
      onItemEnter,
      onItemLeave
    });
    provide("elDropdown", {
      instance: _instance,
      dropdownSize,
      handleClick,
      commandHandler,
      trigger: toRef(props, "trigger"),
      hideOnClick: toRef(props, "hideOnClick")
    });
    const onFocusAfterTrapped = (e) => {
      var _a, _b;
      e.preventDefault();
      (_b = (_a = contentRef.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a, {
        preventScroll: true
      });
    };
    const handlerMainButtonClick = (event) => {
      emit("click", event);
    };
    return {
      t,
      ns,
      scrollbar,
      wrapStyle,
      dropdownTriggerKls,
      dropdownSize,
      triggerId,
      currentTabId,
      handleCurrentTabIdChange,
      handlerMainButtonClick,
      handleEntryFocus,
      handleClose,
      handleOpen,
      handleBeforeShowTooltip,
      handleShowTooltip,
      handleBeforeHideTooltip,
      onFocusAfterTrapped,
      popperRef,
      contentRef,
      triggeringElementRef,
      referenceElementRef
    };
  }
});
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_el_dropdown_collection = resolveComponent("el-dropdown-collection");
  const _component_el_roving_focus_group = resolveComponent("el-roving-focus-group");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_only_child = resolveComponent("el-only-child");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  const _component_el_button = resolveComponent("el-button");
  const _component_arrow_down = resolveComponent("arrow-down");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_el_button_group = resolveComponent("el-button-group");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)])
  }, [
    createVNode(_component_el_tooltip, {
      ref: "popperRef",
      role: _ctx.role,
      effect: _ctx.effect,
      "fallback-placements": ["bottom", "top"],
      "popper-options": _ctx.popperOptions,
      "gpu-acceleration": false,
      "hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
      "manual-mode": true,
      placement: _ctx.placement,
      "popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
      "reference-element": (_a = _ctx.referenceElementRef) == null ? void 0 : _a.$el,
      trigger: _ctx.trigger,
      "trigger-keys": _ctx.triggerKeys,
      "trigger-target-el": _ctx.contentRef,
      "show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
      "stop-popper-mouse-event": false,
      "virtual-ref": _ctx.triggeringElementRef,
      "virtual-triggering": _ctx.splitButton,
      disabled: _ctx.disabled,
      transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
      teleported: _ctx.teleported,
      pure: "",
      persistent: _ctx.persistent,
      onBeforeShow: _ctx.handleBeforeShowTooltip,
      onShow: _ctx.handleShowTooltip,
      onBeforeHide: _ctx.handleBeforeHideTooltip
    }, createSlots({
      content: withCtx(() => [
        createVNode(_component_el_scrollbar, {
          ref: "scrollbar",
          "wrap-style": _ctx.wrapStyle,
          tag: "div",
          "view-class": _ctx.ns.e("list")
        }, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_group, {
              loop: _ctx.loop,
              "current-tab-id": _ctx.currentTabId,
              orientation: "horizontal",
              onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
              onEntryFocus: _ctx.handleEntryFocus
            }, {
              default: withCtx(() => [
                createVNode(_component_el_dropdown_collection, null, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "dropdown")
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
          ]),
          _: 3
        }, 8, ["wrap-style", "view-class"])
      ]),
      _: 2
    }, [
      !_ctx.splitButton ? {
        name: "default",
        fn: withCtx(() => [
          createVNode(_component_el_only_child, {
            id: _ctx.triggerId,
            ref: "triggeringElementRef",
            role: "button",
            tabindex: _ctx.tabindex
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "tabindex"])
        ])
      } : void 0
    ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "persistent", "onBeforeShow", "onShow", "onBeforeHide"]),
    _ctx.splitButton ? (openBlock(), createBlock(_component_el_button_group, { key: 0 }, {
      default: withCtx(() => [
        createVNode(_component_el_button, mergeProps({ ref: "referenceElementRef" }, _ctx.buttonProps, {
          size: _ctx.dropdownSize,
          type: _ctx.type,
          disabled: _ctx.disabled,
          tabindex: _ctx.tabindex,
          onClick: _ctx.handlerMainButtonClick
        }), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
        createVNode(_component_el_button, mergeProps({
          id: _ctx.triggerId,
          ref: "triggeringElementRef"
        }, _ctx.buttonProps, {
          role: "button",
          size: _ctx.dropdownSize,
          type: _ctx.type,
          class: _ctx.ns.e("caret-button"),
          disabled: _ctx.disabled,
          tabindex: _ctx.tabindex,
          "aria-label": _ctx.t("el.dropdown.toggleDropdown")
        }), {
          default: withCtx(() => [
            createVNode(_component_el_icon, {
              class: normalizeClass(_ctx.ns.e("icon"))
            }, {
              default: withCtx(() => [
                createVNode(_component_arrow_down)
              ]),
              _: 1
            }, 8, ["class"])
          ]),
          _: 1
        }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
      ]),
      _: 3
    })) : createCommentVNode("v-if", true)
  ], 2);
}
var Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$4], ["__file", "dropdown.vue"]]);
const _sfc_main$5 = defineComponent({
  components: {
    ElRovingFocusCollectionItem: ElCollectionItem
  },
  props: {
    focusable: {
      type: Boolean,
      default: true
    },
    active: {
      type: Boolean,
      default: false
    }
  },
  emits: ["mousedown", "focus", "keydown"],
  setup(props, { emit }) {
    const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
    const { getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
    const id = useId();
    const rovingFocusGroupItemRef = ref();
    const handleMousedown = composeEventHandlers((e) => {
      emit("mousedown", e);
    }, (e) => {
      if (!props.focusable) {
        e.preventDefault();
      } else {
        onItemFocus(unref(id));
      }
    });
    const handleFocus = composeEventHandlers((e) => {
      emit("focus", e);
    }, () => {
      onItemFocus(unref(id));
    });
    const handleKeydown = composeEventHandlers((e) => {
      emit("keydown", e);
    }, (e) => {
      const { code, shiftKey, target, currentTarget } = e;
      if (code === EVENT_CODE.tab && shiftKey) {
        onItemShiftTab();
        return;
      }
      if (target !== currentTarget)
        return;
      const focusIntent = getFocusIntent(e);
      if (focusIntent) {
        e.preventDefault();
        const items = getItems().filter((item) => item.focusable);
        let elements = items.map((item) => item.ref);
        switch (focusIntent) {
          case "last": {
            elements.reverse();
            break;
          }
          case "prev":
          case "next": {
            if (focusIntent === "prev") {
              elements.reverse();
            }
            const currentIdx = elements.indexOf(currentTarget);
            elements = loop.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
            break;
          }
        }
        nextTick(() => {
          focusFirst(elements);
        });
      }
    });
    const isCurrentTab = computed(() => currentTabbedId.value === unref(id));
    provide(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
      rovingFocusGroupItemRef,
      tabIndex: computed(() => unref(isCurrentTab) ? 0 : -1),
      handleMousedown,
      handleFocus,
      handleKeydown
    });
    return {
      id,
      handleKeydown,
      handleFocus,
      handleMousedown
    };
  }
});
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_roving_focus_collection_item = resolveComponent("el-roving-focus-collection-item");
  return openBlock(), createBlock(_component_el_roving_focus_collection_item, {
    id: _ctx.id,
    focusable: _ctx.focusable,
    active: _ctx.active
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "focusable", "active"]);
}
var ElRovingFocusItem = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$3], ["__file", "roving-focus-item.vue"]]);
const _sfc_main$4 = defineComponent({
  name: "DropdownItemImpl",
  components: {
    ElIcon
  },
  props: dropdownItemProps,
  emits: ["pointermove", "pointerleave", "click", "clickimpl"],
  setup(_, { emit }) {
    const ns = useNamespace("dropdown");
    const { role: menuRole } = inject(DROPDOWN_INJECTION_KEY, void 0);
    const { collectionItemRef: dropdownCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY$1, void 0);
    const { collectionItemRef: rovingFocusCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY, void 0);
    const {
      rovingFocusGroupItemRef,
      tabIndex,
      handleFocus,
      handleKeydown: handleItemKeydown,
      handleMousedown
    } = inject(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
    const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
    const role = computed(() => {
      if (menuRole.value === "menu") {
        return "menuitem";
      } else if (menuRole.value === "navigation") {
        return "link";
      }
      return "button";
    });
    const handleKeydown = composeEventHandlers((e) => {
      if ([EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space].includes(e.code)) {
        e.preventDefault();
        e.stopImmediatePropagation();
        emit("clickimpl", e);
        return true;
      }
    }, handleItemKeydown);
    return {
      ns,
      itemRef,
      dataset: {
        [COLLECTION_ITEM_SIGN]: ""
      },
      role,
      tabIndex,
      handleFocus,
      handleKeydown,
      handleMousedown
    };
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = resolveComponent("el-icon");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.divided ? (openBlock(), createElementBlock("li", {
      key: 0,
      role: "separator",
      class: normalizeClass(_ctx.ns.bem("menu", "item", "divided"))
    }, null, 2)) : createCommentVNode("v-if", true),
    createElementVNode("li", mergeProps({ ref: _ctx.itemRef }, { ..._ctx.dataset, ..._ctx.$attrs }, {
      "aria-disabled": _ctx.disabled,
      class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
      tabindex: _ctx.tabIndex,
      role: _ctx.role,
      onClick: (e) => _ctx.$emit("clickimpl", e),
      onFocus: _ctx.handleFocus,
      onKeydown: withModifiers(_ctx.handleKeydown, ["self"]),
      onMousedown: _ctx.handleMousedown,
      onPointermove: (e) => _ctx.$emit("pointermove", e),
      onPointerleave: (e) => _ctx.$emit("pointerleave", e)
    }), [
      _ctx.icon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
        ]),
        _: 1
      })) : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default")
    ], 16, ["aria-disabled", "tabindex", "role", "onClick", "onFocus", "onKeydown", "onMousedown", "onPointermove", "onPointerleave"])
  ], 64);
}
var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$2], ["__file", "dropdown-item-impl.vue"]]);
const useDropdown = () => {
  const elDropdown = inject("elDropdown", {});
  const _elDropdownSize = computed(() => elDropdown == null ? void 0 : elDropdown.dropdownSize);
  return {
    elDropdown,
    _elDropdownSize
  };
};
const _sfc_main$3 = defineComponent({
  name: "ElDropdownItem",
  components: {
    ElDropdownCollectionItem: ElCollectionItem$1,
    ElRovingFocusItem,
    ElDropdownItemImpl
  },
  inheritAttrs: false,
  props: dropdownItemProps,
  emits: ["pointermove", "pointerleave", "click"],
  setup(props, { emit, attrs }) {
    const { elDropdown } = useDropdown();
    const _instance = getCurrentInstance();
    const itemRef = ref(null);
    const textContent = computed(() => {
      var _a, _b;
      return (_b = (_a = unref(itemRef)) == null ? void 0 : _a.textContent) != null ? _b : "";
    });
    const { onItemEnter, onItemLeave } = inject(DROPDOWN_INJECTION_KEY, void 0);
    const handlePointerMove = composeEventHandlers((e) => {
      emit("pointermove", e);
      return e.defaultPrevented;
    }, whenMouse((e) => {
      if (props.disabled) {
        onItemLeave(e);
        return;
      }
      const target = e.currentTarget;
      if (target === document.activeElement || target.contains(document.activeElement)) {
        return;
      }
      onItemEnter(e);
      if (!e.defaultPrevented) {
        target == null ? void 0 : target.focus();
      }
    }));
    const handlePointerLeave = composeEventHandlers((e) => {
      emit("pointerleave", e);
      return e.defaultPrevented;
    }, whenMouse(onItemLeave));
    const handleClick = composeEventHandlers((e) => {
      if (props.disabled) {
        return;
      }
      emit("click", e);
      return e.type !== "keydown" && e.defaultPrevented;
    }, (e) => {
      var _a, _b, _c;
      if (props.disabled) {
        e.stopImmediatePropagation();
        return;
      }
      if ((_a = elDropdown == null ? void 0 : elDropdown.hideOnClick) == null ? void 0 : _a.value) {
        (_b = elDropdown.handleClick) == null ? void 0 : _b.call(elDropdown);
      }
      (_c = elDropdown.commandHandler) == null ? void 0 : _c.call(elDropdown, props.command, _instance, e);
    });
    const propsAndAttrs = computed(() => ({ ...props, ...attrs }));
    return {
      handleClick,
      handlePointerMove,
      handlePointerLeave,
      textContent,
      propsAndAttrs
    };
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_el_dropdown_item_impl = resolveComponent("el-dropdown-item-impl");
  const _component_el_roving_focus_item = resolveComponent("el-roving-focus-item");
  const _component_el_dropdown_collection_item = resolveComponent("el-dropdown-collection-item");
  return openBlock(), createBlock(_component_el_dropdown_collection_item, {
    disabled: _ctx.disabled,
    "text-value": (_a = _ctx.textValue) != null ? _a : _ctx.textContent
  }, {
    default: withCtx(() => [
      createVNode(_component_el_roving_focus_item, {
        focusable: !_ctx.disabled
      }, {
        default: withCtx(() => [
          createVNode(_component_el_dropdown_item_impl, mergeProps(_ctx.propsAndAttrs, {
            onPointerleave: _ctx.handlePointerLeave,
            onPointermove: _ctx.handlePointerMove,
            onClickimpl: _ctx.handleClick
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
        ]),
        _: 3
      }, 8, ["focusable"])
    ]),
    _: 3
  }, 8, ["disabled", "text-value"]);
}
var DropdownItem = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$1], ["__file", "dropdown-item.vue"]]);
const _sfc_main$2 = defineComponent({
  name: "ElDropdownMenu",
  props: dropdownMenuProps,
  setup(props) {
    const ns = useNamespace("dropdown");
    const { _elDropdownSize } = useDropdown();
    const size = _elDropdownSize.value;
    const { focusTrapRef, onKeydown } = inject(FOCUS_TRAP_INJECTION_KEY, void 0);
    const { contentRef, role, triggerId } = inject(DROPDOWN_INJECTION_KEY, void 0);
    const { collectionRef: dropdownCollectionRef, getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
    const {
      rovingFocusGroupRef,
      rovingFocusGroupRootStyle,
      tabIndex,
      onBlur,
      onFocus,
      onMousedown
    } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
    const { collectionRef: rovingFocusGroupCollectionRef } = inject(COLLECTION_INJECTION_KEY, void 0);
    const dropdownKls = computed(() => {
      return [ns.b("menu"), ns.bm("menu", size == null ? void 0 : size.value)];
    });
    const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
    const composedKeydown = composeEventHandlers((e) => {
      var _a;
      (_a = props.onKeydown) == null ? void 0 : _a.call(props, e);
    }, (e) => {
      const { currentTarget, code, target } = e;
      currentTarget.contains(target);
      if (EVENT_CODE.tab === code) {
        e.stopImmediatePropagation();
      }
      e.preventDefault();
      if (target !== unref(contentRef) || !FIRST_LAST_KEYS.includes(code))
        return;
      const items = getItems().filter((item) => !item.disabled);
      const targets = items.map((item) => item.ref);
      if (LAST_KEYS.includes(code)) {
        targets.reverse();
      }
      focusFirst(targets);
    });
    const handleKeydown = (e) => {
      composedKeydown(e);
      onKeydown(e);
    };
    return {
      size,
      rovingFocusGroupRootStyle,
      tabIndex,
      dropdownKls,
      role,
      triggerId,
      dropdownListWrapperRef,
      handleKeydown,
      onBlur,
      onFocus,
      onMousedown
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("ul", {
    ref: _ctx.dropdownListWrapperRef,
    class: normalizeClass(_ctx.dropdownKls),
    style: normalizeStyle(_ctx.rovingFocusGroupRootStyle),
    tabindex: -1,
    role: _ctx.role,
    "aria-labelledby": _ctx.triggerId,
    onBlur: _ctx.onBlur,
    onFocus: _ctx.onFocus,
    onKeydown: withModifiers(_ctx.handleKeydown, ["self"]),
    onMousedown: withModifiers(_ctx.onMousedown, ["self"])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 46, ["role", "aria-labelledby", "onBlur", "onFocus", "onKeydown", "onMousedown"]);
}
var DropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render], ["__file", "dropdown-menu.vue"]]);
const ElDropdown = withInstall(Dropdown, {
  DropdownItem,
  DropdownMenu
});
const ElDropdownItem = withNoopInstall(DropdownItem);
const ElDropdownMenu = withNoopInstall(DropdownMenu);
const _hoisted_1$1 = { class: "conversation-content" };
const _hoisted_2$1 = { class: "conversation-content-main" };
const _hoisted_3$1 = {
  key: 0,
  class: "conversation-prefix-icon"
};
const _hoisted_4$1 = { class: "conversation-label-container" };
const _hoisted_5 = {
  key: 0,
  class: "conversation-suffix-icon"
};
const _hoisted_6 = { key: 1 };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "item",
  props: {
    item: {},
    itemsStyle: {},
    itemsHoverStyle: {},
    itemsActiveStyle: {},
    itemsMenuOpenedStyle: {},
    prefixIcon: {},
    suffixIcon: {},
    showTooltip: { type: Boolean },
    labelMaxWidth: {},
    menu: {},
    showBuiltInMenu: { type: Boolean },
    tooltipPlacement: {},
    tooltipOffset: {},
    menuPlacement: {},
    menuOffset: {},
    menuMaxHeight: {},
    menuStyle: {},
    menuShowArrow: { type: Boolean },
    menuClassName: {},
    menuTeleported: { type: Boolean },
    active: { type: Boolean }
  },
  emits: ["click", "menuCommand"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const slots = useSlots();
    const {
      item,
      itemsStyle,
      itemsHoverStyle,
      itemsActiveStyle,
      itemsMenuOpenedStyle,
      showTooltip,
      labelMaxWidth,
      menu,
      showBuiltInMenu,
      tooltipPlacement,
      tooltipOffset,
      menuPlacement,
      menuOffset,
      menuMaxHeight,
      menuStyle,
      menuShowArrow,
      menuClassName,
      menuTeleported
    } = toRefs(props);
    function renderIcon(icon) {
      if (!icon)
        return null;
      return h(icon);
    }
    const prefixIconRender = computed(() => {
      return renderIcon(props.prefixIcon);
    });
    const suffixIconRender = computed(() => {
      return renderIcon(props.suffixIcon);
    });
    const isHovered = ref(false);
    function handleMouseEnter() {
      isHovered.value = true;
    }
    function handleMouseLeave() {
      isHovered.value = false;
    }
    function handleClick(key) {
      emit("click", key);
    }
    const isTextOverflow = computed(() => {
      return (label = "") => {
        if (!labelMaxWidth.value)
          return false;
        const span = document.createElement("span");
        span.style.visibility = "hidden";
        span.style.position = "absolute";
        span.style.whiteSpace = "nowrap";
        span.style.fontSize = "14px";
        span.textContent = label;
        document.body.appendChild(span);
        const textWidth = span.offsetWidth;
        document.body.removeChild(span);
        return textWidth > labelMaxWidth.value;
      };
    });
    const labelStyle = computed(() => {
      if (labelMaxWidth.value) {
        return {
          maxWidth: `${labelMaxWidth.value}px`,
          overflow: "hidden"
        };
      }
      return {};
    });
    const isShowMenuBtn = ref(false);
    const shouldShowMenu = computed(() => {
      return isHovered.value || props.active || isShowMenuBtn.value;
    });
    const menuButtonRef = ref(null);
    const mergedMenuStyle = computed(() => {
      return {
        ...menuStyle.value
      };
    });
    function camelToKebab(str) {
      return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
    }
    function updateMenuStatus(isOpen) {
      isShowMenuBtn.value = isOpen;
      if (isOpen) {
        nextTick(() => {
          const dropdownMenu = document.querySelectorAll(".conversation-dropdown-menu");
          if (dropdownMenu.length === 0) {
            return;
          }
          dropdownMenu.forEach((dropdownMenuItem) => {
            if (dropdownMenuItem && dropdownMenuItem.style.display !== "none") {
              const arrows = dropdownMenuItem.querySelectorAll(".el-popper__arrow");
              if (arrows.length === 0) {
                return;
              }
              arrows.forEach((arrow) => {
                arrow.style.display = menuShowArrow.value ? "block" : "none";
              });
              const items = dropdownMenuItem.querySelectorAll(".el-dropdown-menu__item:not(.is-disabled)");
              if (items.length === 0) {
                return;
              }
              items.forEach((item2, index) => {
                if (!menu.value || menu.value.length === 0) {
                  return;
                }
                const menuItemHoverStyle = menu.value[index].menuItemHoverStyle || {};
                const className = `custom-hover-${index}`;
                item2.classList.add(className);
                const style = document.createElement("style");
                style.textContent = `
              .${className}:hover,
              .${className}:focus {
                ${Object.entries(menuItemHoverStyle).map(([prop, val]) => `${camelToKebab(prop)}: ${val} !important;`).join(" ")}
              }
            `;
                document.head.appendChild(style);
              });
            }
          });
        });
      }
    }
    function menuCommand(command, item2) {
      if (slots.menu) {
        return false;
      }
      emit("menuCommand", command, item2);
    }
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      const _component_ElTooltip = ElTooltip;
      const _component_ElIcon = ElIcon;
      const _component_el_dropdown_item = ElDropdownItem;
      const _component_el_dropdown_menu = ElDropdownMenu;
      const _component_el_dropdown = ElDropdown;
      return openBlock(), createElementBlock("li", {
        key: unref(item).key,
        class: normalizeClass(["conversation-item", {
          disabled: unref(item).disabled,
          active: _ctx.active,
          hovered: unref(item).disabled ? false : unref(isHovered),
          "menu-opened": unref(isShowMenuBtn)
        }]),
        style: normalizeStyle({
          ...unref(itemsStyle),
          ...unref(isHovered) ? unref(itemsHoverStyle) : {},
          ...unref(isShowMenuBtn) ? unref(itemsMenuOpenedStyle) : {},
          ..._ctx.active ? unref(itemsActiveStyle) : {}
        }),
        onClick: _cache[2] || (_cache[2] = ($event) => handleClick(unref(item).key)),
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave
      }, [
        createElementVNode("div", _hoisted_1$1, [
          createElementVNode("div", _hoisted_2$1, [
            renderSlot(_ctx.$slots, "label", {}, () => [
              unref(prefixIconRender) ? (openBlock(), createElementBlock("span", _hoisted_3$1, [
                createVNode(_component_el_icon, null, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(prefixIconRender))))
                  ]),
                  _: 1
                })
              ])) : createCommentVNode("", true),
              createElementVNode("div", _hoisted_4$1, [
                unref(showTooltip) && unref(isTextOverflow)(unref(item).label) ? (openBlock(), createBlock(_component_ElTooltip, {
                  key: 0,
                  content: unref(item).label,
                  placement: unref(tooltipPlacement),
                  offset: unref(tooltipOffset),
                  effect: "dark"
                }, {
                  default: withCtx(() => [
                    createElementVNode("span", {
                      class: normalizeClass(["conversation-label", { "text-gradient": unref(isTextOverflow)(unref(item).label) }]),
                      style: normalizeStyle(unref(labelStyle))
                    }, toDisplayString(unref(item).label), 7)
                  ]),
                  _: 1
                }, 8, ["content", "placement", "offset"])) : (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass(["conversation-label", { "text-gradient": unref(isTextOverflow)(unref(item).label) }]),
                  style: normalizeStyle(unref(labelStyle))
                }, toDisplayString(unref(item).label), 7))
              ])
            ], true)
          ]),
          unref(suffixIconRender) ? (openBlock(), createElementBlock("span", _hoisted_5, [
            createVNode(_component_ElIcon, null, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(unref(suffixIconRender))))
              ]),
              _: 1
            })
          ])) : createCommentVNode("", true),
          unref(shouldShowMenu) && unref(showBuiltInMenu) ? (openBlock(), createElementBlock("div", _hoisted_6, [
            unref(menu) && unref(menu).length ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_key: "menuButtonRef",
              ref: menuButtonRef,
              class: "conversation-dropdown-more",
              onClick: _cache[1] || (_cache[1] = (e) => e.stopPropagation())
            }, [
              createVNode(_component_el_dropdown, {
                trigger: "click",
                placement: unref(menuPlacement),
                offset: unref(menuOffset),
                teleported: unref(menuTeleported),
                "popper-class": unref(menuClassName) ? `conversation-dropdown-menu ${unref(menuClassName)}` : "conversation-dropdown-menu",
                "max-height": unref(menuMaxHeight),
                disabled: unref(item).disabled,
                onVisibleChange: updateMenuStatus,
                onCommand: _cache[0] || (_cache[0] = (command) => menuCommand(command, unref(item)))
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "more-filled", normalizeProps(guardReactiveProps({
                    item: unref(item),
                    isHovered: unref(item).disabled ? false : unref(isHovered),
                    isActive: _ctx.active,
                    isMenuOpened: unref(isShowMenuBtn),
                    isDisabled: unref(item).disabled
                  })), () => [
                    createVNode(_component_el_icon, { class: "conversation-dropdown-more-icon" }, {
                      default: withCtx(() => [
                        createVNode(unref(more_filled_default))
                      ]),
                      _: 1
                    })
                  ], true)
                ]),
                dropdown: withCtx(() => [
                  renderSlot(_ctx.$slots, "menu", {}, () => [
                    createVNode(_component_el_dropdown_menu, {
                      style: normalizeStyle(unref(mergedMenuStyle))
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(menu), (menuItem) => {
                          return openBlock(), createBlock(_component_el_dropdown_item, {
                            key: menuItem.key,
                            icon: menuItem.icon,
                            disabled: menuItem.disabled,
                            divided: menuItem.divided,
                            command: menuItem.command,
                            style: normalizeStyle(menuItem.menuItemStyle)
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(menuItem.label), 1)
                            ]),
                            _: 2
                          }, 1032, ["icon", "disabled", "divided", "command", "style"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["style"])
                  ], true)
                ]),
                _: 3
              }, 8, ["placement", "offset", "teleported", "popper-class", "max-height", "disabled"])
            ], 512)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ])
      ], 38);
    };
  }
});
const Item = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["__scopeId", "data-v-a8ef9c64"]]);
const _hoisted_1 = { class: "conversations-scroll-wrapper" };
const _hoisted_2 = { class: "scroll-content" };
const _hoisted_3 = { class: "conversation-group-items" };
const _hoisted_4 = {
  key: 0,
  class: "conversations-load-more"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: /* @__PURE__ */ mergeModels({
    items: { default: () => [] },
    itemsStyle: { default: () => ({}) },
    itemsHoverStyle: { default: () => ({}) },
    itemsActiveStyle: { default: () => ({}) },
    itemsMenuOpenedStyle: { default: () => ({}) },
    style: { default: () => ({}) },
    labelMaxWidth: { default: void 0 },
    labelHeight: { default: 20 },
    showTooltip: { type: Boolean, default: () => false },
    tooltipPlacement: { default: "top" },
    tooltipOffset: { default: 12 },
    groupable: { type: [Boolean, Object], default: () => false },
    ungroupedTitle: { default: "未分组" },
    menu: { default: () => [
      {
        label: "重命名",
        key: "rename",
        icon: markRaw(edit_default),
        command: "rename"
      },
      {
        label: "删除",
        key: "delete",
        icon: markRaw(delete_default),
        command: "delete",
        menuItemHoverStyle: {
          color: "red",
          backgroundColor: "rgba(255, 0, 0, 0.1)"
        }
      }
    ] },
    showBuiltInMenu: { type: Boolean, default: false },
    menuPlacement: { default: "bottom-start" },
    menuOffset: { default: 50 },
    menuShowArrow: { type: Boolean, default: false },
    menuMaxHeight: {},
    menuStyle: { default: () => ({}) },
    menuClassName: { default: "" },
    menuTeleported: { type: Boolean, default: true },
    loadMore: {},
    loadMoreLoading: { type: Boolean, default: false },
    showToTopBtn: { type: Boolean, default: false },
    rowKey: { default: "id" },
    labelKey: { default: "label" }
  }, {
    "active": { required: false },
    "activeModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["menuCommand", "change"], ["update:active"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const activeKey = useModel(__props, "active");
    const itemsUse = computed(() => {
      return props.items.map((item, index) => ({
        ...item,
        uniqueKey: props.rowKey ? get(item, props.rowKey) : index.toString(),
        label: get(item, props.labelKey)
      }));
    });
    const mergedStyle = computed(() => {
      const defaultStyle = {
        padding: "10px 0 10px 10px",
        backgroundColor: "#fff",
        borderRadius: "8px",
        width: "280px",
        height: "0"
      };
      return { ...defaultStyle, ...props.style };
    });
    function handleClick(item) {
      if (item.disabled)
        return;
      emits("change", item);
      activeKey.value = item.uniqueKey;
    }
    const shouldUseGrouping = computed(() => {
      return !!props.groupable;
    });
    const filteredItems = computed(() => {
      return itemsUse.value;
    });
    const groups = computed(() => {
      if (!shouldUseGrouping.value)
        return [];
      if (!filteredItems.value || filteredItems.value.length === 0) {
        return [];
      }
      const groupMap = {};
      filteredItems.value.forEach((item) => {
        let groupName = null;
        if (item.group) {
          groupName = item.group;
        }
        const finalGroupName = groupName || props.ungroupedTitle;
        if (!groupMap[finalGroupName]) {
          groupMap[finalGroupName] = {
            title: finalGroupName,
            key: finalGroupName,
            children: [],
            isUngrouped: !groupName
            // 如果没有找到组名，则标记为未分组
          };
        }
        groupMap[finalGroupName].children.push(item);
      });
      const groupArray = Object.values(groupMap);
      if (typeof props.groupable === "object" && props.groupable.sort) {
        return groupArray.sort((a, b) => {
          if (a.isUngrouped)
            return 1;
          if (b.isUngrouped)
            return -1;
          const sortFn = props.groupable.sort;
          return sortFn ? sortFn(a.key, b.key) : 0;
        });
      }
      return groupArray.sort((a, b) => {
        if (a.isUngrouped)
          return 1;
        if (b.isUngrouped)
          return -1;
        return 0;
      });
    });
    const scrollbarRef = ref(null);
    const showScrollTop = ref(false);
    const groupRefs = ref({});
    const stickyGroupKeys = ref(/* @__PURE__ */ new Set());
    function handleScroll(e) {
      const scrollTop = e.scrollTop;
      showScrollTop.value = scrollTop > 200;
      const scrollbar = scrollbarRef.value;
      if (!scrollbar)
        return;
      const wrap = scrollbar.wrapRef;
      if (!wrap)
        return;
      const bottomOffset = 20;
      const scrollHeight = wrap.scrollHeight;
      const clientHeight = wrap.clientHeight;
      const isNearBottom = scrollHeight - scrollTop - clientHeight < bottomOffset;
      if (isNearBottom) {
        loadMoreData();
      }
      updateStickyStatus();
    }
    function updateStickyStatus(_e) {
      var _a;
      if (!shouldUseGrouping.value || groups.value.length === 0)
        return;
      stickyGroupKeys.value.clear();
      const scrollContainer = (_a = scrollbarRef.value) == null ? void 0 : _a.wrapRef;
      if (!scrollContainer)
        return;
      if (groups.value.length === 1) {
        stickyGroupKeys.value.add(groups.value[0].key);
        return;
      }
      const scrollContainerTop = scrollContainer.getBoundingClientRect().top;
      const containerHeight = scrollContainer.clientHeight;
      const scrollHeight = scrollContainer.scrollHeight;
      const scrollTop = scrollContainer.scrollTop;
      const isNearBottom = scrollHeight - scrollTop - containerHeight < 20;
      if (isNearBottom && groups.value.length > 0) {
        stickyGroupKeys.value.add(groups.value[groups.value.length - 1].key);
        return;
      }
      const visibleGroups = [];
      for (const group of groups.value) {
        const groupElement = groupRefs.value[group.key];
        if (groupElement) {
          const groupRect = groupElement.getBoundingClientRect();
          const relativeTop = groupRect.top - scrollContainerTop;
          if (relativeTop < containerHeight && relativeTop + groupRect.height > 0) {
            visibleGroups.push({
              group,
              relativeTop,
              height: groupRect.height
            });
          }
        }
      }
      visibleGroups.sort((a, b) => a.relativeTop - b.relativeTop);
      if (visibleGroups.length > 0) {
        const fullyVisibleGroup = visibleGroups.find((g) => g.relativeTop >= 0);
        if (fullyVisibleGroup) {
          stickyGroupKeys.value.add(fullyVisibleGroup.group.key);
        } else {
          stickyGroupKeys.value.add(visibleGroups[0].group.key);
        }
      } else if (groups.value.length > 0) {
        stickyGroupKeys.value.add(groups.value[0].key);
      }
    }
    function loadMoreData() {
      if (!props.loadMore)
        return;
      props.loadMore();
    }
    function scrollToTop() {
      var _a;
      (_a = scrollbarRef.value) == null ? void 0 : _a.setScrollTop(0);
    }
    function handleMenuItemClick(command, item) {
      emits("menuCommand", command, item);
    }
    function bindGroupRef(el, item) {
      if (el) {
        groupRefs.value[item.key] = el;
      }
    }
    onMounted(() => {
      if (shouldUseGrouping.value && groups.value.length > 0) {
        stickyGroupKeys.value.add(groups.value[0].key);
      }
    });
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      const _component_el_scrollbar = ElScrollbar;
      const _component_el_button = ElButton;
      return openBlock(), createElementBlock("div", {
        class: "conversations-container",
        style: normalizeStyle({
          "--conversation-label-height": `${props.labelHeight}px`,
          "--conversation-list-auto-bg-color": unref(mergedStyle).backgroundColor
        })
      }, [
        renderSlot(_ctx.$slots, "header", {}, void 0, true),
        createElementVNode("ul", {
          class: "conversations-list",
          style: normalizeStyle(unref(mergedStyle))
        }, [
          createElementVNode("li", _hoisted_1, [
            createVNode(_component_el_scrollbar, {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              height: "100%",
              class: "custom-scrollbar",
              always: "",
              onScroll: handleScroll
            }, {
              default: withCtx(() => [
                createElementVNode("div", _hoisted_2, [
                  unref(shouldUseGrouping) ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(groups), (group) => {
                    return openBlock(), createElementBlock("div", {
                      key: group.key,
                      ref_for: true,
                      ref: (el) => bindGroupRef(el, group),
                      class: "conversation-group"
                    }, [
                      createElementVNode("div", {
                        class: normalizeClass(["conversation-group-title sticky-title", { "active-sticky": unref(stickyGroupKeys).has(group.key) }])
                      }, [
                        renderSlot(_ctx.$slots, "groupTitle", mergeProps({ ref_for: true }, { group }), () => [
                          createTextVNode(toDisplayString(group.title), 1)
                        ], true)
                      ], 2),
                      createElementVNode("div", _hoisted_3, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(group.children, (item) => {
                          return openBlock(), createBlock(Item, {
                            key: item.uniqueKey,
                            item,
                            active: item.uniqueKey === activeKey.value,
                            "items-style": props.itemsStyle,
                            "items-hover-style": props.itemsHoverStyle,
                            "items-active-style": props.itemsActiveStyle,
                            "items-menu-opened-style": props.itemsMenuOpenedStyle,
                            "prefix-icon": item.prefixIcon,
                            "show-tooltip": _ctx.showTooltip,
                            "tooltip-placement": props.tooltipPlacement,
                            "tooltip-offset": props.tooltipOffset,
                            "suffix-icon": item.suffixIcon,
                            "active-key": activeKey.value || "",
                            "label-max-width": _ctx.labelMaxWidth,
                            menu: _ctx.menu,
                            "show-built-in-menu": props.showBuiltInMenu,
                            "menu-placement": props.menuPlacement,
                            "menu-offset": props.menuOffset,
                            "menu-max-height": props.menuMaxHeight,
                            "menu-style": props.menuStyle,
                            "menu-show-arrow": props.menuShowArrow,
                            "menu-class-name": props.menuClassName,
                            "menu-teleported": props.menuTeleported,
                            onClick: ($event) => handleClick(item),
                            onMenuCommand: handleMenuItemClick
                          }, createSlots({ _: 2 }, [
                            _ctx.$slots.label ? {
                              name: "label",
                              fn: withCtx(() => [
                                renderSlot(_ctx.$slots, "label", mergeProps({ ref_for: true }, { item }), void 0, true)
                              ]),
                              key: "0"
                            } : void 0,
                            _ctx.$slots["more-filled"] ? {
                              name: "more-filled",
                              fn: withCtx((moreFilledSoltProps) => [
                                renderSlot(_ctx.$slots, "more-filled", mergeProps({ ref_for: true }, moreFilledSoltProps), void 0, true)
                              ]),
                              key: "1"
                            } : void 0,
                            _ctx.$slots.menu ? {
                              name: "menu",
                              fn: withCtx(() => [
                                renderSlot(_ctx.$slots, "menu", mergeProps({ ref_for: true }, { item }), void 0, true)
                              ]),
                              key: "2"
                            } : void 0
                          ]), 1032, ["item", "active", "items-style", "items-hover-style", "items-active-style", "items-menu-opened-style", "prefix-icon", "show-tooltip", "tooltip-placement", "tooltip-offset", "suffix-icon", "active-key", "label-max-width", "menu", "show-built-in-menu", "menu-placement", "menu-offset", "menu-max-height", "menu-style", "menu-show-arrow", "menu-class-name", "menu-teleported", "onClick"]);
                        }), 128))
                      ])
                    ]);
                  }), 128)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(filteredItems), (item) => {
                    return openBlock(), createBlock(Item, {
                      key: item.uniqueKey,
                      item,
                      "items-style": props.itemsStyle,
                      "items-hover-style": props.itemsHoverStyle,
                      "items-active-style": props.itemsActiveStyle,
                      active: item.uniqueKey === activeKey.value,
                      "items-menu-opened-style": props.itemsMenuOpenedStyle,
                      "prefix-icon": item.prefixIcon,
                      "show-tooltip": _ctx.showTooltip,
                      "tooltip-placement": props.tooltipPlacement,
                      "tooltip-offset": props.tooltipOffset,
                      "suffix-icon": item.suffixIcon,
                      "active-key": activeKey.value || "",
                      "label-max-width": _ctx.labelMaxWidth,
                      menu: _ctx.menu,
                      "show-built-in-menu": props.showBuiltInMenu,
                      "menu-placement": props.menuPlacement,
                      "menu-offset": props.menuOffset,
                      "menu-max-height": props.menuMaxHeight,
                      "menu-style": props.menuStyle,
                      "menu-show-arrow": props.menuShowArrow,
                      "menu-class-name": props.menuClassName,
                      "menu-teleported": props.menuTeleported,
                      onClick: ($event) => handleClick(item),
                      onMenuCommand: handleMenuItemClick
                    }, createSlots({ _: 2 }, [
                      _ctx.$slots.label ? {
                        name: "label",
                        fn: withCtx(() => [
                          renderSlot(_ctx.$slots, "label", mergeProps({ ref_for: true }, { item }), void 0, true)
                        ]),
                        key: "0"
                      } : void 0,
                      _ctx.$slots["more-filled"] ? {
                        name: "more-filled",
                        fn: withCtx((moreFilledSoltProps) => [
                          renderSlot(_ctx.$slots, "more-filled", mergeProps({ ref_for: true }, moreFilledSoltProps), void 0, true)
                        ]),
                        key: "1"
                      } : void 0,
                      _ctx.$slots.menu ? {
                        name: "menu",
                        fn: withCtx(() => [
                          renderSlot(_ctx.$slots, "menu", mergeProps({ ref_for: true }, { item }), void 0, true)
                        ]),
                        key: "2"
                      } : void 0
                    ]), 1032, ["item", "items-style", "items-hover-style", "items-active-style", "active", "items-menu-opened-style", "prefix-icon", "show-tooltip", "tooltip-placement", "tooltip-offset", "suffix-icon", "active-key", "label-max-width", "menu", "show-built-in-menu", "menu-placement", "menu-offset", "menu-max-height", "menu-style", "menu-show-arrow", "menu-class-name", "menu-teleported", "onClick"]);
                  }), 128))
                ]),
                props.loadMoreLoading ? (openBlock(), createElementBlock("div", _hoisted_4, [
                  renderSlot(_ctx.$slots, "load-more", {}, () => [
                    createVNode(_component_el_icon, { class: "conversations-load-more-is-loading" }, {
                      default: withCtx(() => [
                        createVNode(unref(loading_default))
                      ]),
                      _: 1
                    }),
                    _cache[0] || (_cache[0] = createElementVNode("span", null, "加载更多...", -1))
                  ], true)
                ])) : createCommentVNode("", true)
              ]),
              _: 3
            }, 512)
          ])
        ], 4),
        renderSlot(_ctx.$slots, "footer", {}, void 0, true),
        withDirectives(createVNode(_component_el_button, {
          class: "scroll-to-top-btn",
          circle: "",
          onClick: scrollToTop
        }, {
          default: withCtx(() => [
            createVNode(_component_el_icon, null, {
              default: withCtx(() => [
                createVNode(unref(top_default))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 512), [
          [vShow, unref(showScrollTop) && props.showToTopBtn]
        ])
      ], 4);
    };
  }
});
const Conversations = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["__scopeId", "data-v-499173a8"]]);
export {
  Conversations as default
};
//# sourceMappingURL=index.js.map
