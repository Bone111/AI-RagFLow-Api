import "../../base-BXVDO6W4.js";
import '../../el-popover.css';import '../../el-popper.css';import './indexbase.vue';/* empty css                       */
/* empty css                        */
import { defineComponent, useSlots, getCurrentInstance, computed, ref, watch, createElementBlock, openBlock, normalizeStyle, createElementVNode, createVNode, normalizeClass, Transition, withCtx, createCommentVNode, unref, renderSlot, withModifiers, isRef, createBlock, createTextVNode, toDisplayString } from "vue";
import EditorInput from "../EditorInput/index.js";
import { _ as _sfc_main$1, L as LoadingButton, a as _sfc_main$2, S as SpeechLoadingButton, C as ClearButton } from "../../index-B6DhhmTr.js";
import { E as ElPopover } from "../../index-D9zaScNv.js";
import { _ as _export_sfc } from "../../_plugin-vue_export-helper-1tPrXgE0.js";
const _hoisted_1 = {
  key: 0,
  class: "el-sender-header-wrap"
};
const _hoisted_2 = {
  key: 0,
  class: "el-sender-header"
};
const _hoisted_3 = {
  key: 0,
  class: "el-sender-prefix"
};
const _hoisted_4 = {
  key: 1,
  class: "el-sender-action-list"
};
const _hoisted_5 = { class: "el-sender-action-list-presets" };
const _hoisted_6 = {
  key: 2,
  class: "el-sender-updown-wrap"
};
const _hoisted_7 = {
  key: 0,
  class: "el-sender-prefix"
};
const _hoisted_8 = { class: "el-sender-action-list" };
const _hoisted_9 = { class: "el-sender-action-list-presets" };
const _hoisted_10 = {
  key: 0,
  class: "el-sender-footer"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "indexbase",
  props: {
    modelValue: { default: "" },
    placeholder: { default: "请输入内容" },
    autoSize: { default: () => ({
      minRows: 1,
      maxRows: 6
    }) },
    readOnly: { type: Boolean },
    disabled: { type: Boolean },
    loading: { type: Boolean },
    clearable: { type: Boolean },
    allowSpeech: { type: Boolean },
    submitType: { default: "enter" },
    headerAnimationTimer: { default: 300 },
    inputWidth: { default: "100%" },
    variant: { default: "default" },
    showUpdown: { type: Boolean, default: true },
    inputStyle: { default: () => {
    } },
    triggerStrings: { default: () => [] },
    triggerPopoverVisible: { type: Boolean, default: false },
    triggerPopoverWidth: { default: "fit-content" },
    triggerPopoverLeft: { default: "0px" },
    triggerPopoverOffset: { default: 8 },
    triggerPopoverPlacement: { default: "top-start" }
  },
  emits: [
    "update:modelValue",
    "update:triggerPopoverVisible",
    "submit",
    "cancel",
    "recordingChange",
    "trigger"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const instance = getCurrentInstance();
    const hasOnRecordingChangeListener = computed(() => {
      var _a;
      return !!((_a = instance == null ? void 0 : instance.vnode.props) == null ? void 0 : _a.onRecordingChange);
    });
    const senderRef = ref();
    const inputRef = ref();
    const contentRef = ref();
    const internalValue = computed({
      get() {
        return props.modelValue;
      },
      set(val) {
        if (props.readOnly || props.disabled)
          return;
        emits("update:modelValue", val);
      }
    });
    const isComposing = ref(false);
    const popoverRef = ref();
    const hasOnTriggerListener = computed(() => {
      var _a;
      return !!((_a = instance == null ? void 0 : instance.vnode.props) == null ? void 0 : _a.onTrigger);
    });
    const popoverVisible = computed({
      get() {
        return props.triggerPopoverVisible;
      },
      set(value) {
        if (props.readOnly || props.disabled)
          return;
        emits("update:triggerPopoverVisible", value);
      }
    });
    const triggerString = ref("");
    watch(
      () => internalValue.value,
      (newVal, oldVal) => {
        if (isComposing.value)
          return;
        const triggerStrings = props.triggerStrings || [];
        const validOldVal = typeof oldVal === "string" ? oldVal : "";
        const wasOldValTrigger = triggerStrings.includes(validOldVal);
        const isNewValTrigger = triggerStrings.includes(newVal);
        if (oldVal === "" && isNewValTrigger) {
          triggerString.value = newVal;
          if (hasOnTriggerListener.value) {
            emits("trigger", {
              oldValue: oldVal,
              // 关闭时返回之前触发的字符
              newValue: newVal,
              triggerString: newVal,
              isOpen: true
            });
            popoverVisible.value = true;
          } else {
            popoverVisible.value = true;
          }
        } else if (!isNewValTrigger && wasOldValTrigger) {
          if (hasOnTriggerListener.value) {
            emits("trigger", {
              oldValue: oldVal,
              // 关闭时返回之前触发的字符
              newValue: newVal,
              triggerString: void 0,
              isOpen: false
            });
            popoverVisible.value = false;
          } else {
            popoverVisible.value = false;
          }
        } else if (oldVal !== "" && isNewValTrigger && !wasOldValTrigger) {
          triggerString.value = newVal;
          if (hasOnTriggerListener.value) {
            emits("trigger", {
              oldValue: oldVal,
              // 关闭时返回之前触发的字符
              newValue: newVal,
              triggerString: newVal,
              isOpen: true
            });
            popoverVisible.value = true;
          } else {
            popoverVisible.value = true;
          }
        }
      },
      { deep: true, immediate: true }
    );
    function onContentMouseDown(e) {
      if (e.target !== senderRef.value.querySelector(`.el-textarea__inner`)) {
        e.preventDefault();
      }
      inputRef.value.focus();
    }
    const visiableHeader = ref(false);
    function openHeader() {
      if (!slots.header)
        return false;
      if (props.readOnly)
        return false;
      visiableHeader.value = true;
    }
    function closeHeader() {
      if (!slots.header)
        return;
      if (props.readOnly)
        return;
      visiableHeader.value = false;
    }
    const recognition = ref(null);
    const speechLoading = ref(false);
    function startRecognition() {
      if (props.readOnly)
        return;
      if (hasOnRecordingChangeListener.value) {
        speechLoading.value = true;
        emits("recordingChange", true);
        return;
      }
      if ("webkitSpeechRecognition" in window) {
        recognition.value = new webkitSpeechRecognition();
        recognition.value.continuous = true;
        recognition.value.interimResults = true;
        recognition.value.lang = "zh-CN";
        recognition.value.onresult = (event) => {
          let results = "";
          for (let i = 0; i <= event.resultIndex; i++) {
            results += event.results[i][0].transcript;
          }
          if (!props.readOnly) {
            internalValue.value = results;
          }
        };
        recognition.value.onstart = () => {
          speechLoading.value = true;
        };
        recognition.value.onend = () => {
          speechLoading.value = false;
        };
        recognition.value.onerror = (event) => {
          speechLoading.value = false;
        };
        recognition.value.start();
      }
    }
    function stopRecognition() {
      if (hasOnRecordingChangeListener.value) {
        speechLoading.value = false;
        emits("recordingChange", false);
        return;
      }
      if (recognition.value) {
        recognition.value.stop();
        speechLoading.value = false;
      }
    }
    function submit() {
      if (props.readOnly || props.loading || props.disabled || !internalValue.value)
        return;
      emits("submit", internalValue.value);
    }
    function cancel() {
      if (props.readOnly)
        return;
      emits("cancel", internalValue.value);
    }
    function clear() {
      if (props.readOnly)
        return;
      inputRef.value.clear();
      internalValue.value = "";
    }
    function handleKeyDown(e) {
      if (props.readOnly)
        return;
      if (props.submitType === "enter") {
        if (e.shiftKey && e.keyCode === 13) {
          e.preventDefault();
          inputRef.value.insertNewLine();
        } else if (e.keyCode === 13 && !e.shiftKey) {
          e.preventDefault();
          submit();
        }
      } else if (props.submitType === "shiftEnter") {
        if (e.shiftKey && e.keyCode === 13) {
          e.preventDefault();
          submit();
        } else if (e.keyCode === 13 && !e.shiftKey) {
          e.preventDefault();
          inputRef.value.insertNewLine();
        }
      }
    }
    function blur() {
      if (props.readOnly) {
        return false;
      }
      inputRef.value.blur();
    }
    function focus(type = "all") {
      if (props.readOnly) {
        return false;
      }
      if (type === "all") {
        inputRef.value.select();
      } else if (type === "start") {
        inputRef.value.moveToStart();
      } else if (type === "end") {
        inputRef.value.moveToEnd();
      }
    }
    function handleCompositionStart() {
      isComposing.value = true;
    }
    function handleCompositionEnd() {
      isComposing.value = false;
    }
    __expose({
      openHeader,
      // 打开头部
      closeHeader,
      // 关闭头部
      clear,
      // 清空输入框
      blur,
      // 失去焦点
      focus,
      // 获取焦点
      // 按钮操作
      submit,
      cancel,
      startRecognition,
      stopRecognition
    });
    return (_ctx, _cache) => {
      const _component_el_popover = ElPopover;
      return openBlock(), createElementBlock("div", {
        class: "el-sender-wrap",
        style: normalizeStyle({
          "cursor": _ctx.disabled ? "not-allowed" : "default",
          "--el-sender-trigger-popover-width": props.triggerPopoverWidth,
          "--el-sender-trigger-popover-left": props.triggerPopoverLeft
        })
      }, [
        createElementVNode("div", {
          ref_key: "senderRef",
          ref: senderRef,
          class: normalizeClass(["el-sender", {
            "el-sender-disabled": _ctx.disabled
          }]),
          style: normalizeStyle({
            "--el-padding-xs": "8px",
            "--el-padding-sm": "12px",
            "--el-padding": "16px",
            "--el-box-shadow-tertiary": "0 1px 2px 0 rgba(0, 0, 0, 0.03), 0 1px 6px -1px rgba(0, 0, 0, 0.02), 0 2px 4px 0 rgba(0, 0, 0, 0.02)",
            "--el-sender-input-input-font-size": "14px",
            "--el-sender-header-animation-duration": `${_ctx.headerAnimationTimer}ms`
          })
        }, [
          createVNode(Transition, { name: "slide" }, {
            default: withCtx(() => [
              unref(visiableHeader) ? (openBlock(), createElementBlock("div", _hoisted_1, [
                _ctx.$slots.header ? (openBlock(), createElementBlock("div", _hoisted_2, [
                  renderSlot(_ctx.$slots, "header", {}, void 0, true)
                ])) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ]),
            _: 3
          }),
          createElementVNode("div", {
            ref_key: "contentRef",
            ref: contentRef,
            class: normalizeClass(["el-sender-content", { "content-variant-updown": props.variant === "updown" }]),
            onMousedown: onContentMouseDown
          }, [
            _ctx.$slots.prefix && props.variant === "default" ? (openBlock(), createElementBlock("div", _hoisted_3, [
              renderSlot(_ctx.$slots, "prefix", {}, void 0, true)
            ])) : createCommentVNode("", true),
            createVNode(EditorInput, {
              ref_key: "inputRef",
              ref: inputRef,
              modelValue: unref(internalValue),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(internalValue) ? internalValue.value = $event : null),
              class: "el-sender-input",
              "input-style": {
                "resize": "none",
                "max-height": "176px",
                "max-width": _ctx.inputWidth
              },
              rows: 1,
              autosize: _ctx.autoSize,
              type: "textarea",
              "validate-event": false,
              placeholder: _ctx.placeholder,
              "read-only": _ctx.readOnly || _ctx.disabled,
              disabled: _ctx.disabled,
              "inpurt-style": props.inputStyle,
              onKeydown: withModifiers(handleKeyDown, ["stop"]),
              onCompositionstart: handleCompositionStart,
              onCompositionend: handleCompositionEnd
            }, null, 8, ["modelValue", "input-style", "autosize", "placeholder", "read-only", "disabled", "inpurt-style"]),
            props.variant === "default" ? (openBlock(), createElementBlock("div", _hoisted_4, [
              renderSlot(_ctx.$slots, "action-list", {}, () => [
                createElementVNode("div", _hoisted_5, [
                  !_ctx.loading ? (openBlock(), createBlock(unref(_sfc_main$1), {
                    key: 0,
                    disabled: !unref(internalValue),
                    onSubmit: submit
                  }, null, 8, ["disabled"])) : createCommentVNode("", true),
                  _ctx.loading ? (openBlock(), createBlock(unref(LoadingButton), {
                    key: 1,
                    onCancel: cancel
                  })) : createCommentVNode("", true),
                  !unref(speechLoading) && _ctx.allowSpeech ? (openBlock(), createBlock(unref(_sfc_main$2), {
                    key: 2,
                    onClick: startRecognition
                  })) : createCommentVNode("", true),
                  unref(speechLoading) && _ctx.allowSpeech ? (openBlock(), createBlock(unref(SpeechLoadingButton), {
                    key: 3,
                    onClick: stopRecognition
                  })) : createCommentVNode("", true),
                  _ctx.clearable ? (openBlock(), createBlock(unref(ClearButton), {
                    key: 4,
                    onClear: clear
                  })) : createCommentVNode("", true)
                ])
              ], true)
            ])) : createCommentVNode("", true),
            props.variant === "updown" && props.showUpdown ? (openBlock(), createElementBlock("div", _hoisted_6, [
              _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", _hoisted_7, [
                renderSlot(_ctx.$slots, "prefix", {}, void 0, true)
              ])) : createCommentVNode("", true),
              createElementVNode("div", _hoisted_8, [
                renderSlot(_ctx.$slots, "action-list", {}, () => [
                  createElementVNode("div", _hoisted_9, [
                    !_ctx.loading ? (openBlock(), createBlock(unref(_sfc_main$1), {
                      key: 0,
                      disabled: !unref(internalValue),
                      onSubmit: submit
                    }, null, 8, ["disabled"])) : createCommentVNode("", true),
                    _ctx.loading ? (openBlock(), createBlock(unref(LoadingButton), {
                      key: 1,
                      onCancel: cancel
                    })) : createCommentVNode("", true),
                    !unref(speechLoading) && _ctx.allowSpeech ? (openBlock(), createBlock(unref(_sfc_main$2), {
                      key: 2,
                      onClick: startRecognition
                    })) : createCommentVNode("", true),
                    unref(speechLoading) && _ctx.allowSpeech ? (openBlock(), createBlock(unref(SpeechLoadingButton), {
                      key: 3,
                      onClick: stopRecognition
                    })) : createCommentVNode("", true),
                    _ctx.clearable ? (openBlock(), createBlock(unref(ClearButton), {
                      key: 4,
                      onClear: clear
                    })) : createCommentVNode("", true)
                  ])
                ], true)
              ])
            ])) : createCommentVNode("", true)
          ], 34),
          createVNode(Transition, { name: "slide" }, {
            default: withCtx(() => [
              _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_10, [
                renderSlot(_ctx.$slots, "footer", {}, void 0, true)
              ])) : createCommentVNode("", true)
            ]),
            _: 3
          })
        ], 6),
        createVNode(_component_el_popover, {
          ref_key: "popoverRef",
          ref: popoverRef,
          "virtual-ref": unref(senderRef),
          "virtual-triggering": "",
          visible: unref(popoverVisible),
          disabled: props.disabled,
          "show-arrow": false,
          placement: props.triggerPopoverPlacement,
          offset: props.triggerPopoverOffset,
          "popper-class": "el-sender-trigger-popover",
          teleported: false
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "trigger-popover", {
              triggerString: unref(triggerString),
              readonly: props.readOnly
            }, () => [
              createTextVNode(" 当前触发的字符为：" + toDisplayString(`${unref(triggerString)}`) + " 在这里定义的内容，但注意这里的回车事件将会被 输入框 覆盖 ", 1)
            ], true)
          ]),
          _: 3
        }, 8, ["virtual-ref", "visible", "disabled", "placement", "offset"])
      ], 4);
    };
  }
});
const indexbase = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-b636ef6d"]]);
export {
  indexbase as default
};
//# sourceMappingURL=indexbase.js.map
