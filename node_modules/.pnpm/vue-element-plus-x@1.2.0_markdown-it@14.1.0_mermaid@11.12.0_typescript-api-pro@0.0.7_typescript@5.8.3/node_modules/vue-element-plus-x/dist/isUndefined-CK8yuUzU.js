import { a as arrayPush } from "./_arrayPush-CBkQqaE_.js";
import { S as Symbol$1, a as isArray } from "./memoize-DcHWeNg4.js";
import { b as isArguments, c as isLength, i as isIndex } from "./isArguments-BS1MO8S5.js";
import { c as castPath, t as toKey } from "./_baseGet-3tygxliO.js";
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (predicate(value)) {
      {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
function isUndefined(value) {
  return value === void 0;
}
export {
  hasPath as a,
  baseFlatten as b,
  hasIn as h,
  isUndefined as i
};
//# sourceMappingURL=isUndefined-CK8yuUzU.js.map
