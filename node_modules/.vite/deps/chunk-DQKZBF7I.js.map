{
  "version": 3,
  "sources": ["../../.pnpm/vue-element-plus-x@1.2.0_markdown-it@14.1.0_mermaid@11.12.0_typescript-api-pro@0.0.7_typescript@5.8.3/node_modules/vue-element-plus-x/dist/mermaid-parser.core-BjtFtmpl.js"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;\nimport { a as assignValue, e as baseAssignValue } from \"./isArguments-BS1MO8S5.js\";\nimport { r as isPrototype, i as isArrayLike, d as copyObject, j as baseUnary, n as nodeUtil } from \"./_initCloneObject-BD9UVboW.js\";\nimport { aY as createAssigner, ar as baseRest, as as isArrayLikeObject, at as isEmpty } from \"./index-CD6jtNKK.js\";\nimport { k as keys, S as SetCache, e as cacheHas, g as getAllKeysIn, d as arrayFilter, f as arraySome } from \"./_baseIsEqual-CLN1Nr3F.js\";\nimport { a as arrayMap } from \"./_baseGet-3tygxliO.js\";\nimport { e as baseEach, c as baseIteratee, i as arrayIncludes, v as values, j as baseIndexOf, k as baseFilter, b as baseUniq, a as forEach, r as reduce, f as filter, n as noop } from \"./_baseUniq-CyBKxUBB.js\";\nimport { b as basePickBy, f as flatten } from \"./_basePickBy-CNUbravK.js\";\nimport { g as toInteger, m as map, f as find, h as has, e as defaults, l as last, d as min } from \"./min-DKZp8rBd.js\";\nimport { a as isArray, c as isObjectLike, d as baseGetTag, i as isFunction, b as isObject } from \"./memoize-DcHWeNg4.js\";\nimport { b as baseFlatten, i as isUndefined } from \"./isUndefined-CK8yuUzU.js\";\nimport { c as clone } from \"./clone-CS7zTRQj.js\";\nimport { i as identity } from \"./_overRest-GH34SvU2.js\";\nvar objectProto$1 = Object.prototype;\nvar hasOwnProperty$1 = objectProto$1.hasOwnProperty;\nvar assign = createAssigner(function(object, source) {\n  if (isPrototype(source) || isArrayLike(source)) {\n    copyObject(source, keys(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (hasOwnProperty$1.call(source, key)) {\n      assignValue(object, key, source[key]);\n    }\n  }\n});\nfunction baseSlice(array, start, end) {\n  var index = -1, length = array.length;\n  if (start < 0) {\n    start = -start > length ? 0 : length + start;\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : end - start >>> 0;\n  start >>>= 0;\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\nfunction compact(array) {\n  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1, length = array == null ? 0 : array.length;\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection2) {\n    setter(accumulator, value, iteratee(value), collection2);\n  });\n  return accumulator;\n}\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};\n    return func(collection, setter, baseIteratee(iteratee), accumulator);\n  };\n}\nvar LARGE_ARRAY_SIZE = 200;\nfunction baseDifference(array, values2, iteratee, comparator) {\n  var index = -1, includes2 = arrayIncludes, isCommon2 = true, length = array.length, result = [], valuesLength = values2.length;\n  if (!length) {\n    return result;\n  }\n  if (values2.length >= LARGE_ARRAY_SIZE) {\n    includes2 = cacheHas;\n    isCommon2 = false;\n    values2 = new SetCache(values2);\n  }\n  outer:\n    while (++index < length) {\n      var value = array[index], computed = value;\n      value = value !== 0 ? value : 0;\n      if (isCommon2 && computed === computed) {\n        var valuesIndex = valuesLength;\n        while (valuesIndex--) {\n          if (values2[valuesIndex] === computed) {\n            continue outer;\n          }\n        }\n        result.push(value);\n      } else if (!includes2(values2, computed, comparator)) {\n        result.push(value);\n      }\n    }\n  return result;\n}\nvar difference = baseRest(function(array, values2) {\n  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];\n});\nfunction drop(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = n === void 0 ? 1 : toInteger(n);\n  return baseSlice(array, n < 0 ? 0 : n, length);\n}\nfunction dropRight(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = n === void 0 ? 1 : toInteger(n);\n  n = length - n;\n  return baseSlice(array, 0, n < 0 ? 0 : n);\n}\nfunction arrayEvery(array, predicate) {\n  var index = -1, length = array == null ? 0 : array.length;\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection2) {\n    result = !!predicate(value, index, collection2);\n    return result;\n  });\n  return result;\n}\nfunction every(collection, predicate, guard) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  return func(collection, baseIteratee(predicate));\n}\nfunction head(array) {\n  return array && array.length ? array[0] : void 0;\n}\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee));\n}\nvar objectProto = Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\nvar stringTag = \"[object String]\";\nfunction isString(value) {\n  return typeof value == \"string\" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;\n}\nvar nativeMax = Math.max;\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike(collection) ? collection : values(collection);\n  fromIndex = fromIndex && true ? toInteger(fromIndex) : 0;\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;\n}\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = 0;\n  return baseIndexOf(array, value, index);\n}\nvar regexpTag = \"[object RegExp]\";\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\nvar FUNC_ERROR_TEXT = \"Expected a function\";\nfunction negate(predicate) {\n  if (typeof predicate != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0:\n        return !predicate.call(this);\n      case 1:\n        return !predicate.call(this, args[0]);\n      case 2:\n        return !predicate.call(this, args[0], args[1]);\n      case 3:\n        return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\nfunction pickBy(object, predicate) {\n  if (object == null) {\n    return {};\n  }\n  var props = arrayMap(getAllKeysIn(object), function(prop) {\n    return [prop];\n  });\n  predicate = baseIteratee(predicate);\n  return basePickBy(object, props, function(value, path) {\n    return predicate(value, path[0]);\n  });\n}\nfunction reject(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, negate(baseIteratee(predicate)));\n}\nfunction baseSome(collection, predicate) {\n  var result;\n  baseEach(collection, function(value, index, collection2) {\n    result = predicate(value, index, collection2);\n    return !result;\n  });\n  return !!result;\n}\nfunction some(collection, predicate, guard) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  return func(collection, baseIteratee(predicate));\n}\nfunction uniq(array) {\n  return array && array.length ? baseUniq(array) : [];\n}\nfunction uniqBy(array, iteratee) {\n  return array && array.length ? baseUniq(array, baseIteratee(iteratee)) : [];\n}\nfunction isAstNode(obj) {\n  return typeof obj === \"object\" && obj !== null && typeof obj.$type === \"string\";\n}\nfunction isReference(obj) {\n  return typeof obj === \"object\" && obj !== null && typeof obj.$refText === \"string\";\n}\nfunction isAstNodeDescription(obj) {\n  return typeof obj === \"object\" && obj !== null && typeof obj.name === \"string\" && typeof obj.type === \"string\" && typeof obj.path === \"string\";\n}\nfunction isLinkingError(obj) {\n  return typeof obj === \"object\" && obj !== null && isAstNode(obj.container) && isReference(obj.reference) && typeof obj.message === \"string\";\n}\nclass AbstractAstReflection {\n  constructor() {\n    this.subtypes = {};\n    this.allSubtypes = {};\n  }\n  isInstance(node, type) {\n    return isAstNode(node) && this.isSubtype(node.$type, type);\n  }\n  isSubtype(subtype, supertype) {\n    if (subtype === supertype) {\n      return true;\n    }\n    let nested = this.subtypes[subtype];\n    if (!nested) {\n      nested = this.subtypes[subtype] = {};\n    }\n    const existing = nested[supertype];\n    if (existing !== void 0) {\n      return existing;\n    } else {\n      const result = this.computeIsSubtype(subtype, supertype);\n      nested[supertype] = result;\n      return result;\n    }\n  }\n  getAllSubTypes(type) {\n    const existing = this.allSubtypes[type];\n    if (existing) {\n      return existing;\n    } else {\n      const allTypes = this.getAllTypes();\n      const types = [];\n      for (const possibleSubType of allTypes) {\n        if (this.isSubtype(possibleSubType, type)) {\n          types.push(possibleSubType);\n        }\n      }\n      this.allSubtypes[type] = types;\n      return types;\n    }\n  }\n}\nfunction isCompositeCstNode(node) {\n  return typeof node === \"object\" && node !== null && Array.isArray(node.content);\n}\nfunction isLeafCstNode(node) {\n  return typeof node === \"object\" && node !== null && typeof node.tokenType === \"object\";\n}\nfunction isRootCstNode(node) {\n  return isCompositeCstNode(node) && typeof node.fullText === \"string\";\n}\nclass StreamImpl {\n  constructor(startFn, nextFn) {\n    this.startFn = startFn;\n    this.nextFn = nextFn;\n  }\n  iterator() {\n    const iterator = {\n      state: this.startFn(),\n      next: () => this.nextFn(iterator.state),\n      [Symbol.iterator]: () => iterator\n    };\n    return iterator;\n  }\n  [Symbol.iterator]() {\n    return this.iterator();\n  }\n  isEmpty() {\n    const iterator = this.iterator();\n    return Boolean(iterator.next().done);\n  }\n  count() {\n    const iterator = this.iterator();\n    let count = 0;\n    let next = iterator.next();\n    while (!next.done) {\n      count++;\n      next = iterator.next();\n    }\n    return count;\n  }\n  toArray() {\n    const result = [];\n    const iterator = this.iterator();\n    let next;\n    do {\n      next = iterator.next();\n      if (next.value !== void 0) {\n        result.push(next.value);\n      }\n    } while (!next.done);\n    return result;\n  }\n  toSet() {\n    return new Set(this);\n  }\n  toMap(keyFn, valueFn) {\n    const entryStream = this.map((element) => [\n      keyFn ? keyFn(element) : element,\n      valueFn ? valueFn(element) : element\n    ]);\n    return new Map(entryStream);\n  }\n  toString() {\n    return this.join();\n  }\n  concat(other) {\n    return new StreamImpl(() => ({ first: this.startFn(), firstDone: false, iterator: other[Symbol.iterator]() }), (state) => {\n      let result;\n      if (!state.firstDone) {\n        do {\n          result = this.nextFn(state.first);\n          if (!result.done) {\n            return result;\n          }\n        } while (!result.done);\n        state.firstDone = true;\n      }\n      do {\n        result = state.iterator.next();\n        if (!result.done) {\n          return result;\n        }\n      } while (!result.done);\n      return DONE_RESULT;\n    });\n  }\n  join(separator = \",\") {\n    const iterator = this.iterator();\n    let value = \"\";\n    let result;\n    let addSeparator = false;\n    do {\n      result = iterator.next();\n      if (!result.done) {\n        if (addSeparator) {\n          value += separator;\n        }\n        value += toString(result.value);\n      }\n      addSeparator = true;\n    } while (!result.done);\n    return value;\n  }\n  indexOf(searchElement, fromIndex = 0) {\n    const iterator = this.iterator();\n    let index = 0;\n    let next = iterator.next();\n    while (!next.done) {\n      if (index >= fromIndex && next.value === searchElement) {\n        return index;\n      }\n      next = iterator.next();\n      index++;\n    }\n    return -1;\n  }\n  every(predicate) {\n    const iterator = this.iterator();\n    let next = iterator.next();\n    while (!next.done) {\n      if (!predicate(next.value)) {\n        return false;\n      }\n      next = iterator.next();\n    }\n    return true;\n  }\n  some(predicate) {\n    const iterator = this.iterator();\n    let next = iterator.next();\n    while (!next.done) {\n      if (predicate(next.value)) {\n        return true;\n      }\n      next = iterator.next();\n    }\n    return false;\n  }\n  forEach(callbackfn) {\n    const iterator = this.iterator();\n    let index = 0;\n    let next = iterator.next();\n    while (!next.done) {\n      callbackfn(next.value, index);\n      next = iterator.next();\n      index++;\n    }\n  }\n  map(callbackfn) {\n    return new StreamImpl(this.startFn, (state) => {\n      const { done, value } = this.nextFn(state);\n      if (done) {\n        return DONE_RESULT;\n      } else {\n        return { done: false, value: callbackfn(value) };\n      }\n    });\n  }\n  filter(predicate) {\n    return new StreamImpl(this.startFn, (state) => {\n      let result;\n      do {\n        result = this.nextFn(state);\n        if (!result.done && predicate(result.value)) {\n          return result;\n        }\n      } while (!result.done);\n      return DONE_RESULT;\n    });\n  }\n  nonNullable() {\n    return this.filter((e) => e !== void 0 && e !== null);\n  }\n  reduce(callbackfn, initialValue) {\n    const iterator = this.iterator();\n    let previousValue = initialValue;\n    let next = iterator.next();\n    while (!next.done) {\n      if (previousValue === void 0) {\n        previousValue = next.value;\n      } else {\n        previousValue = callbackfn(previousValue, next.value);\n      }\n      next = iterator.next();\n    }\n    return previousValue;\n  }\n  reduceRight(callbackfn, initialValue) {\n    return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n  }\n  recursiveReduce(iterator, callbackfn, initialValue) {\n    const next = iterator.next();\n    if (next.done) {\n      return initialValue;\n    }\n    const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n    if (previousValue === void 0) {\n      return next.value;\n    }\n    return callbackfn(previousValue, next.value);\n  }\n  find(predicate) {\n    const iterator = this.iterator();\n    let next = iterator.next();\n    while (!next.done) {\n      if (predicate(next.value)) {\n        return next.value;\n      }\n      next = iterator.next();\n    }\n    return void 0;\n  }\n  findIndex(predicate) {\n    const iterator = this.iterator();\n    let index = 0;\n    let next = iterator.next();\n    while (!next.done) {\n      if (predicate(next.value)) {\n        return index;\n      }\n      next = iterator.next();\n      index++;\n    }\n    return -1;\n  }\n  includes(searchElement) {\n    const iterator = this.iterator();\n    let next = iterator.next();\n    while (!next.done) {\n      if (next.value === searchElement) {\n        return true;\n      }\n      next = iterator.next();\n    }\n    return false;\n  }\n  flatMap(callbackfn) {\n    return new StreamImpl(() => ({ this: this.startFn() }), (state) => {\n      do {\n        if (state.iterator) {\n          const next = state.iterator.next();\n          if (next.done) {\n            state.iterator = void 0;\n          } else {\n            return next;\n          }\n        }\n        const { done, value } = this.nextFn(state.this);\n        if (!done) {\n          const mapped = callbackfn(value);\n          if (isIterable(mapped)) {\n            state.iterator = mapped[Symbol.iterator]();\n          } else {\n            return { done: false, value: mapped };\n          }\n        }\n      } while (state.iterator);\n      return DONE_RESULT;\n    });\n  }\n  flat(depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n    if (depth <= 0) {\n      return this;\n    }\n    const stream2 = depth > 1 ? this.flat(depth - 1) : this;\n    return new StreamImpl(() => ({ this: stream2.startFn() }), (state) => {\n      do {\n        if (state.iterator) {\n          const next = state.iterator.next();\n          if (next.done) {\n            state.iterator = void 0;\n          } else {\n            return next;\n          }\n        }\n        const { done, value } = stream2.nextFn(state.this);\n        if (!done) {\n          if (isIterable(value)) {\n            state.iterator = value[Symbol.iterator]();\n          } else {\n            return { done: false, value };\n          }\n        }\n      } while (state.iterator);\n      return DONE_RESULT;\n    });\n  }\n  head() {\n    const iterator = this.iterator();\n    const result = iterator.next();\n    if (result.done) {\n      return void 0;\n    }\n    return result.value;\n  }\n  tail(skipCount = 1) {\n    return new StreamImpl(() => {\n      const state = this.startFn();\n      for (let i = 0; i < skipCount; i++) {\n        const next = this.nextFn(state);\n        if (next.done) {\n          return state;\n        }\n      }\n      return state;\n    }, this.nextFn);\n  }\n  limit(maxSize) {\n    return new StreamImpl(() => ({ size: 0, state: this.startFn() }), (state) => {\n      state.size++;\n      if (state.size > maxSize) {\n        return DONE_RESULT;\n      }\n      return this.nextFn(state.state);\n    });\n  }\n  distinct(by) {\n    return new StreamImpl(() => ({ set: /* @__PURE__ */ new Set(), internalState: this.startFn() }), (state) => {\n      let result;\n      do {\n        result = this.nextFn(state.internalState);\n        if (!result.done) {\n          const value = by ? by(result.value) : result.value;\n          if (!state.set.has(value)) {\n            state.set.add(value);\n            return result;\n          }\n        }\n      } while (!result.done);\n      return DONE_RESULT;\n    });\n  }\n  exclude(other, key) {\n    const otherKeySet = /* @__PURE__ */ new Set();\n    for (const item of other) {\n      const value = key ? key(item) : item;\n      otherKeySet.add(value);\n    }\n    return this.filter((e) => {\n      const ownKey = key ? key(e) : e;\n      return !otherKeySet.has(ownKey);\n    });\n  }\n}\nfunction toString(item) {\n  if (typeof item === \"string\") {\n    return item;\n  }\n  if (typeof item === \"undefined\") {\n    return \"undefined\";\n  }\n  if (typeof item.toString === \"function\") {\n    return item.toString();\n  }\n  return Object.prototype.toString.call(item);\n}\nfunction isIterable(obj) {\n  return !!obj && typeof obj[Symbol.iterator] === \"function\";\n}\nconst EMPTY_STREAM = new StreamImpl(() => void 0, () => DONE_RESULT);\nconst DONE_RESULT = Object.freeze({ done: true, value: void 0 });\nfunction stream(...collections) {\n  if (collections.length === 1) {\n    const collection = collections[0];\n    if (collection instanceof StreamImpl) {\n      return collection;\n    }\n    if (isIterable(collection)) {\n      return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());\n    }\n    if (typeof collection.length === \"number\") {\n      return new StreamImpl(() => ({ index: 0 }), (state) => {\n        if (state.index < collection.length) {\n          return { done: false, value: collection[state.index++] };\n        } else {\n          return DONE_RESULT;\n        }\n      });\n    }\n  }\n  if (collections.length > 1) {\n    return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {\n      do {\n        if (state.iterator) {\n          const next = state.iterator.next();\n          if (!next.done) {\n            return next;\n          }\n          state.iterator = void 0;\n        }\n        if (state.array) {\n          if (state.arrIndex < state.array.length) {\n            return { done: false, value: state.array[state.arrIndex++] };\n          }\n          state.array = void 0;\n          state.arrIndex = 0;\n        }\n        if (state.collIndex < collections.length) {\n          const collection = collections[state.collIndex++];\n          if (isIterable(collection)) {\n            state.iterator = collection[Symbol.iterator]();\n          } else if (collection && typeof collection.length === \"number\") {\n            state.array = collection;\n          }\n        }\n      } while (state.iterator || state.array || state.collIndex < collections.length);\n      return DONE_RESULT;\n    });\n  }\n  return EMPTY_STREAM;\n}\nclass TreeStreamImpl extends StreamImpl {\n  constructor(root, children, options) {\n    super(() => ({\n      iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\n      pruned: false\n    }), (state) => {\n      if (state.pruned) {\n        state.iterators.pop();\n        state.pruned = false;\n      }\n      while (state.iterators.length > 0) {\n        const iterator = state.iterators[state.iterators.length - 1];\n        const next = iterator.next();\n        if (next.done) {\n          state.iterators.pop();\n        } else {\n          state.iterators.push(children(next.value)[Symbol.iterator]());\n          return next;\n        }\n      }\n      return DONE_RESULT;\n    });\n  }\n  iterator() {\n    const iterator = {\n      state: this.startFn(),\n      next: () => this.nextFn(iterator.state),\n      prune: () => {\n        iterator.state.pruned = true;\n      },\n      [Symbol.iterator]: () => iterator\n    };\n    return iterator;\n  }\n}\nvar Reduction;\n(function(Reduction2) {\n  function sum(stream2) {\n    return stream2.reduce((a, b) => a + b, 0);\n  }\n  Reduction2.sum = sum;\n  function product(stream2) {\n    return stream2.reduce((a, b) => a * b, 0);\n  }\n  Reduction2.product = product;\n  function min2(stream2) {\n    return stream2.reduce((a, b) => Math.min(a, b));\n  }\n  Reduction2.min = min2;\n  function max(stream2) {\n    return stream2.reduce((a, b) => Math.max(a, b));\n  }\n  Reduction2.max = max;\n})(Reduction || (Reduction = {}));\nfunction streamCst(node) {\n  return new TreeStreamImpl(node, (element) => {\n    if (isCompositeCstNode(element)) {\n      return element.content;\n    } else {\n      return [];\n    }\n  }, { includeRoot: true });\n}\nfunction isChildNode(child, parent) {\n  while (child.container) {\n    child = child.container;\n    if (child === parent) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction tokenToRange(token) {\n  return {\n    start: {\n      character: token.startColumn - 1,\n      line: token.startLine - 1\n    },\n    end: {\n      character: token.endColumn,\n      // endColumn uses the correct index\n      line: token.endLine - 1\n    }\n  };\n}\nfunction toDocumentSegment(node) {\n  if (!node) {\n    return void 0;\n  }\n  const { offset, end, range } = node;\n  return {\n    range,\n    offset,\n    end,\n    length: end - offset\n  };\n}\nvar RangeComparison;\n(function(RangeComparison2) {\n  RangeComparison2[RangeComparison2[\"Before\"] = 0] = \"Before\";\n  RangeComparison2[RangeComparison2[\"After\"] = 1] = \"After\";\n  RangeComparison2[RangeComparison2[\"OverlapFront\"] = 2] = \"OverlapFront\";\n  RangeComparison2[RangeComparison2[\"OverlapBack\"] = 3] = \"OverlapBack\";\n  RangeComparison2[RangeComparison2[\"Inside\"] = 4] = \"Inside\";\n  RangeComparison2[RangeComparison2[\"Outside\"] = 5] = \"Outside\";\n})(RangeComparison || (RangeComparison = {}));\nfunction compareRange(range, to) {\n  if (range.end.line < to.start.line || range.end.line === to.start.line && range.end.character <= to.start.character) {\n    return RangeComparison.Before;\n  } else if (range.start.line > to.end.line || range.start.line === to.end.line && range.start.character >= to.end.character) {\n    return RangeComparison.After;\n  }\n  const startInside = range.start.line > to.start.line || range.start.line === to.start.line && range.start.character >= to.start.character;\n  const endInside = range.end.line < to.end.line || range.end.line === to.end.line && range.end.character <= to.end.character;\n  if (startInside && endInside) {\n    return RangeComparison.Inside;\n  } else if (startInside) {\n    return RangeComparison.OverlapBack;\n  } else if (endInside) {\n    return RangeComparison.OverlapFront;\n  } else {\n    return RangeComparison.Outside;\n  }\n}\nfunction inRange(range, to) {\n  const comparison = compareRange(range, to);\n  return comparison > RangeComparison.After;\n}\nconst DefaultNameRegexp = /^[\\w\\p{L}]$/u;\nfunction findCommentNode(cstNode, commentNames) {\n  if (cstNode) {\n    const previous = getPreviousNode(cstNode, true);\n    if (previous && isCommentNode(previous, commentNames)) {\n      return previous;\n    }\n    if (isRootCstNode(cstNode)) {\n      const endIndex = cstNode.content.findIndex((e) => !e.hidden);\n      for (let i = endIndex - 1; i >= 0; i--) {\n        const child = cstNode.content[i];\n        if (isCommentNode(child, commentNames)) {\n          return child;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction isCommentNode(cstNode, commentNames) {\n  return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\nfunction getPreviousNode(node, hidden = true) {\n  while (node.container) {\n    const parent = node.container;\n    let index = parent.content.indexOf(node);\n    while (index > 0) {\n      index--;\n      const previous = parent.content[index];\n      if (hidden || !previous.hidden) {\n        return previous;\n      }\n    }\n    node = parent;\n  }\n  return void 0;\n}\nclass ErrorWithLocation extends Error {\n  constructor(node, message) {\n    super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n  }\n}\nfunction assertUnreachable(_) {\n  throw new Error(\"Error! The input value was not handled.\");\n}\nconst AbstractRule = \"AbstractRule\";\nconst AbstractType = \"AbstractType\";\nconst Condition = \"Condition\";\nconst TypeDefinition = \"TypeDefinition\";\nconst ValueLiteral = \"ValueLiteral\";\nconst AbstractElement = \"AbstractElement\";\nfunction isAbstractElement(item) {\n  return reflection$1.isInstance(item, AbstractElement);\n}\nconst ArrayLiteral = \"ArrayLiteral\";\nconst ArrayType = \"ArrayType\";\nconst BooleanLiteral = \"BooleanLiteral\";\nfunction isBooleanLiteral(item) {\n  return reflection$1.isInstance(item, BooleanLiteral);\n}\nconst Conjunction = \"Conjunction\";\nfunction isConjunction(item) {\n  return reflection$1.isInstance(item, Conjunction);\n}\nconst Disjunction = \"Disjunction\";\nfunction isDisjunction(item) {\n  return reflection$1.isInstance(item, Disjunction);\n}\nconst Grammar = \"Grammar\";\nconst GrammarImport = \"GrammarImport\";\nconst InferredType = \"InferredType\";\nfunction isInferredType(item) {\n  return reflection$1.isInstance(item, InferredType);\n}\nconst Interface = \"Interface\";\nfunction isInterface(item) {\n  return reflection$1.isInstance(item, Interface);\n}\nconst NamedArgument = \"NamedArgument\";\nconst Negation = \"Negation\";\nfunction isNegation(item) {\n  return reflection$1.isInstance(item, Negation);\n}\nconst NumberLiteral = \"NumberLiteral\";\nconst Parameter = \"Parameter\";\nconst ParameterReference = \"ParameterReference\";\nfunction isParameterReference(item) {\n  return reflection$1.isInstance(item, ParameterReference);\n}\nconst ParserRule = \"ParserRule\";\nfunction isParserRule(item) {\n  return reflection$1.isInstance(item, ParserRule);\n}\nconst ReferenceType = \"ReferenceType\";\nconst ReturnType = \"ReturnType\";\nfunction isReturnType(item) {\n  return reflection$1.isInstance(item, ReturnType);\n}\nconst SimpleType = \"SimpleType\";\nfunction isSimpleType(item) {\n  return reflection$1.isInstance(item, SimpleType);\n}\nconst StringLiteral = \"StringLiteral\";\nconst TerminalRule = \"TerminalRule\";\nfunction isTerminalRule(item) {\n  return reflection$1.isInstance(item, TerminalRule);\n}\nconst Type = \"Type\";\nfunction isType(item) {\n  return reflection$1.isInstance(item, Type);\n}\nconst TypeAttribute = \"TypeAttribute\";\nconst UnionType = \"UnionType\";\nconst Action = \"Action\";\nfunction isAction(item) {\n  return reflection$1.isInstance(item, Action);\n}\nconst Alternatives = \"Alternatives\";\nfunction isAlternatives(item) {\n  return reflection$1.isInstance(item, Alternatives);\n}\nconst Assignment = \"Assignment\";\nfunction isAssignment(item) {\n  return reflection$1.isInstance(item, Assignment);\n}\nconst CharacterRange = \"CharacterRange\";\nfunction isCharacterRange(item) {\n  return reflection$1.isInstance(item, CharacterRange);\n}\nconst CrossReference = \"CrossReference\";\nfunction isCrossReference(item) {\n  return reflection$1.isInstance(item, CrossReference);\n}\nconst EndOfFile = \"EndOfFile\";\nfunction isEndOfFile(item) {\n  return reflection$1.isInstance(item, EndOfFile);\n}\nconst Group$1 = \"Group\";\nfunction isGroup(item) {\n  return reflection$1.isInstance(item, Group$1);\n}\nconst Keyword = \"Keyword\";\nfunction isKeyword(item) {\n  return reflection$1.isInstance(item, Keyword);\n}\nconst NegatedToken = \"NegatedToken\";\nfunction isNegatedToken(item) {\n  return reflection$1.isInstance(item, NegatedToken);\n}\nconst RegexToken = \"RegexToken\";\nfunction isRegexToken(item) {\n  return reflection$1.isInstance(item, RegexToken);\n}\nconst RuleCall = \"RuleCall\";\nfunction isRuleCall(item) {\n  return reflection$1.isInstance(item, RuleCall);\n}\nconst TerminalAlternatives = \"TerminalAlternatives\";\nfunction isTerminalAlternatives(item) {\n  return reflection$1.isInstance(item, TerminalAlternatives);\n}\nconst TerminalGroup = \"TerminalGroup\";\nfunction isTerminalGroup(item) {\n  return reflection$1.isInstance(item, TerminalGroup);\n}\nconst TerminalRuleCall = \"TerminalRuleCall\";\nfunction isTerminalRuleCall(item) {\n  return reflection$1.isInstance(item, TerminalRuleCall);\n}\nconst UnorderedGroup = \"UnorderedGroup\";\nfunction isUnorderedGroup(item) {\n  return reflection$1.isInstance(item, UnorderedGroup);\n}\nconst UntilToken = \"UntilToken\";\nfunction isUntilToken(item) {\n  return reflection$1.isInstance(item, UntilToken);\n}\nconst Wildcard = \"Wildcard\";\nfunction isWildcard(item) {\n  return reflection$1.isInstance(item, Wildcard);\n}\nclass LangiumGrammarAstReflection extends AbstractAstReflection {\n  getAllTypes() {\n    return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group$1, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];\n  }\n  computeIsSubtype(subtype, supertype) {\n    switch (subtype) {\n      case Action:\n      case Alternatives:\n      case Assignment:\n      case CharacterRange:\n      case CrossReference:\n      case EndOfFile:\n      case Group$1:\n      case Keyword:\n      case NegatedToken:\n      case RegexToken:\n      case RuleCall:\n      case TerminalAlternatives:\n      case TerminalGroup:\n      case TerminalRuleCall:\n      case UnorderedGroup:\n      case UntilToken:\n      case Wildcard: {\n        return this.isSubtype(AbstractElement, supertype);\n      }\n      case ArrayLiteral:\n      case NumberLiteral:\n      case StringLiteral: {\n        return this.isSubtype(ValueLiteral, supertype);\n      }\n      case ArrayType:\n      case ReferenceType:\n      case SimpleType:\n      case UnionType: {\n        return this.isSubtype(TypeDefinition, supertype);\n      }\n      case BooleanLiteral: {\n        return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n      }\n      case Conjunction:\n      case Disjunction:\n      case Negation:\n      case ParameterReference: {\n        return this.isSubtype(Condition, supertype);\n      }\n      case InferredType:\n      case Interface:\n      case Type: {\n        return this.isSubtype(AbstractType, supertype);\n      }\n      case ParserRule: {\n        return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n      }\n      case TerminalRule: {\n        return this.isSubtype(AbstractRule, supertype);\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n  getReferenceType(refInfo) {\n    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n    switch (referenceId) {\n      case \"Action:type\":\n      case \"CrossReference:type\":\n      case \"Interface:superTypes\":\n      case \"ParserRule:returnType\":\n      case \"SimpleType:typeRef\": {\n        return AbstractType;\n      }\n      case \"Grammar:hiddenTokens\":\n      case \"ParserRule:hiddenTokens\":\n      case \"RuleCall:rule\": {\n        return AbstractRule;\n      }\n      case \"Grammar:usedGrammars\": {\n        return Grammar;\n      }\n      case \"NamedArgument:parameter\":\n      case \"ParameterReference:parameter\": {\n        return Parameter;\n      }\n      case \"TerminalRuleCall:rule\": {\n        return TerminalRule;\n      }\n      default: {\n        throw new Error(`${referenceId} is not a valid reference id.`);\n      }\n    }\n  }\n  getTypeMetaData(type) {\n    switch (type) {\n      case AbstractElement: {\n        return {\n          name: AbstractElement,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case ArrayLiteral: {\n        return {\n          name: ArrayLiteral,\n          properties: [\n            { name: \"elements\", defaultValue: [] }\n          ]\n        };\n      }\n      case ArrayType: {\n        return {\n          name: ArrayType,\n          properties: [\n            { name: \"elementType\" }\n          ]\n        };\n      }\n      case BooleanLiteral: {\n        return {\n          name: BooleanLiteral,\n          properties: [\n            { name: \"true\", defaultValue: false }\n          ]\n        };\n      }\n      case Conjunction: {\n        return {\n          name: Conjunction,\n          properties: [\n            { name: \"left\" },\n            { name: \"right\" }\n          ]\n        };\n      }\n      case Disjunction: {\n        return {\n          name: Disjunction,\n          properties: [\n            { name: \"left\" },\n            { name: \"right\" }\n          ]\n        };\n      }\n      case Grammar: {\n        return {\n          name: Grammar,\n          properties: [\n            { name: \"definesHiddenTokens\", defaultValue: false },\n            { name: \"hiddenTokens\", defaultValue: [] },\n            { name: \"imports\", defaultValue: [] },\n            { name: \"interfaces\", defaultValue: [] },\n            { name: \"isDeclared\", defaultValue: false },\n            { name: \"name\" },\n            { name: \"rules\", defaultValue: [] },\n            { name: \"types\", defaultValue: [] },\n            { name: \"usedGrammars\", defaultValue: [] }\n          ]\n        };\n      }\n      case GrammarImport: {\n        return {\n          name: GrammarImport,\n          properties: [\n            { name: \"path\" }\n          ]\n        };\n      }\n      case InferredType: {\n        return {\n          name: InferredType,\n          properties: [\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Interface: {\n        return {\n          name: Interface,\n          properties: [\n            { name: \"attributes\", defaultValue: [] },\n            { name: \"name\" },\n            { name: \"superTypes\", defaultValue: [] }\n          ]\n        };\n      }\n      case NamedArgument: {\n        return {\n          name: NamedArgument,\n          properties: [\n            { name: \"calledByName\", defaultValue: false },\n            { name: \"parameter\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case Negation: {\n        return {\n          name: Negation,\n          properties: [\n            { name: \"value\" }\n          ]\n        };\n      }\n      case NumberLiteral: {\n        return {\n          name: NumberLiteral,\n          properties: [\n            { name: \"value\" }\n          ]\n        };\n      }\n      case Parameter: {\n        return {\n          name: Parameter,\n          properties: [\n            { name: \"name\" }\n          ]\n        };\n      }\n      case ParameterReference: {\n        return {\n          name: ParameterReference,\n          properties: [\n            { name: \"parameter\" }\n          ]\n        };\n      }\n      case ParserRule: {\n        return {\n          name: ParserRule,\n          properties: [\n            { name: \"dataType\" },\n            { name: \"definesHiddenTokens\", defaultValue: false },\n            { name: \"definition\" },\n            { name: \"entry\", defaultValue: false },\n            { name: \"fragment\", defaultValue: false },\n            { name: \"hiddenTokens\", defaultValue: [] },\n            { name: \"inferredType\" },\n            { name: \"name\" },\n            { name: \"parameters\", defaultValue: [] },\n            { name: \"returnType\" },\n            { name: \"wildcard\", defaultValue: false }\n          ]\n        };\n      }\n      case ReferenceType: {\n        return {\n          name: ReferenceType,\n          properties: [\n            { name: \"referenceType\" }\n          ]\n        };\n      }\n      case ReturnType: {\n        return {\n          name: ReturnType,\n          properties: [\n            { name: \"name\" }\n          ]\n        };\n      }\n      case SimpleType: {\n        return {\n          name: SimpleType,\n          properties: [\n            { name: \"primitiveType\" },\n            { name: \"stringType\" },\n            { name: \"typeRef\" }\n          ]\n        };\n      }\n      case StringLiteral: {\n        return {\n          name: StringLiteral,\n          properties: [\n            { name: \"value\" }\n          ]\n        };\n      }\n      case TerminalRule: {\n        return {\n          name: TerminalRule,\n          properties: [\n            { name: \"definition\" },\n            { name: \"fragment\", defaultValue: false },\n            { name: \"hidden\", defaultValue: false },\n            { name: \"name\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Type: {\n        return {\n          name: Type,\n          properties: [\n            { name: \"name\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case TypeAttribute: {\n        return {\n          name: TypeAttribute,\n          properties: [\n            { name: \"defaultValue\" },\n            { name: \"isOptional\", defaultValue: false },\n            { name: \"name\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case UnionType: {\n        return {\n          name: UnionType,\n          properties: [\n            { name: \"types\", defaultValue: [] }\n          ]\n        };\n      }\n      case Action: {\n        return {\n          name: Action,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"feature\" },\n            { name: \"inferredType\" },\n            { name: \"lookahead\" },\n            { name: \"operator\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Alternatives: {\n        return {\n          name: Alternatives,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case Assignment: {\n        return {\n          name: Assignment,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"feature\" },\n            { name: \"lookahead\" },\n            { name: \"operator\" },\n            { name: \"terminal\" }\n          ]\n        };\n      }\n      case CharacterRange: {\n        return {\n          name: CharacterRange,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"left\" },\n            { name: \"lookahead\" },\n            { name: \"right\" }\n          ]\n        };\n      }\n      case CrossReference: {\n        return {\n          name: CrossReference,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"deprecatedSyntax\", defaultValue: false },\n            { name: \"lookahead\" },\n            { name: \"terminal\" },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case EndOfFile: {\n        return {\n          name: EndOfFile,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case Group$1: {\n        return {\n          name: Group$1,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"guardCondition\" },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case Keyword: {\n        return {\n          name: Keyword,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case NegatedToken: {\n        return {\n          name: NegatedToken,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"terminal\" }\n          ]\n        };\n      }\n      case RegexToken: {\n        return {\n          name: RegexToken,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"regex\" }\n          ]\n        };\n      }\n      case RuleCall: {\n        return {\n          name: RuleCall,\n          properties: [\n            { name: \"arguments\", defaultValue: [] },\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"rule\" }\n          ]\n        };\n      }\n      case TerminalAlternatives: {\n        return {\n          name: TerminalAlternatives,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case TerminalGroup: {\n        return {\n          name: TerminalGroup,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case TerminalRuleCall: {\n        return {\n          name: TerminalRuleCall,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"rule\" }\n          ]\n        };\n      }\n      case UnorderedGroup: {\n        return {\n          name: UnorderedGroup,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"elements\", defaultValue: [] },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      case UntilToken: {\n        return {\n          name: UntilToken,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" },\n            { name: \"terminal\" }\n          ]\n        };\n      }\n      case Wildcard: {\n        return {\n          name: Wildcard,\n          properties: [\n            { name: \"cardinality\" },\n            { name: \"lookahead\" }\n          ]\n        };\n      }\n      default: {\n        return {\n          name: type,\n          properties: []\n        };\n      }\n    }\n  }\n}\nconst reflection$1 = new LangiumGrammarAstReflection();\nfunction linkContentToContainer(node) {\n  for (const [name, value] of Object.entries(node)) {\n    if (!name.startsWith(\"$\")) {\n      if (Array.isArray(value)) {\n        value.forEach((item, index) => {\n          if (isAstNode(item)) {\n            item.$container = node;\n            item.$containerProperty = name;\n            item.$containerIndex = index;\n          }\n        });\n      } else if (isAstNode(value)) {\n        value.$container = node;\n        value.$containerProperty = name;\n      }\n    }\n  }\n}\nfunction getContainerOfType(node, typePredicate) {\n  let item = node;\n  while (item) {\n    if (typePredicate(item)) {\n      return item;\n    }\n    item = item.$container;\n  }\n  return void 0;\n}\nfunction getDocument(node) {\n  const rootNode = findRootNode(node);\n  const result = rootNode.$document;\n  if (!result) {\n    throw new Error(\"AST node has no document.\");\n  }\n  return result;\n}\nfunction findRootNode(node) {\n  while (node.$container) {\n    node = node.$container;\n  }\n  return node;\n}\nfunction streamContents(node, options) {\n  if (!node) {\n    throw new Error(\"Node must be an AstNode.\");\n  }\n  const range = options === null || options === void 0 ? void 0 : options.range;\n  return new StreamImpl(() => ({\n    keys: Object.keys(node),\n    keyIndex: 0,\n    arrayIndex: 0\n  }), (state) => {\n    while (state.keyIndex < state.keys.length) {\n      const property = state.keys[state.keyIndex];\n      if (!property.startsWith(\"$\")) {\n        const value = node[property];\n        if (isAstNode(value)) {\n          state.keyIndex++;\n          if (isAstNodeInRange(value, range)) {\n            return { done: false, value };\n          }\n        } else if (Array.isArray(value)) {\n          while (state.arrayIndex < value.length) {\n            const index = state.arrayIndex++;\n            const element = value[index];\n            if (isAstNode(element) && isAstNodeInRange(element, range)) {\n              return { done: false, value: element };\n            }\n          }\n          state.arrayIndex = 0;\n        }\n      }\n      state.keyIndex++;\n    }\n    return DONE_RESULT;\n  });\n}\nfunction streamAllContents(root, options) {\n  if (!root) {\n    throw new Error(\"Root node must be an AstNode.\");\n  }\n  return new TreeStreamImpl(root, (node) => streamContents(node, options));\n}\nfunction streamAst(root, options) {\n  if (!root) {\n    throw new Error(\"Root node must be an AstNode.\");\n  }\n  return new TreeStreamImpl(root, (node) => streamContents(node, options), { includeRoot: true });\n}\nfunction isAstNodeInRange(astNode, range) {\n  var _a2;\n  if (!range) {\n    return true;\n  }\n  const nodeRange = (_a2 = astNode.$cstNode) === null || _a2 === void 0 ? void 0 : _a2.range;\n  if (!nodeRange) {\n    return false;\n  }\n  return inRange(nodeRange, range);\n}\nfunction streamReferences(node) {\n  return new StreamImpl(() => ({\n    keys: Object.keys(node),\n    keyIndex: 0,\n    arrayIndex: 0\n  }), (state) => {\n    while (state.keyIndex < state.keys.length) {\n      const property = state.keys[state.keyIndex];\n      if (!property.startsWith(\"$\")) {\n        const value = node[property];\n        if (isReference(value)) {\n          state.keyIndex++;\n          return { done: false, value: { reference: value, container: node, property } };\n        } else if (Array.isArray(value)) {\n          while (state.arrayIndex < value.length) {\n            const index = state.arrayIndex++;\n            const element = value[index];\n            if (isReference(element)) {\n              return { done: false, value: { reference: element, container: node, property, index } };\n            }\n          }\n          state.arrayIndex = 0;\n        }\n      }\n      state.keyIndex++;\n    }\n    return DONE_RESULT;\n  });\n}\nfunction assignMandatoryProperties(reflection2, node) {\n  const typeMetaData = reflection2.getTypeMetaData(node.$type);\n  const genericNode = node;\n  for (const property of typeMetaData.properties) {\n    if (property.defaultValue !== void 0 && genericNode[property.name] === void 0) {\n      genericNode[property.name] = copyDefaultValue(property.defaultValue);\n    }\n  }\n}\nfunction copyDefaultValue(propertyType) {\n  if (Array.isArray(propertyType)) {\n    return [...propertyType.map(copyDefaultValue)];\n  } else {\n    return propertyType;\n  }\n}\nfunction cc(char) {\n  return char.charCodeAt(0);\n}\nfunction insertToSet(item, set) {\n  if (Array.isArray(item)) {\n    item.forEach(function(subItem) {\n      set.push(subItem);\n    });\n  } else {\n    set.push(item);\n  }\n}\nfunction addFlag(flagObj, flagKey) {\n  if (flagObj[flagKey] === true) {\n    throw \"duplicate flag \" + flagKey;\n  }\n  flagObj[flagKey];\n  flagObj[flagKey] = true;\n}\nfunction ASSERT_EXISTS(obj) {\n  if (obj === void 0) {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n  return true;\n}\nfunction ASSERT_NEVER_REACH_HERE() {\n  throw Error(\"Internal Error - Should never get here!\");\n}\nfunction isCharacter(obj) {\n  return obj[\"type\"] === \"Character\";\n}\nconst digitsCharCodes = [];\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\n  digitsCharCodes.push(i);\n}\nconst wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\n  wordCharCodes.push(i);\n}\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n  wordCharCodes.push(i);\n}\nconst whitespaceCodes = [\n  cc(\" \"),\n  cc(\"\\f\"),\n  cc(\"\\n\"),\n  cc(\"\\r\"),\n  cc(\"\t\"),\n  cc(\"\\v\"),\n  cc(\"\t\"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\"\\u2028\"),\n  cc(\"\\u2029\"),\n  cc(\" \"),\n  cc(\" \"),\n  cc(\"　\"),\n  cc(\"\\uFEFF\")\n];\nconst hexDigitPattern = /[0-9a-fA-F]/;\nconst decimalPattern = /[0-9]/;\nconst decimalPatternNoZero = /[1-9]/;\nclass RegExpParser {\n  constructor() {\n    this.idx = 0;\n    this.input = \"\";\n    this.groupIdx = 0;\n  }\n  saveState() {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx\n    };\n  }\n  restoreState(newState2) {\n    this.idx = newState2.idx;\n    this.input = newState2.input;\n    this.groupIdx = newState2.groupIdx;\n  }\n  pattern(input) {\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n    this.consumeChar(\"/\");\n    const value = this.disjunction();\n    this.consumeChar(\"/\");\n    const flags = {\n      type: \"Flags\",\n      loc: { begin: this.idx, end: input.length },\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false\n    };\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n    return {\n      type: \"Pattern\",\n      flags,\n      value,\n      loc: this.loc(0)\n    };\n  }\n  disjunction() {\n    const alts = [];\n    const begin = this.idx;\n    alts.push(this.alternative());\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n    return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\n  }\n  alternative() {\n    const terms = [];\n    const begin = this.idx;\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n    return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\n  }\n  term() {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  }\n  assertion() {\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\",\n          loc: this.loc(begin)\n        };\n      case \"$\":\n        return { type: \"EndAnchor\", loc: this.loc(begin) };\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\",\n              loc: this.loc(begin)\n            };\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\",\n              loc: this.loc(begin)\n            };\n        }\n        throw Error(\"Invalid Assertion Escape\");\n      // '(?=' or '(?!'\n      case \"(\":\n        this.consumeChar(\"?\");\n        let type;\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n        ASSERT_EXISTS(type);\n        const disjunction = this.disjunction();\n        this.consumeChar(\")\");\n        return {\n          type,\n          value: disjunction,\n          loc: this.loc(begin)\n        };\n    }\n    return ASSERT_NEVER_REACH_HERE();\n  }\n  quantifier(isBacktracking = false) {\n    let range = void 0;\n    const begin = this.idx;\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity\n        };\n        break;\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity\n        };\n        break;\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1\n        };\n        break;\n      case \"{\":\n        const atLeast = this.integerIncludingZero();\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast,\n              atMost: atLeast\n            };\n            break;\n          case \",\":\n            let atMost;\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast,\n                atMost\n              };\n            } else {\n              range = {\n                atLeast,\n                atMost: Infinity\n              };\n            }\n            this.consumeChar(\"}\");\n            break;\n        }\n        if (isBacktracking === true && range === void 0) {\n          return void 0;\n        }\n        ASSERT_EXISTS(range);\n        break;\n    }\n    if (isBacktracking === true && range === void 0) {\n      return void 0;\n    }\n    if (ASSERT_EXISTS(range)) {\n      if (this.peekChar(0) === \"?\") {\n        this.consumeChar(\"?\");\n        range.greedy = false;\n      } else {\n        range.greedy = true;\n      }\n      range.type = \"Quantifier\";\n      range.loc = this.loc(begin);\n      return range;\n    }\n  }\n  atom() {\n    let atom2;\n    const begin = this.idx;\n    switch (this.peekChar()) {\n      case \".\":\n        atom2 = this.dotAll();\n        break;\n      case \"\\\\\":\n        atom2 = this.atomEscape();\n        break;\n      case \"[\":\n        atom2 = this.characterClass();\n        break;\n      case \"(\":\n        atom2 = this.group();\n        break;\n    }\n    if (atom2 === void 0 && this.isPatternCharacter()) {\n      atom2 = this.patternCharacter();\n    }\n    if (ASSERT_EXISTS(atom2)) {\n      atom2.loc = this.loc(begin);\n      if (this.isQuantifier()) {\n        atom2.quantifier = this.quantifier();\n      }\n      return atom2;\n    }\n  }\n  dotAll() {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n    };\n  }\n  atomEscape() {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n  decimalEscapeAtom() {\n    const value = this.positiveInteger();\n    return { type: \"GroupBackReference\", value };\n  }\n  characterClassEscape() {\n    let set;\n    let complement = false;\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n      case \"w\":\n        set = wordCharCodes;\n        break;\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n    if (ASSERT_EXISTS(set)) {\n      return { type: \"Set\", value: set, complement };\n    }\n  }\n  controlEscapeAtom() {\n    let escapeCode;\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n      case \"t\":\n        escapeCode = cc(\"\t\");\n        break;\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n    if (ASSERT_EXISTS(escapeCode)) {\n      return { type: \"Character\", value: escapeCode };\n    }\n  }\n  controlLetterEscapeAtom() {\n    this.consumeChar(\"c\");\n    const letter = this.popChar();\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n    const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return { type: \"Character\", value: letterCode };\n  }\n  nulCharacterAtom() {\n    this.consumeChar(\"0\");\n    return { type: \"Character\", value: cc(\"\\0\") };\n  }\n  hexEscapeSequenceAtom() {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  }\n  regExpUnicodeEscapeSequenceAtom() {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  }\n  identityEscapeAtom() {\n    const escapedChar = this.popChar();\n    return { type: \"Character\", value: cc(escapedChar) };\n  }\n  classPatternCharacterAtom() {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \"]\":\n        throw Error(\"TBD\");\n      default:\n        const nextChar = this.popChar();\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n  characterClass() {\n    const set = [];\n    let complement = false;\n    this.consumeChar(\"[\");\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n    while (this.isClassAtom()) {\n      const from = this.classAtom();\n      from.type === \"Character\";\n      if (isCharacter(from) && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        const to = this.classAtom();\n        to.type === \"Character\";\n        if (isCharacter(to)) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n          set.push({ from: from.value, to: to.value });\n        } else {\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n    this.consumeChar(\"]\");\n    return { type: \"Set\", complement, value: set };\n  }\n  classAtom() {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"]\":\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n      case \"\\\\\":\n        return this.classEscape();\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  }\n  classEscape() {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      // Matches a backspace.\n      // (Not to be confused with \\b word boundary outside characterClass)\n      case \"b\":\n        this.consumeChar(\"b\");\n        return { type: \"Character\", value: cc(\"\\b\") };\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  }\n  group() {\n    let capturing = true;\n    this.consumeChar(\"(\");\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n      default:\n        this.groupIdx++;\n        break;\n    }\n    const value = this.disjunction();\n    this.consumeChar(\")\");\n    const groupAst = {\n      type: \"Group\",\n      capturing,\n      value\n    };\n    if (capturing) {\n      groupAst[\"idx\"] = this.groupIdx;\n    }\n    return groupAst;\n  }\n  positiveInteger() {\n    let number = this.popChar();\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  }\n  integerIncludingZero() {\n    let number = this.popChar();\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  }\n  patternCharacter() {\n    const nextChar = this.popChar();\n    switch (nextChar) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"^\":\n      // istanbul ignore next\n      case \"$\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \".\":\n      // istanbul ignore next\n      case \"*\":\n      // istanbul ignore next\n      case \"+\":\n      // istanbul ignore next\n      case \"?\":\n      // istanbul ignore next\n      case \"(\":\n      // istanbul ignore next\n      case \")\":\n      // istanbul ignore next\n      case \"[\":\n      // istanbul ignore next\n      case \"|\":\n        throw Error(\"TBD\");\n      default:\n        return { type: \"Character\", value: cc(nextChar) };\n    }\n  }\n  isRegExpFlag() {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  isRangeDash() {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  }\n  isDigit() {\n    return decimalPattern.test(this.peekChar(0));\n  }\n  isClassAtom(howMuch = 0) {\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n  isTerm() {\n    return this.isAtom() || this.isAssertion();\n  }\n  isAtom() {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\":\n      // atomEscape\n      case \"[\":\n      // characterClass\n      // TODO: isAtom must be called before isAssertion - disambiguate\n      case \"(\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  isAssertion() {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n          default:\n            return false;\n        }\n      // '(?=' or '(?!'\n      case \"(\":\n        return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n      default:\n        return false;\n    }\n  }\n  isQuantifier() {\n    const prevState = this.saveState();\n    try {\n      return this.quantifier(true) !== void 0;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  }\n  isPatternCharacter() {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  }\n  parseHexDigits(howMany) {\n    let hexString = \"\";\n    for (let i = 0; i < howMany; i++) {\n      const hexChar = this.popChar();\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n      hexString += hexChar;\n    }\n    const charCode = parseInt(hexString, 16);\n    return { type: \"Character\", value: charCode };\n  }\n  peekChar(howMuch = 0) {\n    return this.input[this.idx + howMuch];\n  }\n  popChar() {\n    const nextChar = this.peekChar(0);\n    this.consumeChar(void 0);\n    return nextChar;\n  }\n  consumeChar(char) {\n    if (char !== void 0 && this.input[this.idx] !== char) {\n      throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n    }\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n    this.idx++;\n  }\n  loc(begin) {\n    return { begin, end: this.idx };\n  }\n}\nclass BaseRegExpVisitor {\n  visitChildren(node) {\n    for (const key in node) {\n      const child = node[key];\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== void 0) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach((subChild) => {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  }\n  visit(node) {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n      case \"Set\":\n        this.visitSet(node);\n        break;\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n    this.visitChildren(node);\n  }\n  visitPattern(node) {\n  }\n  visitFlags(node) {\n  }\n  visitDisjunction(node) {\n  }\n  visitAlternative(node) {\n  }\n  // Assertion\n  visitStartAnchor(node) {\n  }\n  visitEndAnchor(node) {\n  }\n  visitWordBoundary(node) {\n  }\n  visitNonWordBoundary(node) {\n  }\n  visitLookahead(node) {\n  }\n  visitNegativeLookahead(node) {\n  }\n  // atoms\n  visitCharacter(node) {\n  }\n  visitSet(node) {\n  }\n  visitGroup(node) {\n  }\n  visitGroupBackReference(node) {\n  }\n  visitQuantifier(node) {\n  }\n}\nconst NEWLINE_REGEXP = /\\r?\\n/gm;\nconst regexpParser = new RegExpParser();\nclass TerminalRegExpVisitor extends BaseRegExpVisitor {\n  constructor() {\n    super(...arguments);\n    this.isStarting = true;\n    this.endRegexpStack = [];\n    this.multiline = false;\n  }\n  get endRegex() {\n    return this.endRegexpStack.join(\"\");\n  }\n  reset(regex) {\n    this.multiline = false;\n    this.regex = regex;\n    this.startRegexp = \"\";\n    this.isStarting = true;\n    this.endRegexpStack = [];\n  }\n  visitGroup(node) {\n    if (node.quantifier) {\n      this.isStarting = false;\n      this.endRegexpStack = [];\n    }\n  }\n  visitCharacter(node) {\n    const char = String.fromCharCode(node.value);\n    if (!this.multiline && char === \"\\n\") {\n      this.multiline = true;\n    }\n    if (node.quantifier) {\n      this.isStarting = false;\n      this.endRegexpStack = [];\n    } else {\n      const escapedChar = escapeRegExp(char);\n      this.endRegexpStack.push(escapedChar);\n      if (this.isStarting) {\n        this.startRegexp += escapedChar;\n      }\n    }\n  }\n  visitSet(node) {\n    if (!this.multiline) {\n      const set = this.regex.substring(node.loc.begin, node.loc.end);\n      const regex = new RegExp(set);\n      this.multiline = Boolean(\"\\n\".match(regex));\n    }\n    if (node.quantifier) {\n      this.isStarting = false;\n      this.endRegexpStack = [];\n    } else {\n      const set = this.regex.substring(node.loc.begin, node.loc.end);\n      this.endRegexpStack.push(set);\n      if (this.isStarting) {\n        this.startRegexp += set;\n      }\n    }\n  }\n  visitChildren(node) {\n    if (node.type === \"Group\") {\n      const group = node;\n      if (group.quantifier) {\n        return;\n      }\n    }\n    super.visitChildren(node);\n  }\n}\nconst visitor = new TerminalRegExpVisitor();\nfunction isMultilineComment(regexp) {\n  try {\n    if (typeof regexp === \"string\") {\n      regexp = new RegExp(regexp);\n    }\n    regexp = regexp.toString();\n    visitor.reset(regexp);\n    visitor.visit(regexpParser.pattern(regexp));\n    return visitor.multiline;\n  } catch (_a2) {\n    return false;\n  }\n}\nconst whitespaceCharacters = \"\\f\\n\\r\t\\v              \\u2028\\u2029  　\\uFEFF\".split(\"\");\nfunction isWhitespace(value) {\n  const regexp = typeof value === \"string\" ? new RegExp(value) : value;\n  return whitespaceCharacters.some((ws) => regexp.test(ws));\n}\nfunction escapeRegExp(value) {\n  return value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction getCaseInsensitivePattern(keyword) {\n  return Array.prototype.map.call(keyword, (letter) => /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join(\"\");\n}\nfunction partialMatches(regex, input) {\n  const partial = partialRegExp(regex);\n  const match = input.match(partial);\n  return !!match && match[0].length > 0;\n}\nfunction partialRegExp(regex) {\n  if (typeof regex === \"string\") {\n    regex = new RegExp(regex);\n  }\n  const re = regex, source = regex.source;\n  let i = 0;\n  function process2() {\n    let result = \"\", tmp;\n    function appendRaw(nbChars) {\n      result += source.substr(i, nbChars);\n      i += nbChars;\n    }\n    function appendOptional(nbChars) {\n      result += \"(?:\" + source.substr(i, nbChars) + \"|$)\";\n      i += nbChars;\n    }\n    while (i < source.length) {\n      switch (source[i]) {\n        case \"\\\\\":\n          switch (source[i + 1]) {\n            case \"c\":\n              appendOptional(3);\n              break;\n            case \"x\":\n              appendOptional(4);\n              break;\n            case \"u\":\n              if (re.unicode) {\n                if (source[i + 2] === \"{\") {\n                  appendOptional(source.indexOf(\"}\", i) - i + 1);\n                } else {\n                  appendOptional(6);\n                }\n              } else {\n                appendOptional(2);\n              }\n              break;\n            case \"p\":\n            case \"P\":\n              if (re.unicode) {\n                appendOptional(source.indexOf(\"}\", i) - i + 1);\n              } else {\n                appendOptional(2);\n              }\n              break;\n            case \"k\":\n              appendOptional(source.indexOf(\">\", i) - i + 1);\n              break;\n            default:\n              appendOptional(2);\n              break;\n          }\n          break;\n        case \"[\":\n          tmp = /\\[(?:\\\\.|.)*?\\]/g;\n          tmp.lastIndex = i;\n          tmp = tmp.exec(source) || [];\n          appendOptional(tmp[0].length);\n          break;\n        case \"|\":\n        case \"^\":\n        case \"$\":\n        case \"*\":\n        case \"+\":\n        case \"?\":\n          appendRaw(1);\n          break;\n        case \"{\":\n          tmp = /\\{\\d+,?\\d*\\}/g;\n          tmp.lastIndex = i;\n          tmp = tmp.exec(source);\n          if (tmp) {\n            appendRaw(tmp[0].length);\n          } else {\n            appendOptional(1);\n          }\n          break;\n        case \"(\":\n          if (source[i + 1] === \"?\") {\n            switch (source[i + 2]) {\n              case \":\":\n                result += \"(?:\";\n                i += 3;\n                result += process2() + \"|$)\";\n                break;\n              case \"=\":\n                result += \"(?=\";\n                i += 3;\n                result += process2() + \")\";\n                break;\n              case \"!\":\n                tmp = i;\n                i += 3;\n                process2();\n                result += source.substr(tmp, i - tmp);\n                break;\n              case \"<\":\n                switch (source[i + 3]) {\n                  case \"=\":\n                  case \"!\":\n                    tmp = i;\n                    i += 4;\n                    process2();\n                    result += source.substr(tmp, i - tmp);\n                    break;\n                  default:\n                    appendRaw(source.indexOf(\">\", i) - i + 1);\n                    result += process2() + \"|$)\";\n                    break;\n                }\n                break;\n            }\n          } else {\n            appendRaw(1);\n            result += process2() + \"|$)\";\n          }\n          break;\n        case \")\":\n          ++i;\n          return result;\n        default:\n          appendOptional(1);\n          break;\n      }\n    }\n    return result;\n  }\n  return new RegExp(process2(), regex.flags);\n}\nfunction getEntryRule(grammar) {\n  return grammar.rules.find((e) => isParserRule(e) && e.entry);\n}\nfunction getHiddenRules(grammar) {\n  return grammar.rules.filter((e) => isTerminalRule(e) && e.hidden);\n}\nfunction getAllReachableRules(grammar, allTerminals) {\n  const ruleNames = /* @__PURE__ */ new Set();\n  const entryRule = getEntryRule(grammar);\n  if (!entryRule) {\n    return new Set(grammar.rules);\n  }\n  const topMostRules = [entryRule].concat(getHiddenRules(grammar));\n  for (const rule of topMostRules) {\n    ruleDfs(rule, ruleNames, allTerminals);\n  }\n  const rules = /* @__PURE__ */ new Set();\n  for (const rule of grammar.rules) {\n    if (ruleNames.has(rule.name) || isTerminalRule(rule) && rule.hidden) {\n      rules.add(rule);\n    }\n  }\n  return rules;\n}\nfunction ruleDfs(rule, visitedSet, allTerminals) {\n  visitedSet.add(rule.name);\n  streamAllContents(rule).forEach((node) => {\n    if (isRuleCall(node) || allTerminals) {\n      const refRule = node.rule.ref;\n      if (refRule && !visitedSet.has(refRule.name)) {\n        ruleDfs(refRule, visitedSet, allTerminals);\n      }\n    }\n  });\n}\nfunction getCrossReferenceTerminal(crossRef) {\n  if (crossRef.terminal) {\n    return crossRef.terminal;\n  } else if (crossRef.type.ref) {\n    const nameAssigment = findNameAssignment(crossRef.type.ref);\n    return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;\n  }\n  return void 0;\n}\nfunction isCommentTerminal(terminalRule) {\n  return terminalRule.hidden && !isWhitespace(terminalRegex(terminalRule));\n}\nfunction findNodesForProperty(node, property) {\n  if (!node || !property) {\n    return [];\n  }\n  return findNodesForPropertyInternal(node, property, node.astNode, true);\n}\nfunction findNodeForProperty(node, property, index) {\n  if (!node || !property) {\n    return void 0;\n  }\n  const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\n  if (nodes.length === 0) {\n    return void 0;\n  }\n  if (index !== void 0) {\n    index = Math.max(0, Math.min(index, nodes.length - 1));\n  } else {\n    index = 0;\n  }\n  return nodes[index];\n}\nfunction findNodesForPropertyInternal(node, property, element, first2) {\n  if (!first2) {\n    const nodeFeature = getContainerOfType(node.grammarSource, isAssignment);\n    if (nodeFeature && nodeFeature.feature === property) {\n      return [node];\n    }\n  }\n  if (isCompositeCstNode(node) && node.astNode === element) {\n    return node.content.flatMap((e) => findNodesForPropertyInternal(e, property, element, false));\n  }\n  return [];\n}\nfunction findNodeForKeyword(node, keyword, index) {\n  if (!node) {\n    return void 0;\n  }\n  const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n  if (nodes.length === 0) {\n    return void 0;\n  }\n  if (index !== void 0) {\n    index = Math.max(0, Math.min(index, nodes.length - 1));\n  } else {\n    index = 0;\n  }\n  return nodes[index];\n}\nfunction findNodesForKeywordInternal(node, keyword, element) {\n  if (node.astNode !== element) {\n    return [];\n  }\n  if (isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\n    return [node];\n  }\n  const treeIterator = streamCst(node).iterator();\n  let result;\n  const keywordNodes = [];\n  do {\n    result = treeIterator.next();\n    if (!result.done) {\n      const childNode = result.value;\n      if (childNode.astNode === element) {\n        if (isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\n          keywordNodes.push(childNode);\n        }\n      } else {\n        treeIterator.prune();\n      }\n    }\n  } while (!result.done);\n  return keywordNodes;\n}\nfunction findAssignment(cstNode) {\n  var _a2;\n  const astNode = cstNode.astNode;\n  while (astNode === ((_a2 = cstNode.container) === null || _a2 === void 0 ? void 0 : _a2.astNode)) {\n    const assignment = getContainerOfType(cstNode.grammarSource, isAssignment);\n    if (assignment) {\n      return assignment;\n    }\n    cstNode = cstNode.container;\n  }\n  return void 0;\n}\nfunction findNameAssignment(type) {\n  let startNode = type;\n  if (isInferredType(startNode)) {\n    if (isAction(startNode.$container)) {\n      startNode = startNode.$container.$container;\n    } else if (isParserRule(startNode.$container)) {\n      startNode = startNode.$container;\n    } else {\n      assertUnreachable(startNode.$container);\n    }\n  }\n  return findNameAssignmentInternal(type, startNode, /* @__PURE__ */ new Map());\n}\nfunction findNameAssignmentInternal(type, startNode, cache) {\n  var _a2;\n  function go(node, refType) {\n    let childAssignment = void 0;\n    const parentAssignment = getContainerOfType(node, isAssignment);\n    if (!parentAssignment) {\n      childAssignment = findNameAssignmentInternal(refType, refType, cache);\n    }\n    cache.set(type, childAssignment);\n    return childAssignment;\n  }\n  if (cache.has(type)) {\n    return cache.get(type);\n  }\n  cache.set(type, void 0);\n  for (const node of streamAllContents(startNode)) {\n    if (isAssignment(node) && node.feature.toLowerCase() === \"name\") {\n      cache.set(type, node);\n      return node;\n    } else if (isRuleCall(node) && isParserRule(node.rule.ref)) {\n      return go(node, node.rule.ref);\n    } else if (isSimpleType(node) && ((_a2 = node.typeRef) === null || _a2 === void 0 ? void 0 : _a2.ref)) {\n      return go(node, node.typeRef.ref);\n    }\n  }\n  return void 0;\n}\nfunction isDataTypeRule(rule) {\n  return isDataTypeRuleInternal(rule, /* @__PURE__ */ new Set());\n}\nfunction isDataTypeRuleInternal(rule, visited) {\n  if (visited.has(rule)) {\n    return true;\n  } else {\n    visited.add(rule);\n  }\n  for (const node of streamAllContents(rule)) {\n    if (isRuleCall(node)) {\n      if (!node.rule.ref) {\n        return false;\n      }\n      if (isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\n        return false;\n      }\n    } else if (isAssignment(node)) {\n      return false;\n    } else if (isAction(node)) {\n      return false;\n    }\n  }\n  return Boolean(rule.definition);\n}\nfunction getExplicitRuleType(rule) {\n  if (rule.inferredType) {\n    return rule.inferredType.name;\n  } else if (rule.dataType) {\n    return rule.dataType;\n  } else if (rule.returnType) {\n    const refType = rule.returnType.ref;\n    if (refType) {\n      if (isParserRule(refType)) {\n        return refType.name;\n      } else if (isInterface(refType) || isType(refType)) {\n        return refType.name;\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTypeName(type) {\n  var _a2;\n  if (isParserRule(type)) {\n    return isDataTypeRule(type) ? type.name : (_a2 = getExplicitRuleType(type)) !== null && _a2 !== void 0 ? _a2 : type.name;\n  } else if (isInterface(type) || isType(type) || isReturnType(type)) {\n    return type.name;\n  } else if (isAction(type)) {\n    const actionType = getActionType(type);\n    if (actionType) {\n      return actionType;\n    }\n  } else if (isInferredType(type)) {\n    return type.name;\n  }\n  throw new Error(\"Cannot get name of Unknown Type\");\n}\nfunction getActionType(action) {\n  var _a2;\n  if (action.inferredType) {\n    return action.inferredType.name;\n  } else if ((_a2 = action.type) === null || _a2 === void 0 ? void 0 : _a2.ref) {\n    return getTypeName(action.type.ref);\n  }\n  return void 0;\n}\nfunction getRuleType(rule) {\n  var _a2, _b2, _c2;\n  if (isTerminalRule(rule)) {\n    return (_b2 = (_a2 = rule.type) === null || _a2 === void 0 ? void 0 : _a2.name) !== null && _b2 !== void 0 ? _b2 : \"string\";\n  } else {\n    return (_c2 = getExplicitRuleType(rule)) !== null && _c2 !== void 0 ? _c2 : rule.name;\n  }\n}\nfunction terminalRegex(terminalRule) {\n  const flags = {\n    s: false,\n    i: false,\n    u: false\n  };\n  const source = abstractElementToRegex(terminalRule.definition, flags);\n  const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join(\"\");\n  return new RegExp(source, flagText);\n}\nconst WILDCARD = /[\\s\\S]/.source;\nfunction abstractElementToRegex(element, flags) {\n  if (isTerminalAlternatives(element)) {\n    return terminalAlternativesToRegex(element);\n  } else if (isTerminalGroup(element)) {\n    return terminalGroupToRegex(element);\n  } else if (isCharacterRange(element)) {\n    return characterRangeToRegex(element);\n  } else if (isTerminalRuleCall(element)) {\n    const rule = element.rule.ref;\n    if (!rule) {\n      throw new Error(\"Missing rule reference.\");\n    }\n    return withCardinality(abstractElementToRegex(rule.definition), {\n      cardinality: element.cardinality,\n      lookahead: element.lookahead\n    });\n  } else if (isNegatedToken(element)) {\n    return negateTokenToRegex(element);\n  } else if (isUntilToken(element)) {\n    return untilTokenToRegex(element);\n  } else if (isRegexToken(element)) {\n    const lastSlash = element.regex.lastIndexOf(\"/\");\n    const source = element.regex.substring(1, lastSlash);\n    const regexFlags = element.regex.substring(lastSlash + 1);\n    if (flags) {\n      flags.i = regexFlags.includes(\"i\");\n      flags.s = regexFlags.includes(\"s\");\n      flags.u = regexFlags.includes(\"u\");\n    }\n    return withCardinality(source, {\n      cardinality: element.cardinality,\n      lookahead: element.lookahead,\n      wrap: false\n    });\n  } else if (isWildcard(element)) {\n    return withCardinality(WILDCARD, {\n      cardinality: element.cardinality,\n      lookahead: element.lookahead\n    });\n  } else {\n    throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);\n  }\n}\nfunction terminalAlternativesToRegex(alternatives) {\n  return withCardinality(alternatives.elements.map((e) => abstractElementToRegex(e)).join(\"|\"), {\n    cardinality: alternatives.cardinality,\n    lookahead: alternatives.lookahead\n  });\n}\nfunction terminalGroupToRegex(group) {\n  return withCardinality(group.elements.map((e) => abstractElementToRegex(e)).join(\"\"), {\n    cardinality: group.cardinality,\n    lookahead: group.lookahead\n  });\n}\nfunction untilTokenToRegex(until) {\n  return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\n    cardinality: until.cardinality,\n    lookahead: until.lookahead\n  });\n}\nfunction negateTokenToRegex(negate2) {\n  return withCardinality(`(?!${abstractElementToRegex(negate2.terminal)})${WILDCARD}*?`, {\n    cardinality: negate2.cardinality,\n    lookahead: negate2.lookahead\n  });\n}\nfunction characterRangeToRegex(range) {\n  if (range.right) {\n    return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\n      cardinality: range.cardinality,\n      lookahead: range.lookahead,\n      wrap: false\n    });\n  }\n  return withCardinality(keywordToRegex(range.left), {\n    cardinality: range.cardinality,\n    lookahead: range.lookahead,\n    wrap: false\n  });\n}\nfunction keywordToRegex(keyword) {\n  return escapeRegExp(keyword.value);\n}\nfunction withCardinality(regex, options) {\n  var _a2;\n  if (options.wrap !== false || options.lookahead) {\n    regex = `(${(_a2 = options.lookahead) !== null && _a2 !== void 0 ? _a2 : \"\"}${regex})`;\n  }\n  if (options.cardinality) {\n    return `${regex}${options.cardinality}`;\n  }\n  return regex;\n}\nfunction createGrammarConfig(services) {\n  const rules = [];\n  const grammar = services.Grammar;\n  for (const rule of grammar.rules) {\n    if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {\n      rules.push(rule.name);\n    }\n  }\n  return {\n    multilineCommentRules: rules,\n    nameRegexp: DefaultNameRegexp\n  };\n}\nfunction PRINT_ERROR(msg) {\n  if (console && console.error) {\n  }\n}\nfunction PRINT_WARNING(msg) {\n  if (console && console.warn) {\n  }\n}\nfunction timer(func) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  const val = func();\n  const end = (/* @__PURE__ */ new Date()).getTime();\n  const total = end - start;\n  return { time: total, value: val };\n}\nfunction toFastProperties(toBecomeFast) {\n  function FakeConstructor() {\n  }\n  FakeConstructor.prototype = toBecomeFast;\n  const fakeInstance = new FakeConstructor();\n  function fakeAccess() {\n    return typeof fakeInstance.bar;\n  }\n  fakeAccess();\n  fakeAccess();\n  return toBecomeFast;\n}\nfunction tokenLabel$1(tokType) {\n  if (hasTokenLabel$1(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\nfunction hasTokenLabel$1(obj) {\n  return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\nclass AbstractProduction {\n  get definition() {\n    return this._definition;\n  }\n  set definition(value) {\n    this._definition = value;\n  }\n  constructor(_definition) {\n    this._definition = _definition;\n  }\n  accept(visitor2) {\n    visitor2.visit(this);\n    forEach(this.definition, (prod) => {\n      prod.accept(visitor2);\n    });\n  }\n}\nclass NonTerminal extends AbstractProduction {\n  constructor(options) {\n    super([]);\n    this.idx = 1;\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n  set definition(definition) {\n  }\n  get definition() {\n    if (this.referencedRule !== void 0) {\n      return this.referencedRule.definition;\n    }\n    return [];\n  }\n  accept(visitor2) {\n    visitor2.visit(this);\n  }\n}\nclass Rule extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.orgText = \"\";\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n}\nclass Alternative extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.ignoreAmbiguities = false;\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n}\nlet Option$1 = class Option extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n};\nclass RepetitionMandatory extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n}\nclass RepetitionMandatoryWithSeparator extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n}\nclass Repetition extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n}\nclass RepetitionWithSeparator extends AbstractProduction {\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n}\nclass Alternation extends AbstractProduction {\n  get definition() {\n    return this._definition;\n  }\n  set definition(value) {\n    this._definition = value;\n  }\n  constructor(options) {\n    super(options.definition);\n    this.idx = 1;\n    this.ignoreAmbiguities = false;\n    this.hasPredicates = false;\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n}\nclass Terminal {\n  constructor(options) {\n    this.idx = 1;\n    assign(this, pickBy(options, (v) => v !== void 0));\n  }\n  accept(visitor2) {\n    visitor2.visit(this);\n  }\n}\nfunction serializeGrammar(topRules) {\n  return map(topRules, serializeProduction);\n}\nfunction serializeProduction(node) {\n  function convertDefinition(definition) {\n    return map(definition, serializeProduction);\n  }\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    };\n    if (isString(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return {\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Option$1) {\n    return {\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return {\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return {\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return {\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Repetition) {\n    return {\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Alternation) {\n    return {\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = {\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel$1(node.terminalType),\n      idx: node.idx\n    };\n    if (isString(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n    const pattern = node.terminalType.PATTERN;\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp(pattern) ? pattern.source : pattern;\n    }\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return {\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    };\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nclass GAstVisitor {\n  visit(node) {\n    const nodeAny = node;\n    switch (nodeAny.constructor) {\n      case NonTerminal:\n        return this.visitNonTerminal(nodeAny);\n      case Alternative:\n        return this.visitAlternative(nodeAny);\n      case Option$1:\n        return this.visitOption(nodeAny);\n      case RepetitionMandatory:\n        return this.visitRepetitionMandatory(nodeAny);\n      case RepetitionMandatoryWithSeparator:\n        return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n      case RepetitionWithSeparator:\n        return this.visitRepetitionWithSeparator(nodeAny);\n      case Repetition:\n        return this.visitRepetition(nodeAny);\n      case Alternation:\n        return this.visitAlternation(nodeAny);\n      case Terminal:\n        return this.visitTerminal(nodeAny);\n      case Rule:\n        return this.visitRule(nodeAny);\n      /* c8 ignore next 2 */\n      default:\n        throw Error(\"non exhaustive match\");\n    }\n  }\n  /* c8 ignore next */\n  visitNonTerminal(node) {\n  }\n  /* c8 ignore next */\n  visitAlternative(node) {\n  }\n  /* c8 ignore next */\n  visitOption(node) {\n  }\n  /* c8 ignore next */\n  visitRepetition(node) {\n  }\n  /* c8 ignore next */\n  visitRepetitionMandatory(node) {\n  }\n  /* c8 ignore next 3 */\n  visitRepetitionMandatoryWithSeparator(node) {\n  }\n  /* c8 ignore next */\n  visitRepetitionWithSeparator(node) {\n  }\n  /* c8 ignore next */\n  visitAlternation(node) {\n  }\n  /* c8 ignore next */\n  visitTerminal(node) {\n  }\n  /* c8 ignore next */\n  visitRule(node) {\n  }\n}\nfunction isSequenceProd(prod) {\n  return prod instanceof Alternative || prod instanceof Option$1 || prod instanceof Repetition || prod instanceof RepetitionMandatory || prod instanceof RepetitionMandatoryWithSeparator || prod instanceof RepetitionWithSeparator || prod instanceof Terminal || prod instanceof Rule;\n}\nfunction isOptionalProd(prod, alreadyVisited = []) {\n  const isDirectlyOptional = prod instanceof Option$1 || prod instanceof Repetition || prod instanceof RepetitionWithSeparator;\n  if (isDirectlyOptional) {\n    return true;\n  }\n  if (prod instanceof Alternation) {\n    return some(prod.definition, (subProd) => {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n    return false;\n  } else if (prod instanceof AbstractProduction) {\n    if (prod instanceof NonTerminal) {\n      alreadyVisited.push(prod);\n    }\n    return every(prod.definition, (subProd) => {\n      return isOptionalProd(subProd, alreadyVisited);\n    });\n  } else {\n    return false;\n  }\n}\nfunction isBranchingProd(prod) {\n  return prod instanceof Alternation;\n}\nfunction getProductionDslName$1(prod) {\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\";\n  } else if (prod instanceof Option$1) {\n    return \"OPTION\";\n  } else if (prod instanceof Alternation) {\n    return \"OR\";\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\";\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\";\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\";\n  } else if (prod instanceof Repetition) {\n    return \"MANY\";\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nclass RestWalker {\n  walk(prod, prevRest = []) {\n    forEach(prod.definition, (subProd, index) => {\n      const currRest = drop(prod.definition, index + 1);\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option$1) {\n        this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n  }\n  walkFlat(flatProd, currRest, prevRest) {\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  }\n  walkOption(optionProd, currRest, prevRest) {\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  }\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    const fullAtLeastOneRest = [\n      new Option$1({ definition: atLeastOneProd.definition })\n    ].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  }\n  walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  }\n  walkMany(manyProd, currRest, prevRest) {\n    const fullManyRest = [\n      new Option$1({ definition: manyProd.definition })\n    ].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  }\n  walkManySep(manySepProd, currRest, prevRest) {\n    const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  }\n  walkOr(orProd, currRest, prevRest) {\n    const fullOrRest = currRest.concat(prevRest);\n    forEach(orProd.definition, (alt) => {\n      const prodWrapper = new Alternative({ definition: [alt] });\n      this.walk(prodWrapper, fullOrRest);\n    });\n  }\n}\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  const repSepRest = [\n    new Option$1({\n      definition: [\n        new Terminal({ terminalType: repSepProd.separator })\n      ].concat(repSepProd.definition)\n    })\n  ];\n  const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}\nfunction first(prod) {\n  if (prod instanceof NonTerminal) {\n    return first(prod.referencedRule);\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(prod);\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction firstForSequence(prod) {\n  let firstSet = [];\n  const seq = prod.definition;\n  let nextSubProdIdx = 0;\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  let currSubProd;\n  let isLastInnerProdOptional = true;\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n  return uniq(firstSet);\n}\nfunction firstForBranching(prod) {\n  const allAlternativesFirsts = map(prod.definition, (innerProd) => {\n    return first(innerProd);\n  });\n  return uniq(flatten(allAlternativesFirsts));\n}\nfunction firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}\nconst IN = \"_~IN~_\";\nclass ResyncFollowsWalker extends RestWalker {\n  constructor(topProd) {\n    super();\n    this.topProd = topProd;\n    this.follows = {};\n  }\n  startWalking() {\n    this.walk(this.topProd);\n    return this.follows;\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n    const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;\n    const fullRest = currRest.concat(prevRest);\n    const restProd = new Alternative({ definition: fullRest });\n    const t_in_topProd_follows = first(restProd);\n    this.follows[followName] = t_in_topProd_follows;\n  }\n}\nfunction computeAllProdsFollows(topProductions) {\n  const reSyncFollows = {};\n  forEach(topProductions, (topProd) => {\n    const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n    assign(reSyncFollows, currRefsFollow);\n  });\n  return reSyncFollows;\n}\nfunction buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n  return inner.name + occurenceInParent + IN;\n}\nlet regExpAstCache = {};\nconst regExpParser = new RegExpParser();\nfunction getRegExpAst(regExp) {\n  const regExpStr = regExp.toString();\n  if (regExpAstCache.hasOwnProperty(regExpStr)) {\n    return regExpAstCache[regExpStr];\n  } else {\n    const regExpAst = regExpParser.pattern(regExpStr);\n    regExpAstCache[regExpStr] = regExpAst;\n    return regExpAst;\n  }\n}\nfunction clearRegExpParserCache() {\n  regExpAstCache = {};\n}\nconst complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nconst failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n  try {\n    const ast = getRegExpAst(regExp);\n    const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(`${failedOptimizationPrefixMsg}\tUnable to optimize: < ${regExp.toString()} >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);\n      }\n    } else {\n      let msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\tThis will disable the lexer's first char optimizations.\\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      PRINT_ERROR(`${failedOptimizationPrefixMsg}\n\tFailed parsing: < ${regExp.toString()} >\n\tUsing the @chevrotain/regexp-to-ast library\n\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues` + msgSuffix);\n    }\n  }\n  return [];\n}\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      const terms = ast.value;\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i];\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        const atom2 = term;\n        switch (atom2.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom2.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom2.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            forEach(atom2.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                const range = code;\n                if (ignoreCase === true) {\n                  for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                } else {\n                  for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                    const maxUnOptVal = range.to;\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                    for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom2.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        const isOptionalQuantifier = atom2.quantifier !== void 0 && atom2.quantifier.atLeast === 0;\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          atom2.type === \"Group\" && isWholeOptional(atom2) === false || // If this term is not a group it may only be optional if it has an optional quantifier\n          atom2.type !== \"Group\" && isOptionalQuantifier === false\n        ) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  return values(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\nfunction handleIgnoreCase(code, result) {\n  const char = String.fromCharCode(code);\n  const upperChar = char.toUpperCase();\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    const lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\nfunction findCode(setNode, targetCharCodes) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes(targetCharCodes, codeOrRange);\n    } else {\n      const range = codeOrRange;\n      return find(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== void 0;\n    }\n  });\n}\nfunction isWholeOptional(ast) {\n  const quantifier = ast.quantifier;\n  if (quantifier && quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return isArray(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\nclass CharCodeFinder extends BaseRegExpVisitor {\n  constructor(targetCharCodes) {\n    super();\n    this.targetCharCodes = targetCharCodes;\n    this.found = false;\n  }\n  visitChildren(node) {\n    if (this.found === true) {\n      return;\n    }\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    super.visitChildren(node);\n  }\n  visitCharacter(node) {\n    if (includes(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  }\n  visitSet(node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === void 0) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== void 0) {\n        this.found = true;\n      }\n    }\n  }\n}\nfunction canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern);\n    const charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return find(pattern, (char) => {\n      return includes(charCodes, char.charCodeAt(0));\n    }) !== void 0;\n  }\n}\nconst PATTERN = \"PATTERN\";\nconst DEFAULT_MODE = \"defaultMode\";\nconst MODES = \"modes\";\nlet SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nfunction analyzeTokenTypes(tokenTypes, options) {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false,\n    safeMode: false,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: (msg, action) => action()\n  });\n  const tracer = options.tracer;\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n    initCharCodeToOptimizedIndexMap();\n  });\n  let onlyRelevantTypes;\n  tracer(\"Reject Lexer.NA\", () => {\n    onlyRelevantTypes = reject(tokenTypes, (currType) => {\n      return currType[PATTERN] === Lexer.NA;\n    });\n  });\n  let hasCustom = false;\n  let allTransformedPatterns;\n  tracer(\"Transform Patterns\", () => {\n    hasCustom = false;\n    allTransformedPatterns = map(onlyRelevantTypes, (currType) => {\n      const currPattern = currType[PATTERN];\n      if (isRegExp(currPattern)) {\n        const regExpSource = currPattern.source;\n        if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp\n        regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) {\n          return regExpSource;\n        } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" && // not a meta character\n        !includes([\n          \"d\",\n          \"D\",\n          \"s\",\n          \"S\",\n          \"t\",\n          \"r\",\n          \"n\",\n          \"t\",\n          \"0\",\n          \"c\",\n          \"b\",\n          \"B\",\n          \"f\",\n          \"v\",\n          \"w\",\n          \"W\"\n        ], regExpSource[1])) {\n          return regExpSource[1];\n        } else {\n          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n        }\n      } else if (isFunction(currPattern)) {\n        hasCustom = true;\n        return { exec: currPattern };\n      } else if (typeof currPattern === \"object\") {\n        hasCustom = true;\n        return currPattern;\n      } else if (typeof currPattern === \"string\") {\n        if (currPattern.length === 1) {\n          return currPattern;\n        } else {\n          const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n          const wrappedRegExp = new RegExp(escapedRegExpString);\n          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n        }\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  });\n  let patternIdxToType;\n  let patternIdxToGroup;\n  let patternIdxToLongerAltIdxArr;\n  let patternIdxToPushMode;\n  let patternIdxToPopMode;\n  tracer(\"misc mapping\", () => {\n    patternIdxToType = map(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);\n    patternIdxToGroup = map(onlyRelevantTypes, (clazz) => {\n      const groupName = clazz.GROUP;\n      if (groupName === Lexer.SKIPPED) {\n        return void 0;\n      } else if (isString(groupName)) {\n        return groupName;\n      } else if (isUndefined(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n    patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz) => {\n      const longerAltType = clazz.LONGER_ALT;\n      if (longerAltType) {\n        const longerAltIdxArr = isArray(longerAltType) ? map(longerAltType, (type) => indexOf(onlyRelevantTypes, type)) : [indexOf(onlyRelevantTypes, longerAltType)];\n        return longerAltIdxArr;\n      }\n    });\n    patternIdxToPushMode = map(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);\n    patternIdxToPopMode = map(onlyRelevantTypes, (clazz) => has(clazz, \"POP_MODE\"));\n  });\n  let patternIdxToCanLineTerminator;\n  tracer(\"Line Terminator Handling\", () => {\n    const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false);\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return !!tokType.LINE_BREAKS;\n        } else {\n          return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n        }\n      });\n    }\n  });\n  let patternIdxToIsCustom;\n  let patternIdxToShort;\n  let emptyGroups;\n  let patternIdxToConfig;\n  tracer(\"Misc Mapping #2\", () => {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n    emptyGroups = reduce(onlyRelevantTypes, (acc, clazz) => {\n      const groupName = clazz.GROUP;\n      if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n        acc[groupName] = [];\n      }\n      return acc;\n    }, {});\n    patternIdxToConfig = map(allTransformedPatterns, (x, idx) => {\n      return {\n        pattern: allTransformedPatterns[idx],\n        longerAlt: patternIdxToLongerAltIdxArr[idx],\n        canLineTerminator: patternIdxToCanLineTerminator[idx],\n        isCustom: patternIdxToIsCustom[idx],\n        short: patternIdxToShort[idx],\n        group: patternIdxToGroup[idx],\n        push: patternIdxToPushMode[idx],\n        pop: patternIdxToPopMode[idx],\n        tokenTypeIdx: patternIdxToType[idx],\n        tokenType: onlyRelevantTypes[idx]\n      };\n    });\n  });\n  let canBeOptimized = true;\n  let charCodeToPatternIdxToConfig = [];\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", () => {\n      charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, (result, currTokType, idx) => {\n        if (typeof currTokType.PATTERN === \"string\") {\n          const charCode = currTokType.PATTERN.charCodeAt(0);\n          const optimizedIdx = charCodeToOptimizedIndex(charCode);\n          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n        } else if (isArray(currTokType.START_CHARS_HINT)) {\n          let lastOptimizedIdx;\n          forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n            const charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n            const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n            if (lastOptimizedIdx !== currOptimizedIdx) {\n              lastOptimizedIdx = currOptimizedIdx;\n              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n            }\n          });\n        } else if (isRegExp(currTokType.PATTERN)) {\n          if (currTokType.PATTERN.unicode) {\n            canBeOptimized = false;\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(`${failedOptimizationPrefixMsg}\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);\n            }\n          } else {\n            const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n            if (isEmpty(optimizedCodes)) {\n              canBeOptimized = false;\n            }\n            forEach(optimizedCodes, (code) => {\n              addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n            });\n          }\n        } else {\n          if (options.ensureOptimizations) {\n            PRINT_ERROR(`${failedOptimizationPrefixMsg}\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`);\n          }\n          canBeOptimized = false;\n        }\n        return result;\n      }, []);\n    });\n  }\n  return {\n    emptyGroups,\n    patternIdxToConfig,\n    charCodeToPatternIdxToConfig,\n    hasCustom,\n    canBeOptimized\n  };\n}\nfunction validatePatterns(tokenTypes, validModesNames) {\n  let errors = [];\n  const missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n  const invalidResult = findInvalidPatterns(missingResult.valid);\n  const validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n  return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n  let errors = [];\n  const withRegExpPatterns = filter(tokenTypes, (currTokType) => isRegExp(currTokType[PATTERN]));\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n  return errors;\n}\nfunction findMissingPatterns(tokenTypes) {\n  const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n    return !has(currType, PATTERN);\n  });\n  const errors = map(tokenTypesWithMissingPattern, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  const valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n  return { errors, valid };\n}\nfunction findInvalidPatterns(tokenTypes) {\n  const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return !isRegExp(pattern) && !isFunction(pattern) && !has(pattern, \"exec\") && !isString(pattern);\n  });\n  const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  const valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n  return { errors, valid };\n}\nconst end_of_input = /[^\\\\][$]/;\nfunction findEndOfInputAnchor(tokenTypes) {\n  class EndAnchorFinder extends BaseRegExpVisitor {\n    constructor() {\n      super(...arguments);\n      this.found = false;\n    }\n    visitEndAnchor(node) {\n      this.found = true;\n    }\n  }\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n    try {\n      const regexpAst = getRegExpAst(pattern);\n      const endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n      return endAnchorVisitor.found;\n    } catch (e) {\n      return end_of_input.test(pattern.source);\n    }\n  });\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nfunction findEmptyMatchRegExps(tokenTypes) {\n  const matchesEmptyString = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n    return pattern.test(\"\");\n  });\n  const errors = map(matchesEmptyString, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nconst start_of_input = /[^\\\\[][\\^]|^\\^/;\nfunction findStartOfInputAnchor(tokenTypes) {\n  class StartAnchorFinder extends BaseRegExpVisitor {\n    constructor() {\n      super(...arguments);\n      this.found = false;\n    }\n    visitStartAnchor(node) {\n      this.found = true;\n    }\n  }\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n    try {\n      const regexpAst = getRegExpAst(pattern);\n      const startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n      return startAnchorVisitor.found;\n    } catch (e) {\n      return start_of_input.test(pattern.source);\n    }\n  });\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nfunction findUnsupportedFlags(tokenTypes) {\n  const invalidFlags = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n  const errors = map(invalidFlags, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nfunction findDuplicatePatterns(tokenTypes) {\n  const found = [];\n  let identicalPatterns = map(tokenTypes, (outerType) => {\n    return reduce(tokenTypes, (result, innerType) => {\n      if (outerType.PATTERN.source === innerType.PATTERN.source && !includes(found, innerType) && innerType.PATTERN !== Lexer.NA) {\n        found.push(innerType);\n        result.push(innerType);\n        return result;\n      }\n      return result;\n    }, []);\n  });\n  identicalPatterns = compact(identicalPatterns);\n  const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n    return currIdenticalSet.length > 1;\n  });\n  const errors = map(duplicatePatterns, (setOfIdentical) => {\n    const tokenTypeNames = map(setOfIdentical, (currType) => {\n      return currType.name;\n    });\n    const dupPatternSrc = head(setOfIdentical).PATTERN;\n    return {\n      message: `The same RegExp pattern ->${dupPatternSrc}<-has been used in all of the following Token Types: ${tokenTypeNames.join(\", \")} <-`,\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    };\n  });\n  return errors;\n}\nfunction findInvalidGroupType(tokenTypes) {\n  const invalidTypes = filter(tokenTypes, (clazz) => {\n    if (!has(clazz, \"GROUP\")) {\n      return false;\n    }\n    const group = clazz.GROUP;\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n  });\n  const errors = map(invalidTypes, (currType) => {\n    return {\n      message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    };\n  });\n  return errors;\n}\nfunction findModesThatDoNotExist(tokenTypes, validModes) {\n  const invalidModes = filter(tokenTypes, (clazz) => {\n    return clazz.PUSH_MODE !== void 0 && !includes(validModes, clazz.PUSH_MODE);\n  });\n  const errors = map(invalidModes, (tokType) => {\n    const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-which does not exist`;\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    };\n  });\n  return errors;\n}\nfunction findUnreachablePatterns(tokenTypes) {\n  const errors = [];\n  const canBeTested = reduce(tokenTypes, (result, tokType, idx) => {\n    const pattern = tokType.PATTERN;\n    if (pattern === Lexer.NA) {\n      return result;\n    }\n    if (isString(pattern)) {\n      result.push({ str: pattern, idx, tokenType: tokType });\n    } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n      result.push({ str: pattern.source, idx, tokenType: tokType });\n    }\n    return result;\n  }, []);\n  forEach(tokenTypes, (tokType, testIdx) => {\n    forEach(canBeTested, ({ str, idx, tokenType }) => {\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        const msg = `Token: ->${tokenType.name}<- can never be matched.\nBecause it appears AFTER the Token Type ->${tokType.name}<-in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction testTokenType(str, pattern) {\n  if (isRegExp(pattern)) {\n    const regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (isFunction(pattern)) {\n    return pattern(str, 0, [], {});\n  } else if (has(pattern, \"exec\")) {\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction noMetaChar(regExp) {\n  const metaChars = [\n    \".\",\n    \"\\\\\",\n    \"[\",\n    \"]\",\n    \"|\",\n    \"^\",\n    \"$\",\n    \"(\",\n    \")\",\n    \"?\",\n    \"*\",\n    \"+\",\n    \"{\"\n  ];\n  return find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === void 0;\n}\nfunction addStartOfInput(pattern) {\n  const flags = pattern.ignoreCase ? \"i\" : \"\";\n  return new RegExp(`^(?:${pattern.source})`, flags);\n}\nfunction addStickyFlag(pattern) {\n  const flags = pattern.ignoreCase ? \"iy\" : \"y\";\n  return new RegExp(`${pattern.source}`, flags);\n}\nfunction performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  const errors = [];\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + DEFAULT_MODE + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    });\n  }\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message: \"A MultiMode Lexer cannot be initialized without a <\" + MODES + \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    });\n  }\n  if (has(lexerDefinition, MODES) && has(lexerDefinition, DEFAULT_MODE) && !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n    errors.push({\n      message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>which does not exist\n`,\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    });\n  }\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n      forEach(currModeValue, (currTokType, currIdx) => {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${currModeName}> at index: <${currIdx}>\n`,\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          });\n        } else if (has(currTokType, \"LONGER_ALT\")) {\n          const longerAlt = isArray(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];\n          forEach(longerAlt, (currLongerAlt) => {\n            if (!isUndefined(currLongerAlt) && !includes(currModeValue, currLongerAlt)) {\n              errors.push({\n                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\n`,\n                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n              });\n            }\n          });\n        }\n      });\n    });\n  }\n  return errors;\n}\nfunction performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n  const warnings = [];\n  let hasAnyLineBreak = false;\n  const allTokenTypes = compact(flatten(values(lexerDefinition.modes)));\n  const concreteTokenTypes = reject(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA);\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n  if (trackLines) {\n    forEach(concreteTokenTypes, (tokType) => {\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n      if (currIssue !== false) {\n        const message = buildLineBreakIssueMessage(tokType, currIssue);\n        const warningDescriptor = {\n          message,\n          type: currIssue.issue,\n          tokenType: tokType\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message: \"Warning: No LINE_BREAKS Found.\\n\tThis Lexer has been defined to track line and column information,\\n\tBut none of the Token Types can be identified as matching a line terminator.\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    });\n  }\n  return warnings;\n}\nfunction cloneEmptyGroups(emptyGroups) {\n  const clonedResult = {};\n  const groupKeys = keys(emptyGroups);\n  forEach(groupKeys, (currKey) => {\n    const currGroupValue = emptyGroups[currKey];\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n  return clonedResult;\n}\nfunction isCustomPattern(tokenType) {\n  const pattern = tokenType.PATTERN;\n  if (isRegExp(pattern)) {\n    return false;\n  } else if (isFunction(pattern)) {\n    return true;\n  } else if (has(pattern, \"exec\")) {\n    return true;\n  } else if (isString(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction isShortPattern(pattern) {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\nconst LineTerminatorOptimizedTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function(text) {\n    const len = text.length;\n    for (let i = this.lastIndex; i < len; i++) {\n      const c = text.charCodeAt(i);\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n  lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    return false;\n  } else {\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n      } catch (e) {\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: e.message\n        };\n      }\n      return false;\n    } else if (isString(tokType.PATTERN)) {\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\nfunction buildLineBreakIssueMessage(tokType, details) {\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return `Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <${tokType.name}> Token Type\n\t Root cause: ${details.errMsg}.\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return `Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <${tokType.name}> Token Type\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction getCharCodes(charsOrCodes) {\n  const charCodes = map(charsOrCodes, (numOrString) => {\n    if (isString(numOrString)) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n  return charCodes;\n}\nfunction addToMapOfArrays(map2, key, value) {\n  if (map2[key] === void 0) {\n    map2[key] = [value];\n  } else {\n    map2[key].push(value);\n  }\n}\nconst minOptimizationVal = 256;\nlet charCodeToOptimizedIdxMap = [];\nfunction charCodeToOptimizedIndex(charCode) {\n  return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n}\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n    for (let i = 0; i < 65536; i++) {\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n    }\n  }\n}\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n  const instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n}\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nlet tokenShortNameIdx = 1;\nconst tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n  const tokenTypesAndParents = expandCategories(tokenTypes);\n  assignTokenDefaultProps(tokenTypesAndParents);\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  forEach(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nfunction expandCategories(tokenTypes) {\n  let result = clone(tokenTypes);\n  let categories = tokenTypes;\n  let searching = true;\n  while (searching) {\n    categories = compact(flatten(map(categories, (currTokType) => currTokType.CATEGORIES)));\n    const newCategories = difference(categories, result);\n    result = result.concat(newCategories);\n    if (isEmpty(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\nfunction assignTokenDefaultProps(tokenTypes) {\n  forEach(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = tokenShortNameIdx++;\n    }\n    if (hasCategoriesProperty(currTokType) && !isArray(currTokType.CATEGORIES)) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nfunction assignCategoriesTokensProp(tokenTypes) {\n  forEach(tokenTypes, (currTokType) => {\n    currTokType.categoryMatches = [];\n    forEach(currTokType.categoryMatchesMap, (val, key) => {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nfunction assignCategoriesMapProp(tokenTypes) {\n  forEach(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n  forEach(path, (pathNode) => {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  forEach(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode);\n    if (!includes(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nfunction hasShortKeyProperty(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}\nfunction hasCategoriesProperty(tokType) {\n  return has(tokType, \"CATEGORIES\");\n}\nfunction hasExtendingTokensTypesProperty(tokType) {\n  return has(tokType, \"categoryMatches\");\n}\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n  return has(tokType, \"categoryMatchesMap\");\n}\nfunction isTokenType(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}\nconst defaultLexerErrorProvider = {\n  buildUnableToPopLexerModeMessage(token) {\n    return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n  },\n  buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n    return `unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset}, skipped ${length} characters.`;\n  }\n};\nvar LexerDefinitionErrorType;\n(function(LexerDefinitionErrorType2) {\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n  LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nconst DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false,\n  recoveryEnabled: true\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nclass Lexer {\n  constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {};\n    this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n      if (this.traceInitPerf === true) {\n        this.traceInitIndent++;\n        const indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n        }\n        const { time, value } = timer(phaseImpl);\n        const traceMethod = time > 10 ? console.warn : console.log;\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n        }\n        this.traceInitIndent--;\n        return value;\n      } else {\n        return phaseImpl();\n      }\n    };\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\na boolean 2nd argument is no longer supported\");\n    }\n    this.config = assign({}, DEFAULT_LEXER_CONFIG, config);\n    const traceInitVal = this.config.traceInitPerf;\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition;\n      let hasOnlySingleMode = true;\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n        } else {\n          if (this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n        this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);\n        this.trackEndLines = /full/i.test(this.config.positionTracking);\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: { defaultMode: clone(lexerDefinition) },\n            defaultMode: DEFAULT_MODE\n          };\n        } else {\n          hasOnlySingleMode = false;\n          actualDefinition = clone(lexerDefinition);\n        }\n      });\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n        });\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n        });\n      }\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n      forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject(currModeValue, (currTokType) => isUndefined(currTokType));\n      });\n      const allModeNames = keys(actualDefinition.modes);\n      forEach(actualDefinition.modes, (currModDef, currModName) => {\n        this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n          this.modes.push(currModName);\n          if (this.config.skipValidations === false) {\n            this.TRACE_INIT(`validatePatterns`, () => {\n              this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n            });\n          }\n          if (isEmpty(this.lexerDefinitionErrors)) {\n            augmentTokenTypes(currModDef);\n            let currAnalyzeResult;\n            this.TRACE_INIT(`analyzeTokenTypes`, () => {\n              currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: this.TRACE_INIT\n              });\n            });\n            this.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig;\n            this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig;\n            this.emptyGroups = assign({}, this.emptyGroups, currAnalyzeResult.emptyGroups);\n            this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n            this.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized;\n          }\n        });\n      });\n      this.defaultMode = actualDefinition.defaultMode;\n      if (!isEmpty(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message;\n        });\n        const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      }\n      forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message);\n      });\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        if (SUPPORT_STICKY) {\n          this.chopInput = identity;\n          this.match = this.matchWithTest;\n        } else {\n          this.updateLastIndex = noop;\n          this.match = this.matchWithExec;\n        }\n        if (hasOnlySingleMode) {\n          this.handleModes = noop;\n        }\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = identity;\n        }\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = noop;\n        }\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken;\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken;\n        } else {\n          throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`);\n        }\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush;\n          this.handlePayload = this.handlePayloadWithCustom;\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess;\n          this.handlePayload = this.handlePayloadNoCustom;\n        }\n      });\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n          return cannotBeOptimized;\n        }, []);\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(`Lexer Modes: < ${unOptimizedModes.join(\", \")} > cannot be optimized.\n\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.`);\n        }\n      });\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache();\n      });\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this);\n      });\n    });\n  }\n  tokenize(text, initialMode = this.defaultMode) {\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n        return error.message;\n      });\n      const allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n    return this.tokenizeInternal(text, initialMode);\n  }\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n  tokenizeInternal(text, initialMode) {\n    let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, msg, match;\n    const orgText = text;\n    const orgLength = orgText.length;\n    let offset = 0;\n    let matchedTokensIndex = 0;\n    const guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);\n    const matchedTokens = new Array(guessedNumberOfTokens);\n    const errors = [];\n    let line = this.trackStartLines ? 1 : void 0;\n    let column = this.trackStartLines ? 1 : void 0;\n    const groups = cloneEmptyGroups(this.emptyGroups);\n    const trackLines = this.trackStartLines;\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    let currModePatternsLength = 0;\n    let patternIdxToConfig = [];\n    let currCharCodeToPatternIdxToConfig = [];\n    const modeStack = [];\n    const emptyArray = [];\n    Object.freeze(emptyArray);\n    let getPossiblePatterns;\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n    function getPossiblePatternsOptimized(charCode) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n      const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n      if (possiblePatterns === void 0) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n    const pop_mode = (popToken) => {\n      if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === void 0) {\n        const msg2 = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg2\n        });\n      } else {\n        modeStack.pop();\n        const newMode = last(modeStack);\n        patternIdxToConfig = this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    }\n    push_mode.call(this, initialMode);\n    let currConfig;\n    const recoveryEnabled = this.config.recoveryEnabled;\n    while (offset < orgLength) {\n      matchedImage = null;\n      const nextCharCode = orgText.charCodeAt(offset);\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      const chosenPatternsLength = chosenPatternIdxToConfig.length;\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        const currPattern = currConfig.pattern;\n        payload = null;\n        const singleCharCode = currConfig.short;\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n          if (match !== null) {\n            matchedImage = match[0];\n            if (match.payload !== void 0) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n        if (matchedImage !== null) {\n          longerAlt = currConfig.longerAlt;\n          if (longerAlt !== void 0) {\n            const longerAltLength = longerAlt.length;\n            for (k = 0; k < longerAltLength; k++) {\n              const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n              const longerAltPattern = longerAltConfig.pattern;\n              altPayload = null;\n              if (longerAltConfig.isCustom === true) {\n                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                if (match !== null) {\n                  matchAltImage = match[0];\n                  if (match.payload !== void 0) {\n                    altPayload = match.payload;\n                  }\n                } else {\n                  matchAltImage = null;\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern, offset);\n                matchAltImage = this.match(longerAltPattern, text, offset);\n              }\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage;\n                payload = altPayload;\n                currConfig = longerAltConfig;\n                break;\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n        if (group !== void 0) {\n          tokType = currConfig.tokenTypeIdx;\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload);\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength;\n        column = this.computeNewColumn(column, imageLength);\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0;\n          let foundTerminator;\n          let lastLTEndOffset;\n          lineTerminatorPattern.lastIndex = 0;\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        }\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        const errorStartOffset = offset;\n        const errorLine = line;\n        const errorColumn = column;\n        let foundResyncPoint = recoveryEnabled === false;\n        while (foundResyncPoint === false && offset < orgLength) {\n          text = this.chopInput(text, 1);\n          offset++;\n          for (j = 0; j < currModePatternsLength; j++) {\n            const currConfig2 = patternIdxToConfig[j];\n            const currPattern = currConfig2.pattern;\n            const singleCharCode = currConfig2.short;\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                foundResyncPoint = true;\n              }\n            } else if (currConfig2.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n        errLength = offset - errorStartOffset;\n        column = this.computeNewColumn(column, errLength);\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n        if (recoveryEnabled === false) {\n          break;\n        }\n      }\n    }\n    if (!this.hasCustom) {\n      matchedTokens.length = matchedTokensIndex;\n    }\n    return {\n      tokens: matchedTokens,\n      groups,\n      errors\n    };\n  }\n  handleModes(config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      const pushMode = config.push;\n      pop_mode(newToken);\n      if (pushMode !== void 0) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== void 0) {\n      push_mode.call(this, config.push);\n    }\n  }\n  chopInput(text, length) {\n    return text.substring(length);\n  }\n  updateLastIndex(regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  }\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    let lastCharIsLT, fixForEndingInLT;\n    if (group !== void 0) {\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        newToken.endLine = line + fixForEndingInLT;\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      }\n    }\n  }\n  computeNewColumn(oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  }\n  createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType\n    };\n  }\n  createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType\n    };\n  }\n  createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType\n    };\n  }\n  addTokenUsingPush(tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  }\n  addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  }\n  handlePayloadNoCustom(token, payload) {\n  }\n  handlePayloadWithCustom(token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  }\n  matchWithTest(pattern, text, offset) {\n    const found = pattern.test(text);\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n    return null;\n  }\n  matchWithExec(pattern, text) {\n    const regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : null;\n  }\n}\nLexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\nLexer.NA = /NOT_APPLICABLE/;\nfunction tokenLabel(tokType) {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\nfunction hasTokenLabel(obj) {\n  return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\nconst PARENT = \"parent\";\nconst CATEGORIES = \"categories\";\nconst LABEL = \"label\";\nconst GROUP = \"group\";\nconst PUSH_MODE = \"push_mode\";\nconst POP_MODE = \"pop_mode\";\nconst LONGER_ALT = \"longer_alt\";\nconst LINE_BREAKS = \"line_breaks\";\nconst START_CHARS_HINT = \"start_chars_hint\";\nfunction createToken(config) {\n  return createTokenInternal(config);\n}\nfunction createTokenInternal(config) {\n  const pattern = config.pattern;\n  const tokenType = {};\n  tokenType.name = config.name;\n  if (!isUndefined(pattern)) {\n    tokenType.PATTERN = pattern;\n  }\n  if (has(config, PARENT)) {\n    throw \"The parent property is no longer supported.\\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\";\n  }\n  if (has(config, CATEGORIES)) {\n    tokenType.CATEGORIES = config[CATEGORIES];\n  }\n  augmentTokenTypes([tokenType]);\n  if (has(config, LABEL)) {\n    tokenType.LABEL = config[LABEL];\n  }\n  if (has(config, GROUP)) {\n    tokenType.GROUP = config[GROUP];\n  }\n  if (has(config, POP_MODE)) {\n    tokenType.POP_MODE = config[POP_MODE];\n  }\n  if (has(config, PUSH_MODE)) {\n    tokenType.PUSH_MODE = config[PUSH_MODE];\n  }\n  if (has(config, LONGER_ALT)) {\n    tokenType.LONGER_ALT = config[LONGER_ALT];\n  }\n  if (has(config, LINE_BREAKS)) {\n    tokenType.LINE_BREAKS = config[LINE_BREAKS];\n  }\n  if (has(config, START_CHARS_HINT)) {\n    tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n  }\n  return tokenType;\n}\nconst EOF = createToken({ name: \"EOF\", pattern: Lexer.NA });\naugmentTokenTypes([EOF]);\nfunction createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n  return {\n    image,\n    startOffset,\n    endOffset,\n    startLine,\n    endLine,\n    startColumn,\n    endColumn,\n    tokenTypeIdx: tokType.tokenTypeIdx,\n    tokenType: tokType\n  };\n}\nfunction tokenMatcher(token, tokType) {\n  return tokenStructuredMatcher(token, tokType);\n}\nconst defaultParserErrorProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n    const hasLabel = hasTokenLabel(expected);\n    const expectedMsg = hasLabel ? `--> ${tokenLabel(expected)} <--` : `token of type --> ${expected.name} <--`;\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n    return msg;\n  },\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName }) {\n    const errPrefix = \"Expecting: \";\n    const actualText = head(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n      const nextValidTokenSequences = map(allLookAheadPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\", \")}]`);\n      const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n      const calculatedDescription = `one of these possible Token sequences:\n${nextValidSequenceItems.join(\"\\n\")}`;\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName }) {\n    const errPrefix = \"Expecting: \";\n    const actualText = head(actual).image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const nextValidTokenSequences = map(expectedIterationPaths, (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\",\")}]`);\n      const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\n  <${nextValidTokenSequences.join(\" ,\")}>`;\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(defaultParserErrorProvider);\nconst defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError(topLevelRule, undefinedRule) {\n    const msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\ninside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nconst defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError(topLevelRule, duplicateProds) {\n    function getExtraProductionArgument2(prod) {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    const topLevelName = topLevelRule.name;\n    const duplicateProd = head(duplicateProds);\n    const index = duplicateProd.idx;\n    const dslName = getProductionDslName$1(duplicateProd);\n    const extraArgument = getExtraProductionArgument2(duplicateProd);\n    const hasExplicitIndex = index > 0;\n    let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : \"\"}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError(rule) {\n    const errMsg = `Namespace conflict found in grammar.\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\nTo resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.`;\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError(options) {\n    const pathMsg = map(options.prefixPath, (currTok) => tokenLabel(currTok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(\" ,\")}> due to common lookahead prefix\nin <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\nSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.`;\n    return errMsg;\n  },\n  buildAlternationAmbiguityError(options) {\n    const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(\", \");\n    const occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\" ,\")}> in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;\n    currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.`;\n    return currMessage;\n  },\n  buildEmptyRepetitionError(options) {\n    let dslName = getProductionDslName$1(options.repetition);\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n    const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\nThis could lead to an infinite loop.`;\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError(options) {\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError(options) {\n    const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}> in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\nOnly the last alternative may be an empty alternative.`;\n    return errMsg;\n  },\n  buildTooManyAlternativesError(options) {\n    const errMsg = `An Alternation cannot have more than 256 alternatives:\n<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\n has ${options.alternation.definition.length + 1} alternatives.`;\n    return errMsg;\n  },\n  buildLeftRecursionError(options) {\n    const ruleName = options.topLevelRule.name;\n    const pathNames = map(options.leftRecursionPath, (currRule) => currRule.name);\n    const leftRecursivePath = `${ruleName} --> ${pathNames.concat([ruleName]).join(\" --> \")}`;\n    const errMsg = `Left Recursion found in grammar.\nrule: <${ruleName}> can be invoked from itself (directly or indirectly)\nwithout consuming any Tokens. The grammar path that causes this is: \n ${leftRecursivePath}\n To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError(options) {\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError(options) {\n    let ruleName;\n    if (options.topLevelRule instanceof Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n    const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n    return errMsg;\n  }\n};\nfunction resolveGrammar$1(topLevels, errMsgProvider) {\n  const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n  refResolver.resolveRefs();\n  return refResolver.errors;\n}\nclass GastRefResolverVisitor extends GAstVisitor {\n  constructor(nameToTopRule, errMsgProvider) {\n    super();\n    this.nameToTopRule = nameToTopRule;\n    this.errMsgProvider = errMsgProvider;\n    this.errors = [];\n  }\n  resolveRefs() {\n    forEach(values(this.nameToTopRule), (prod) => {\n      this.currTopLevel = prod;\n      prod.accept(this);\n    });\n  }\n  visitNonTerminal(node) {\n    const ref = this.nameToTopRule[node.nonTerminalName];\n    if (!ref) {\n      const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n      this.errors.push({\n        message: msg,\n        type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n        ruleName: this.currTopLevel.name,\n        unresolvedRefName: node.nonTerminalName\n      });\n    } else {\n      node.referencedRule = ref;\n    }\n  }\n}\nclass AbstractNextPossibleTokensWalker extends RestWalker {\n  constructor(topProd, path) {\n    super();\n    this.topProd = topProd;\n    this.path = path;\n    this.possibleTokTypes = [];\n    this.nextProductionName = \"\";\n    this.nextProductionOccurrence = 0;\n    this.found = false;\n    this.isAtEndOfPath = false;\n  }\n  startWalking() {\n    this.found = false;\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n    this.ruleStack = clone(this.path.ruleStack).reverse();\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse();\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  }\n  walk(prod, prevRest = []) {\n    if (!this.found) {\n      super.walk(prod, prevRest);\n    }\n  }\n  walkProdRef(refProd, currRest, prevRest) {\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      const fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  }\n  updateExpectedNext() {\n    if (isEmpty(this.ruleStack)) {\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  }\n}\nclass NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n  constructor(topProd, path) {\n    super(topProd, path);\n    this.path = path;\n    this.nextTerminalName = \"\";\n    this.nextTerminalOccurrence = 0;\n    this.nextTerminalName = this.path.lastTok.name;\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n  }\n  walkTerminal(terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      const fullRest = currRest.concat(prevRest);\n      const restProd = new Alternative({ definition: fullRest });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  }\n}\nclass AbstractNextTerminalAfterProductionWalker extends RestWalker {\n  constructor(topRule, occurrence) {\n    super();\n    this.topRule = topRule;\n    this.occurrence = occurrence;\n    this.result = {\n      token: void 0,\n      occurrence: void 0,\n      isEndOfRule: void 0\n    };\n  }\n  startWalking() {\n    this.walk(this.topRule);\n    return this.result;\n  }\n}\nclass NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = head(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === void 0;\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest);\n    }\n  }\n}\nclass NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = head(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === void 0;\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest);\n    }\n  }\n}\nclass NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = head(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === void 0;\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n    }\n  }\n}\nclass NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = head(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n    }\n  }\n}\nfunction possiblePathsFrom(targetDef, maxLength, currPath = []) {\n  currPath = clone(currPath);\n  let result = [];\n  let i = 0;\n  function remainingPathWith(nextDef) {\n    return nextDef.concat(drop(targetDef, i + 1));\n  }\n  function getAlternativesForProd(definition) {\n    const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i];\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option$1) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)\n        })\n      ];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition)\n        })\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, (currAlt) => {\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  });\n  return result;\n}\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  const EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  const EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  let foundCompletePath = false;\n  const tokenVectorLength = tokenVector.length;\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  const result = [];\n  const possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n  while (!isEmpty(possiblePaths)) {\n    const currPath = possiblePaths.pop();\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n        possiblePaths.pop();\n      }\n      continue;\n    }\n    const currDef = currPath.def;\n    const currIdx = currPath.idx;\n    const currRuleStack = currPath.ruleStack;\n    const currOccurrenceStack = currPath.occurrenceStack;\n    if (isEmpty(currDef)) {\n      continue;\n    }\n    const prod = currDef[0];\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1;\n        const actualToken = tokenVector[nextIdx];\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        }\n      } else if (currIdx === tokenVectorLength - 1) {\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      const newOccurrenceStack = clone(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option$1) {\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      const secondIteration = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      });\n      const nthRepetition = new Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout);\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt = prod.definition[i];\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof Rule) {\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  const newRuleStack = clone(currRuleStack);\n  newRuleStack.push(topRule.name);\n  const newCurrOccurrenceStack = clone(currOccurrenceStack);\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}\nvar PROD_TYPE;\n(function(PROD_TYPE2) {\n  PROD_TYPE2[PROD_TYPE2[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE2[PROD_TYPE2[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE2[PROD_TYPE2[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nfunction getProdType$1(prod) {\n  if (prod instanceof Option$1 || prod === \"Option\") {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof Repetition || prod === \"Repetition\") {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof RepetitionMandatory || prod === \"RepetitionMandatory\") {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === \"RepetitionMandatoryWithSeparator\") {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof RepetitionWithSeparator || prod === \"RepetitionWithSeparator\") {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof Alternation || prod === \"Alternation\") {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction getLookaheadPaths(options) {\n  const { occurrence, rule, prodType, maxLookahead } = options;\n  const type = getProdType$1(prodType);\n  if (type === PROD_TYPE.ALTERNATION) {\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n  } else {\n    return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n  }\n}\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);\n}\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  const tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);\n}\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {\n  const numOfAlts = alts.length;\n  const areAllOneTokenLookahead = every(alts, (currAlt) => {\n    return every(currAlt, (currPath) => {\n      return currPath.length === 1;\n    });\n  });\n  if (hasPredicates) {\n    return function(orAlts) {\n      const predicates = map(orAlts, (currAlt) => currAlt.GATE);\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n        const currPredicate = predicates[t];\n        if (currPredicate !== void 0 && currPredicate.call(this) === false) {\n          continue;\n        }\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j];\n          const currPathLength = currPath.length;\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1);\n            if (tokenMatcher2(nextToken, currPath[i]) === false) {\n              continue nextPath;\n            }\n          }\n          return t;\n        }\n      }\n      return void 0;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokenAlts = map(alts, (currAlt) => {\n      return flatten(currAlt);\n    });\n    const choiceToAlt = reduce(singleTokenAlts, (result, currAlt, idx) => {\n      forEach(currAlt, (currTokType) => {\n        if (!has(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n        forEach(currTokType.categoryMatches, (currExtendingType) => {\n          if (!has(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, {});\n    return function() {\n      const nextToken = this.LA(1);\n      return choiceToAlt[nextToken.tokenTypeIdx];\n    };\n  } else {\n    return function() {\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j];\n          const currPathLength = currPath.length;\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1);\n            if (tokenMatcher2(nextToken, currPath[i]) === false) {\n              continue nextPath;\n            }\n          }\n          return t;\n        }\n      }\n      return void 0;\n    };\n  }\n}\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {\n  const areAllOneTokenLookahead = every(alt, (currPath) => {\n    return currPath.length === 1;\n  });\n  const numOfPaths = alt.length;\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokensTypes = flatten(alt);\n    if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n      const expectedTokenType = singleTokensTypes[0];\n      const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n      return function() {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n      };\n    } else {\n      const choiceToAlt = reduce(singleTokensTypes, (result, currTokType, idx) => {\n        result[currTokType.tokenTypeIdx] = true;\n        forEach(currTokType.categoryMatches, (currExtendingType) => {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function() {\n        const nextToken = this.LA(1);\n        return choiceToAlt[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function() {\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\n        const currPath = alt[j];\n        const currPathLength = currPath.length;\n        for (let i = 0; i < currPathLength; i++) {\n          const nextToken = this.LA(i + 1);\n          if (tokenMatcher2(nextToken, currPath[i]) === false) {\n            continue nextPath;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n  }\n}\nclass RestDefinitionFinderWalker extends RestWalker {\n  constructor(topProd, targetOccurrence, targetProdType) {\n    super();\n    this.topProd = topProd;\n    this.targetOccurrence = targetOccurrence;\n    this.targetProdType = targetProdType;\n  }\n  startWalking() {\n    this.walk(this.topProd);\n    return this.restDef;\n  }\n  checkIsTarget(node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    }\n    return false;\n  }\n  walkOption(optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      super.walkOption(optionProd, currRest, prevRest);\n    }\n  }\n  walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      super.walkOption(atLeastOneProd, currRest, prevRest);\n    }\n  }\n  walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      super.walkOption(atLeastOneSepProd, currRest, prevRest);\n    }\n  }\n  walkMany(manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      super.walkOption(manyProd, currRest, prevRest);\n    }\n  }\n  walkManySep(manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      super.walkOption(manySepProd, currRest, prevRest);\n    }\n  }\n}\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n  constructor(targetOccurrence, targetProdType, targetRef) {\n    super();\n    this.targetOccurrence = targetOccurrence;\n    this.targetProdType = targetProdType;\n    this.targetRef = targetRef;\n    this.result = [];\n  }\n  checkIsTarget(node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  }\n  visitOption(node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  }\n  visitRepetition(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  }\n  visitRepetitionMandatory(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  }\n  visitRepetitionMandatoryWithSeparator(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  }\n  visitRepetitionWithSeparator(node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  }\n  visitAlternation(node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  }\n}\nfunction initializeArrayOfArrays(size) {\n  const result = new Array(size);\n  for (let i = 0; i < size; i++) {\n    result[i] = [];\n  }\n  return result;\n}\nfunction pathToHashKeys(path) {\n  let keys2 = [\"\"];\n  for (let i = 0; i < path.length; i++) {\n    const tokType = path[i];\n    const longerKeys = [];\n    for (let j = 0; j < keys2.length; j++) {\n      const currShorterKey = keys2[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n      for (let t = 0; t < tokType.categoryMatches.length; t++) {\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n    keys2 = longerKeys;\n  }\n  return keys2;\n}\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    if (currAltIdx === idx) {\n      continue;\n    }\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      const searchKey = searchPathKeys[searchIdx];\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n  const partialAlts = map(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));\n  const finalResult = initializeArrayOfArrays(partialAlts.length);\n  const altsHashes = map(partialAlts, (currAltPaths) => {\n    const dict = {};\n    forEach(currAltPaths, (item) => {\n      const keys2 = pathToHashKeys(item.partialPath);\n      forEach(keys2, (currKey) => {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  let newData = partialAlts;\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\n    const currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      const currAltPathsAndSuffixes = currDataset[altIdx];\n      for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        const prefixKeys = pathToHashKeys(currPathPrefix);\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          const currAltResult = finalResult[altIdx];\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix);\n            for (let j = 0; j < prefixKeys.length; j++) {\n              const currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        } else {\n          const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n          forEach(newPartialPathsAndSuffixes, (item) => {\n            const prefixKeys2 = pathToHashKeys(item.partialPath);\n            forEach(prefixKeys2, (key) => {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    }\n  }\n  return finalResult;\n}\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  const visitor2 = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor2);\n  return lookAheadSequenceFromAlternatives(visitor2.result, k);\n}\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  const insideDef = insideDefVisitor.result;\n  const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  const afterDef = afterDefWalker.startWalking();\n  const insideFlat = new Alternative({ definition: insideDef });\n  const afterFlat = new Alternative({ definition: afterDef });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nfunction containsPath(alternative, searchPath) {\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n    const otherPath = alternative[i];\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n    for (let j = 0; j < otherPath.length; j++) {\n      const searchTok = searchPath[j];\n      const otherTok = otherPath[j];\n      const matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nfunction isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && every(prefix, (tokType, idx) => {\n    const otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n  return every(lookAheadPaths, (singleAltPaths) => every(singleAltPaths, (singlePath) => every(singlePath, (token) => isEmpty(token.categoryMatches))));\n}\nfunction validateLookahead(options) {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  });\n  return map(lookaheadValidationErrorMessages, (errorMessage) => Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage));\n}\nfunction validateGrammar$1(topLevels, tokenTypes, errMsgProvider, grammarName) {\n  const duplicateErrors = flatMap(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));\n  const duplicateRulesError = flatMap(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n  return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  const collectorVisitor2 = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor2);\n  const allRuleProductions = collectorVisitor2.allProductions;\n  const productionGroups = groupBy(allRuleProductions, identifyProductionForDuplicates);\n  const duplicates = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1;\n  });\n  const errors = map(values(duplicates), (currDuplicates) => {\n    const firstProd = head(currDuplicates);\n    const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    const dslName = getProductionDslName$1(firstProd);\n    const defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName,\n      occurrence: firstProd.idx\n    };\n    const param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n    return defError;\n  });\n  return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n  return `${getProductionDslName$1(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\nclass OccurrenceValidationCollector extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n  visitNonTerminal(subrule) {\n    this.allProductions.push(subrule);\n  }\n  visitOption(option2) {\n    this.allProductions.push(option2);\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n  visitAlternation(or) {\n    this.allProductions.push(or);\n  }\n  visitTerminal(terminal) {\n    this.allProductions.push(terminal);\n  }\n}\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  const errors = [];\n  const occurrences = reduce(allRules, (result, curRule) => {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n    return result;\n  }, 0);\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n  return errors;\n}\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  const errors = [];\n  let errMsg;\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg = `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-as it is not defined in any of the super grammars `;\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName\n    });\n  }\n  return errors;\n}\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n  const errors = [];\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    const ruleName = topRule.name;\n    const foundLeftRecursion = includes(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName\n      });\n    }\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\nfunction getFirstNoneTerminal(definition) {\n  let result = [];\n  if (isEmpty(definition)) {\n    return result;\n  }\n  const firstProd = head(definition);\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof Alternative || firstProd instanceof Option$1 || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    result = flatten(map(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));\n  } else if (firstProd instanceof Terminal) ;\n  else {\n    throw Error(\"non exhaustive match\");\n  }\n  const isFirstOptional = isOptionalProd(firstProd);\n  const hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\nclass OrCollector extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.alternations = [];\n  }\n  visitAlternation(node) {\n    this.alternations.push(node);\n  }\n}\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = flatMap(ors, (currOr) => {\n    const exceptLast = dropRight(currOr.definition);\n    return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n      const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n      if (isEmpty(possibleFirstInAlt)) {\n        return [\n          {\n            message: errMsgProvider.buildEmptyAlternationError({\n              topLevelRule,\n              alternation: currOr,\n              emptyChoiceIdx: currAltIdx\n            }),\n            type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n            ruleName: topLevelRule.name,\n            occurrence: currOr.idx,\n            alternative: currAltIdx + 1\n          }\n        ];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  let ors = orCollector.alternations;\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\n  const errors = flatMap(ors, (currOr) => {\n    const currOccurrence = currOr.idx;\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\nclass RepetitionCollector extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.allProductions = [];\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.allProductions.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.allProductions.push(many);\n  }\n}\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        }\n      ];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  const errors = [];\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor2 = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor2);\n    const allRuleProductions = collectorVisitor2.allProductions;\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType$1(currProd);\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      const currOccurrence = currProd.idx;\n      const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      const pathsInsideProduction = paths[0];\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation2, rule, errMsgProvider) {\n  const foundAmbiguousPaths = [];\n  const identicalAmbiguities = reduce(alternatives, (result, currAlt, currAltIdx) => {\n    if (alternation2.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n    forEach(currAlt, (currPath) => {\n      const altsCurrPathAppearsIn = [currAltIdx];\n      forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation2.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation2,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation2.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation2, rule, errMsgProvider) {\n  const pathsAndIndices = reduce(alternatives, (result, currAlt, idx) => {\n    const currPathsAndIdx = map(currAlt, (currPath) => {\n      return { idx, path: currPath };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  const errors = compact(flatMap(pathsAndIndices, (currPathAndIdx) => {\n    const alternativeGast = alternation2.definition[currPathAndIdx.idx];\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n    const targetIdx = currPathAndIdx.idx;\n    const targetPath = currPathAndIdx.path;\n    const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, (searchPathAndIdx) => {\n      return (\n        // ignore (skip) ambiguities with this \"other\" alternative\n        alternation2.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n      const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      const occurrence = alternation2.idx === 0 ? \"\" : alternation2.idx;\n      const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation2,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  const errors = [];\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name);\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name;\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}\nfunction resolveGrammar(options) {\n  const actualOptions = defaults(options, {\n    errMsgProvider: defaultGrammarResolverErrorProvider\n  });\n  const topRulesTable = {};\n  forEach(options.rules, (rule) => {\n    topRulesTable[rule.name] = rule;\n  });\n  return resolveGrammar$1(topRulesTable, actualOptions.errMsgProvider);\n}\nfunction validateGrammar(options) {\n  options = defaults(options, {\n    errMsgProvider: defaultGrammarValidatorErrorProvider\n  });\n  return validateGrammar$1(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nconst RECOGNITION_EXCEPTION_NAMES = [\n  MISMATCHED_TOKEN_EXCEPTION,\n  NO_VIABLE_ALT_EXCEPTION,\n  EARLY_EXIT_EXCEPTION,\n  NOT_ALL_INPUT_PARSED_EXCEPTION\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\nfunction isRecognitionException(error) {\n  return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nclass RecognitionException extends Error {\n  constructor(message, token) {\n    super(message);\n    this.token = token;\n    this.resyncedTokens = [];\n    Object.setPrototypeOf(this, new.target.prototype);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\nclass MismatchedTokenException extends RecognitionException {\n  constructor(message, token, previousToken) {\n    super(message, token);\n    this.previousToken = previousToken;\n    this.name = MISMATCHED_TOKEN_EXCEPTION;\n  }\n}\nclass NoViableAltException extends RecognitionException {\n  constructor(message, token, previousToken) {\n    super(message, token);\n    this.previousToken = previousToken;\n    this.name = NO_VIABLE_ALT_EXCEPTION;\n  }\n}\nclass NotAllInputParsedException extends RecognitionException {\n  constructor(message, token) {\n    super(message, token);\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n  }\n}\nclass EarlyExitException extends RecognitionException {\n  constructor(message, token, previousToken) {\n    super(message, token);\n    this.previousToken = previousToken;\n    this.name = EARLY_EXIT_EXCEPTION;\n  }\n}\nconst EOF_FOLLOW_KEY = {};\nconst IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nclass InRuleRecoveryException extends Error {\n  constructor(message) {\n    super(message);\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n  }\n}\nclass Recoverable {\n  initRecoverable(config) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n    this.recoveryEnabled = has(config, \"recoveryEnabled\") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  }\n  getTokenToInsert(tokType) {\n    const tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  }\n  canTokenTypeBeInsertedInRecovery(tokType) {\n    return true;\n  }\n  canTokenTypeBeDeletedInRecovery(tokType) {\n    return true;\n  }\n  tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n    const reSyncTokType = this.findReSyncTokenType();\n    const savedLexerState = this.exportLexerState();\n    const resyncedTokens = [];\n    let passedResyncPoint = false;\n    const nextTokenWithoutResync = this.LA(1);\n    let currToken = this.LA(1);\n    const generateErrorMessage = () => {\n      const previousToken = this.LA(0);\n      const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n      const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n      error.resyncedTokens = dropRight(resyncedTokens);\n      this.SAVE_ERROR(error);\n    };\n    while (!passedResyncPoint) {\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return;\n      } else if (lookAheadFunc.call(this)) {\n        generateErrorMessage();\n        grammarRule.apply(this, grammarRuleArgs);\n        return;\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    }\n    this.importLexerState(savedLexerState);\n  }\n  shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n    if (notStuck === false) {\n      return false;\n    }\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    }\n    if (this.isBackTracking()) {\n      return false;\n    }\n    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n      return false;\n    }\n    return true;\n  }\n  // Error Recovery functionality\n  getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n    const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    const follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  }\n  tryInRuleRecovery(expectedTokType, follows) {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      const tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      const nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  }\n  canPerformInRuleRecovery(expectedToken, follows) {\n    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n  }\n  canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    }\n    if (isEmpty(follows)) {\n      return false;\n    }\n    const mismatchedTok = this.LA(1);\n    const isMisMatchedTokInFollows = find(follows, (possibleFollowsTokType) => {\n      return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n    }) !== void 0;\n    return isMisMatchedTokInFollows;\n  }\n  canRecoverWithSingleTokenDeletion(expectedTokType) {\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n      return false;\n    }\n    const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n    return isNextTokenWhatIsExpected;\n  }\n  isInCurrentRuleReSyncSet(tokenTypeIdx) {\n    const followKey = this.getCurrFollowKey();\n    const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return includes(currentRuleReSyncSet, tokenTypeIdx);\n  }\n  findReSyncTokenType() {\n    const allPossibleReSyncTokTypes = this.flattenFollowSet();\n    let nextToken = this.LA(1);\n    let k = 2;\n    while (true) {\n      const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\n        const canMatch = tokenMatcher(nextToken, resyncTokType);\n        return canMatch;\n      });\n      if (foundMatch !== void 0) {\n        return foundMatch;\n      }\n      nextToken = this.LA(k);\n      k++;\n    }\n  }\n  getCurrFollowKey() {\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY;\n    }\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    };\n  }\n  buildFullFollowKeyStack() {\n    const explicitRuleStack = this.RULE_STACK;\n    const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return map(explicitRuleStack, (ruleName, idx) => {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY;\n      }\n      return {\n        ruleName: this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      };\n    });\n  }\n  flattenFollowSet() {\n    const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n      return this.getFollowSetFromFollowKey(currKey);\n    });\n    return flatten(followStack);\n  }\n  getFollowSetFromFollowKey(followKey) {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF];\n    }\n    const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n    return this.resyncFollows[followName];\n  }\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  addToResyncTokens(token, resyncTokens) {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token);\n    }\n    return resyncTokens;\n  }\n  reSyncTo(tokType) {\n    const resyncedTokens = [];\n    let nextTok = this.LA(1);\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    }\n    return dropRight(resyncedTokens);\n  }\n  attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  }\n  getCurrentGrammarPath(tokType, tokIdxInRule) {\n    const pathRuleStack = this.getHumanReadableRuleStack();\n    const pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK);\n    const grammarPath = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    };\n    return grammarPath;\n  }\n  getHumanReadableRuleStack() {\n    return map(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));\n  }\n}\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  let firstAfterRepInfo = this.firstAfterRepMap[key];\n  if (firstAfterRepInfo === void 0) {\n    const currRuleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[currRuleName];\n    const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n  let expectTokAfterLastMatch = firstAfterRepInfo.token;\n  let nextTokIdx = firstAfterRepInfo.occurrence;\n  const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {\n    expectTokAfterLastMatch = EOF;\n    nextTokIdx = 1;\n  }\n  if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {\n    return;\n  }\n  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n  }\n}\nconst BITS_FOR_METHOD_TYPE = 4;\nconst BITS_FOR_OCCURRENCE_IDX = 8;\nconst OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nconst OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nconst MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nconst AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nconst MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nconst AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\nfunction getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n  return occurrence | dslMethodIdx | ruleIdx;\n}\nclass LLkLookaheadStrategy {\n  constructor(options) {\n    var _a2;\n    this.maxLookahead = (_a2 = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a2 !== void 0 ? _a2 : DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n  validate(options) {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n    if (isEmpty(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors\n      ];\n      return allErrors;\n    }\n    return leftRecursionErrors;\n  }\n  validateNoLeftRecursion(rules) {\n    return flatMap(rules, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));\n  }\n  validateEmptyOrAlternatives(rules) {\n    return flatMap(rules, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));\n  }\n  validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n    return flatMap(rules, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));\n  }\n  validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n    return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n  }\n  buildLookaheadForAlternation(options) {\n    return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n  }\n  buildLookaheadForOptional(options) {\n    return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType$1(options.prodType), buildSingleAlternativeLookaheadFunction);\n  }\n}\nclass LooksAhead {\n  initLooksAhead(config) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = has(config, \"maxLookahead\") ? config.maxLookahead : DEFAULT_PARSER_CONFIG.maxLookahead;\n    this.lookaheadStrategy = has(config, \"lookaheadStrategy\") ? config.lookaheadStrategy : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n    this.lookAheadFuncsCache = /* @__PURE__ */ new Map();\n  }\n  preComputeLookaheadFunctions(rules) {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const { alternation: alternation2, repetition: repetition2, option: option2, repetitionMandatory: repetitionMandatory2, repetitionMandatoryWithSeparator, repetitionWithSeparator } = collectMethods(currRule);\n        forEach(alternation2, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          this.TRACE_INIT(`${getProductionDslName$1(currProd)}${prodIdx}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: this.dynamicTokensEnabled\n            });\n            const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n            this.setLaFuncCache(key, laFunc);\n          });\n        });\n        forEach(repetition2, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, \"Repetition\", currProd.maxLookahead, getProductionDslName$1(currProd));\n        });\n        forEach(option2, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, \"Option\", currProd.maxLookahead, getProductionDslName$1(currProd));\n        });\n        forEach(repetitionMandatory2, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, getProductionDslName$1(currProd));\n        });\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, getProductionDslName$1(currProd));\n        });\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, getProductionDslName$1(currProd));\n        });\n      });\n    });\n  }\n  computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`, () => {\n      const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n        prodOccurrence,\n        rule,\n        maxLookahead: prodMaxLookahead || this.maxLookahead,\n        dynamicTokensEnabled: this.dynamicTokensEnabled,\n        prodType\n      });\n      const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n      this.setLaFuncCache(key, laFunc);\n    });\n  }\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n  }\n  getLaFuncFromCache(key) {\n    return this.lookAheadFuncsCache.get(key);\n  }\n  /* istanbul ignore next */\n  setLaFuncCache(key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  }\n}\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n  constructor() {\n    super(...arguments);\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  }\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    };\n  }\n  visitOption(option2) {\n    this.dslMethods.option.push(option2);\n  }\n  visitRepetitionWithSeparator(manySep) {\n    this.dslMethods.repetitionWithSeparator.push(manySep);\n  }\n  visitRepetitionMandatory(atLeastOne) {\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\n  }\n  visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n  }\n  visitRepetition(many) {\n    this.dslMethods.repetition.push(many);\n  }\n  visitAlternation(or) {\n    this.dslMethods.alternation.push(or);\n  }\n}\nconst collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n  collectorVisitor.reset();\n  rule.accept(collectorVisitor);\n  const dslMethods = collectorVisitor.dslMethods;\n  collectorVisitor.reset();\n  return dslMethods;\n}\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\nfunction addTerminalToCst(node, token, tokenTypeName) {\n  if (node.children[tokenTypeName] === void 0) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n  if (node.children[ruleName] === void 0) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\nconst NAME = \"name\";\nfunction defineNameProp(obj, nameValue) {\n  Object.defineProperty(obj, NAME, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: nameValue\n  });\n}\nfunction defaultVisit(ctx, param) {\n  const childrenNames = keys(ctx);\n  const childrenNamesLength = childrenNames.length;\n  for (let i = 0; i < childrenNamesLength; i++) {\n    const currChildName = childrenNames[i];\n    const currChildArray = ctx[currChildName];\n    const currChildArrayLength = currChildArray.length;\n    for (let j = 0; j < currChildArrayLength; j++) {\n      const currChild = currChildArray[j];\n      if (currChild.tokenTypeIdx === void 0) {\n        this[currChild.name](currChild.children, param);\n      }\n    }\n  }\n}\nfunction createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n  const derivedConstructor = function() {\n  };\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n  const semanticProto = {\n    visit: function(cstNode, param) {\n      if (isArray(cstNode)) {\n        cstNode = cstNode[0];\n      }\n      if (isUndefined(cstNode)) {\n        return void 0;\n      }\n      return this[cstNode.name](cstNode.children, param);\n    },\n    validateVisitor: function() {\n      const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n      if (!isEmpty(semanticDefinitionErrors)) {\n        const errorMessages = map(semanticDefinitionErrors, (currDefError) => currDefError.msg);\n        throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\n\t${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\t\")}`);\n      }\n    }\n  };\n  derivedConstructor.prototype = semanticProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  derivedConstructor._RULE_NAMES = ruleNames;\n  return derivedConstructor;\n}\nfunction createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n  const derivedConstructor = function() {\n  };\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n  const withDefaultsProto = Object.create(baseConstructor.prototype);\n  forEach(ruleNames, (ruleName) => {\n    withDefaultsProto[ruleName] = defaultVisit;\n  });\n  derivedConstructor.prototype = withDefaultsProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  return derivedConstructor;\n}\nvar CstVisitorDefinitionError;\n(function(CstVisitorDefinitionError2) {\n  CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n  CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nfunction validateVisitor(visitorInstance, ruleNames) {\n  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n  return missingErrors;\n}\nfunction validateMissingCstMethods(visitorInstance, ruleNames) {\n  const missingRuleNames = filter(ruleNames, (currRuleName) => {\n    return isFunction(visitorInstance[currRuleName]) === false;\n  });\n  const errors = map(missingRuleNames, (currRuleName) => {\n    return {\n      msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,\n      type: CstVisitorDefinitionError.MISSING_METHOD,\n      methodName: currRuleName\n    };\n  });\n  return compact(errors);\n}\nclass TreeBuilder {\n  initTreeBuilder(config) {\n    this.CST_STACK = [];\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = noop;\n      this.cstFinallyStateUpdate = noop;\n      this.cstPostTerminal = noop;\n      this.cstPostNonTerminal = noop;\n      this.cstPostRule = noop;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = noop;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop;\n          this.setNodeLocationFromNode = noop;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n          this.cstPostRule = noop;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop;\n          this.setNodeLocationFromNode = noop;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = noop;\n        this.setNodeLocationFromNode = noop;\n        this.cstPostRule = noop;\n        this.setInitialNodeLocation = noop;\n      } else {\n        throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`);\n      }\n    }\n  }\n  setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  }\n  setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  }\n  setInitialNodeLocationFullRecovery(cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  }\n  /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n  setInitialNodeLocationFullRegular(cstNode) {\n    const nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  }\n  cstInvocationStateUpdate(fullRuleName) {\n    const cstNode = {\n      name: fullRuleName,\n      children: /* @__PURE__ */ Object.create(null)\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  }\n  cstFinallyStateUpdate() {\n    this.CST_STACK.pop();\n  }\n  cstPostRuleFull(ruleCstNode) {\n    const prevToken = this.LA(0);\n    const loc = ruleCstNode.location;\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    } else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  }\n  cstPostRuleOnlyOffset(ruleCstNode) {\n    const prevToken = this.LA(0);\n    const loc = ruleCstNode.location;\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    } else {\n      loc.startOffset = NaN;\n    }\n  }\n  cstPostTerminal(key, consumedToken) {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key);\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  }\n  cstPostNonTerminal(ruleCstResult, ruleName) {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  }\n  getBaseCstVisitorConstructor() {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n    return this.baseCstVisitorConstructor;\n  }\n  getBaseCstVisitorConstructorWithDefaults() {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n    return this.baseCstVisitorWithDefaultsConstructor;\n  }\n  getLastExplicitRuleShortName() {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  }\n  getPreviousExplicitRuleShortName() {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  }\n  getLastExplicitRuleOccurrenceIndex() {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  }\n}\nclass LexerAdapter {\n  initLexerAdapter() {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  }\n  set input(newInput) {\n    if (this.selfAnalysisDone !== true) {\n      throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);\n    }\n    this.reset();\n    this.tokVector = newInput;\n    this.tokVectorLength = newInput.length;\n  }\n  get input() {\n    return this.tokVector;\n  }\n  // skips a token and returns the next token\n  SKIP_TOKEN() {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return END_OF_FILE;\n    }\n  }\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LA(howMuch) {\n    const soughtIdx = this.currIdx + howMuch;\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  }\n  consumeToken() {\n    this.currIdx++;\n  }\n  exportLexerState() {\n    return this.currIdx;\n  }\n  importLexerState(newState2) {\n    this.currIdx = newState2;\n  }\n  resetLexerState() {\n    this.currIdx = -1;\n  }\n  moveToTerminatedState() {\n    this.currIdx = this.tokVector.length - 1;\n  }\n  getLexerPosition() {\n    return this.exportLexerState();\n  }\n}\nclass RecognizerApi {\n  ACTION(impl) {\n    return impl.call(this);\n  }\n  consume(idx, tokType, options) {\n    return this.consumeInternal(tokType, idx, options);\n  }\n  subrule(idx, ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, idx, options);\n  }\n  option(idx, actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, idx);\n  }\n  or(idx, altsOrOpts) {\n    return this.orInternal(altsOrOpts, idx);\n  }\n  many(idx, actionORMethodDef) {\n    return this.manyInternal(idx, actionORMethodDef);\n  }\n  atLeastOne(idx, actionORMethodDef) {\n    return this.atLeastOneInternal(idx, actionORMethodDef);\n  }\n  CONSUME(tokType, options) {\n    return this.consumeInternal(tokType, 0, options);\n  }\n  CONSUME1(tokType, options) {\n    return this.consumeInternal(tokType, 1, options);\n  }\n  CONSUME2(tokType, options) {\n    return this.consumeInternal(tokType, 2, options);\n  }\n  CONSUME3(tokType, options) {\n    return this.consumeInternal(tokType, 3, options);\n  }\n  CONSUME4(tokType, options) {\n    return this.consumeInternal(tokType, 4, options);\n  }\n  CONSUME5(tokType, options) {\n    return this.consumeInternal(tokType, 5, options);\n  }\n  CONSUME6(tokType, options) {\n    return this.consumeInternal(tokType, 6, options);\n  }\n  CONSUME7(tokType, options) {\n    return this.consumeInternal(tokType, 7, options);\n  }\n  CONSUME8(tokType, options) {\n    return this.consumeInternal(tokType, 8, options);\n  }\n  CONSUME9(tokType, options) {\n    return this.consumeInternal(tokType, 9, options);\n  }\n  SUBRULE(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 0, options);\n  }\n  SUBRULE1(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 1, options);\n  }\n  SUBRULE2(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 2, options);\n  }\n  SUBRULE3(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 3, options);\n  }\n  SUBRULE4(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 4, options);\n  }\n  SUBRULE5(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 5, options);\n  }\n  SUBRULE6(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 6, options);\n  }\n  SUBRULE7(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 7, options);\n  }\n  SUBRULE8(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 8, options);\n  }\n  SUBRULE9(ruleToCall, options) {\n    return this.subruleInternal(ruleToCall, 9, options);\n  }\n  OPTION(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 0);\n  }\n  OPTION1(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 1);\n  }\n  OPTION2(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 2);\n  }\n  OPTION3(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 3);\n  }\n  OPTION4(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 4);\n  }\n  OPTION5(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 5);\n  }\n  OPTION6(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 6);\n  }\n  OPTION7(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 7);\n  }\n  OPTION8(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 8);\n  }\n  OPTION9(actionORMethodDef) {\n    return this.optionInternal(actionORMethodDef, 9);\n  }\n  OR(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 0);\n  }\n  OR1(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 1);\n  }\n  OR2(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 2);\n  }\n  OR3(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 3);\n  }\n  OR4(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 4);\n  }\n  OR5(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 5);\n  }\n  OR6(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 6);\n  }\n  OR7(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 7);\n  }\n  OR8(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 8);\n  }\n  OR9(altsOrOpts) {\n    return this.orInternal(altsOrOpts, 9);\n  }\n  MANY(actionORMethodDef) {\n    this.manyInternal(0, actionORMethodDef);\n  }\n  MANY1(actionORMethodDef) {\n    this.manyInternal(1, actionORMethodDef);\n  }\n  MANY2(actionORMethodDef) {\n    this.manyInternal(2, actionORMethodDef);\n  }\n  MANY3(actionORMethodDef) {\n    this.manyInternal(3, actionORMethodDef);\n  }\n  MANY4(actionORMethodDef) {\n    this.manyInternal(4, actionORMethodDef);\n  }\n  MANY5(actionORMethodDef) {\n    this.manyInternal(5, actionORMethodDef);\n  }\n  MANY6(actionORMethodDef) {\n    this.manyInternal(6, actionORMethodDef);\n  }\n  MANY7(actionORMethodDef) {\n    this.manyInternal(7, actionORMethodDef);\n  }\n  MANY8(actionORMethodDef) {\n    this.manyInternal(8, actionORMethodDef);\n  }\n  MANY9(actionORMethodDef) {\n    this.manyInternal(9, actionORMethodDef);\n  }\n  MANY_SEP(options) {\n    this.manySepFirstInternal(0, options);\n  }\n  MANY_SEP1(options) {\n    this.manySepFirstInternal(1, options);\n  }\n  MANY_SEP2(options) {\n    this.manySepFirstInternal(2, options);\n  }\n  MANY_SEP3(options) {\n    this.manySepFirstInternal(3, options);\n  }\n  MANY_SEP4(options) {\n    this.manySepFirstInternal(4, options);\n  }\n  MANY_SEP5(options) {\n    this.manySepFirstInternal(5, options);\n  }\n  MANY_SEP6(options) {\n    this.manySepFirstInternal(6, options);\n  }\n  MANY_SEP7(options) {\n    this.manySepFirstInternal(7, options);\n  }\n  MANY_SEP8(options) {\n    this.manySepFirstInternal(8, options);\n  }\n  MANY_SEP9(options) {\n    this.manySepFirstInternal(9, options);\n  }\n  AT_LEAST_ONE(actionORMethodDef) {\n    this.atLeastOneInternal(0, actionORMethodDef);\n  }\n  AT_LEAST_ONE1(actionORMethodDef) {\n    return this.atLeastOneInternal(1, actionORMethodDef);\n  }\n  AT_LEAST_ONE2(actionORMethodDef) {\n    this.atLeastOneInternal(2, actionORMethodDef);\n  }\n  AT_LEAST_ONE3(actionORMethodDef) {\n    this.atLeastOneInternal(3, actionORMethodDef);\n  }\n  AT_LEAST_ONE4(actionORMethodDef) {\n    this.atLeastOneInternal(4, actionORMethodDef);\n  }\n  AT_LEAST_ONE5(actionORMethodDef) {\n    this.atLeastOneInternal(5, actionORMethodDef);\n  }\n  AT_LEAST_ONE6(actionORMethodDef) {\n    this.atLeastOneInternal(6, actionORMethodDef);\n  }\n  AT_LEAST_ONE7(actionORMethodDef) {\n    this.atLeastOneInternal(7, actionORMethodDef);\n  }\n  AT_LEAST_ONE8(actionORMethodDef) {\n    this.atLeastOneInternal(8, actionORMethodDef);\n  }\n  AT_LEAST_ONE9(actionORMethodDef) {\n    this.atLeastOneInternal(9, actionORMethodDef);\n  }\n  AT_LEAST_ONE_SEP(options) {\n    this.atLeastOneSepFirstInternal(0, options);\n  }\n  AT_LEAST_ONE_SEP1(options) {\n    this.atLeastOneSepFirstInternal(1, options);\n  }\n  AT_LEAST_ONE_SEP2(options) {\n    this.atLeastOneSepFirstInternal(2, options);\n  }\n  AT_LEAST_ONE_SEP3(options) {\n    this.atLeastOneSepFirstInternal(3, options);\n  }\n  AT_LEAST_ONE_SEP4(options) {\n    this.atLeastOneSepFirstInternal(4, options);\n  }\n  AT_LEAST_ONE_SEP5(options) {\n    this.atLeastOneSepFirstInternal(5, options);\n  }\n  AT_LEAST_ONE_SEP6(options) {\n    this.atLeastOneSepFirstInternal(6, options);\n  }\n  AT_LEAST_ONE_SEP7(options) {\n    this.atLeastOneSepFirstInternal(7, options);\n  }\n  AT_LEAST_ONE_SEP8(options) {\n    this.atLeastOneSepFirstInternal(8, options);\n  }\n  AT_LEAST_ONE_SEP9(options) {\n    this.atLeastOneSepFirstInternal(9, options);\n  }\n  RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n    if (includes(this.definedRulesNames, name)) {\n      const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n        topLevelRule: name,\n        grammarName: this.className\n      });\n      const error = {\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: name\n      };\n      this.definitionErrors.push(error);\n    }\n    this.definedRulesNames.push(name);\n    const ruleImplementation = this.defineRule(name, implementation, config);\n    this[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n  OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n    const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n    this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n    const ruleImplementation = this.defineRule(name, impl, config);\n    this[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n  BACKTRACK(grammarRule, args) {\n    return function() {\n      this.isBackTrackingStack.push(1);\n      const orgState = this.saveRecogState();\n      try {\n        grammarRule.apply(this, args);\n        return true;\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return false;\n        } else {\n          throw e;\n        }\n      } finally {\n        this.reloadRecogState(orgState);\n        this.isBackTrackingStack.pop();\n      }\n    };\n  }\n  // GAST export APIs\n  getGAstProductions() {\n    return this.gastProductionsCache;\n  }\n  getSerializedGastProductions() {\n    return serializeGrammar(values(this.gastProductionsCache));\n  }\n}\nclass RecognizerEngine {\n  initRecognizerEngine(tokenVocabulary, config) {\n    this.className = this.constructor.name;\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokenStructuredMatcherNoCategories;\n    this.subruleIdx = 0;\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\tFor Further details.\");\n    }\n    if (isArray(tokenVocabulary)) {\n      if (isEmpty(tokenVocabulary)) {\n        throw Error(\"A Token Vocabulary cannot be empty.\\n\tNote that the first argument for the parser constructor\\n\tis no longer a Token vector (since v4.0).\");\n      }\n      if (typeof tokenVocabulary[0].startOffset === \"number\") {\n        throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\tFor Further details.\");\n      }\n    }\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = reduce(tokenVocabulary, (acc, tokType) => {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (has(tokenVocabulary, \"modes\") && every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n      const allTokenTypes2 = flatten(values(tokenVocabulary.modes));\n      const uniqueTokens = uniq(allTokenTypes2);\n      this.tokensMap = reduce(uniqueTokens, (acc, tokType) => {\n        acc[tokType.name] = tokType;\n        return acc;\n      }, {});\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = clone(tokenVocabulary);\n    } else {\n      throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n    }\n    this.tokensMap[\"EOF\"] = EOF;\n    const allTokenTypes = has(tokenVocabulary, \"modes\") ? flatten(values(tokenVocabulary.modes)) : values(tokenVocabulary);\n    const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) => isEmpty(tokenConstructor.categoryMatches));\n    this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n    augmentTokenTypes(values(this.tokensMap));\n  }\n  defineRule(ruleName, impl, config) {\n    if (this.selfAnalysisDone) {\n      throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);\n    }\n    const resyncEnabled = has(config, \"resyncEnabled\") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;\n    const recoveryValueFunc = has(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n    const shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n    let invokeRuleWithTry;\n    if (this.outputCst === true) {\n      invokeRuleWithTry = function invokeRuleWithTry2(...args) {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          impl.apply(this, args);\n          const cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst;\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    } else {\n      invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          return impl.apply(this, args);\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    }\n    const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });\n    return wrappedGrammarRule;\n  }\n  invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1;\n    const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n    if (isRecognitionException(e)) {\n      const recogError = e;\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType();\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n          if (this.outputCst) {\n            const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc(e);\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          }\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        this.moveToTerminatedState();\n        return recoveryValueFunc(e);\n      } else {\n        throw recogError;\n      }\n    } else {\n      throw e;\n    }\n  }\n  // Implementation of parsing DSL\n  optionInternal(actionORMethodDef, occurrence) {\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  }\n  optionInternalLogic(actionORMethodDef, occurrence, key) {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      if (predicate !== void 0) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n    return void 0;\n  }\n  atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n    const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n  atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      if (predicate !== void 0) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    if (lookAheadFunc.call(this) === true) {\n      let notStuck = this.doSingleRepetition(action);\n      while (lookAheadFunc.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n    }\n    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n  }\n  atLeastOneSepFirstInternal(prodOccurrence, options) {\n    const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n  atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      action.call(this);\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      };\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        this.CONSUME(separator);\n        action.call(this);\n      }\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        NextTerminalAfterAtLeastOneSepWalker\n      ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n    } else {\n      throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n    }\n  }\n  manyInternal(prodOccurrence, actionORMethodDef) {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n  manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n    let lookaheadFunction = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      if (predicate !== void 0) {\n        const orgLookaheadFunction = lookaheadFunction;\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n    let notStuck = true;\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    }\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck\n    );\n  }\n  manySepFirstInternal(prodOccurrence, options) {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n  manySepFirstInternalLogic(prodOccurrence, options, key) {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLaFunc = this.getLaFuncFromCache(key);\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      };\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        this.CONSUME(separator);\n        action.call(this);\n      }\n      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        NextTerminalAfterManySepWalker\n      ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n    }\n  }\n  repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n    while (separatorLookAheadFunc()) {\n      this.CONSUME(separator);\n      action.call(this);\n    }\n    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n      prodOccurrence,\n      separator,\n      separatorLookAheadFunc,\n      action,\n      nextTerminalAfterWalker\n    ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n  }\n  doSingleRepetition(action) {\n    const beforeIteration = this.getLexerPosition();\n    action.call(this);\n    const afterIteration = this.getLexerPosition();\n    return afterIteration > beforeIteration;\n  }\n  orInternal(altsOrOpts, occurrence) {\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n    const laFunc = this.getLaFuncFromCache(laKey);\n    const altIdxToTake = laFunc.call(this, alts);\n    if (altIdxToTake !== void 0) {\n      const chosenAlternative = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n  }\n  ruleFinallyStateUpdate() {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n    this.cstFinallyStateUpdate();\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1);\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      });\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n    }\n  }\n  subruleInternal(ruleToCall, idx, options) {\n    let ruleResult;\n    try {\n      const args = options !== void 0 ? options.ARGS : void 0;\n      this.subruleIdx = idx;\n      ruleResult = ruleToCall.apply(this, args);\n      this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);\n      return ruleResult;\n    } catch (e) {\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  }\n  subruleInternalError(e, options, ruleName) {\n    if (isRecognitionException(e) && e.partialCstResult !== void 0) {\n      this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);\n      delete e.partialCstResult;\n    }\n    throw e;\n  }\n  consumeInternal(tokType, idx, options) {\n    let consumedToken;\n    try {\n      const nextToken = this.LA(1);\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n    }\n    this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);\n    return consumedToken;\n  }\n  consumeInternalError(tokType, nextToken, options) {\n    let msg;\n    const previousToken = this.LA(0);\n    if (options !== void 0 && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      });\n    }\n    throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n  }\n  consumeInternalRecovery(tokType, idx, eFromConsumption) {\n    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n    eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n      const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n      try {\n        return this.tryInRuleRecovery(tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  }\n  saveRecogState() {\n    const savedErrors = this.errors;\n    const savedRuleStack = clone(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    };\n  }\n  reloadRecogState(newState2) {\n    this.errors = newState2.errors;\n    this.importLexerState(newState2.lexerState);\n    this.RULE_STACK = newState2.RULE_STACK;\n  }\n  ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName);\n    this.cstInvocationStateUpdate(fullName);\n  }\n  isBackTracking() {\n    return this.isBackTrackingStack.length !== 0;\n  }\n  getCurrRuleFullName() {\n    const shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  }\n  shortRuleNameToFullName(shortName) {\n    return this.shortRuleNameToFull[shortName];\n  }\n  isAtEndOfInput() {\n    return this.tokenMatcher(this.LA(1), EOF);\n  }\n  reset() {\n    this.resetLexerState();\n    this.subruleIdx = 0;\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = [];\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  }\n}\nclass ErrorHandler {\n  initErrorHandler(config) {\n    this._errors = [];\n    this.errorMessageProvider = has(config, \"errorMessageProvider\") ? config.errorMessageProvider : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  }\n  SAVE_ERROR(error) {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK)\n      };\n      this._errors.push(error);\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  }\n  get errors() {\n    return clone(this._errors);\n  }\n  set errors(newErrors) {\n    this._errors = newErrors;\n  }\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    const insideProdPaths = lookAheadPathsPerAlternative[0];\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName\n    });\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n  }\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(occurrence, errMsgTypes) {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const previousToken = this.LA(0);\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n  }\n}\nclass ContentAssist {\n  initContentAssist() {\n  }\n  computeContentAssist(startRuleName, precedingInput) {\n    const startRuleGast = this.gastProductionsCache[startRuleName];\n    if (isUndefined(startRuleGast)) {\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n    }\n    return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n  }\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n  getNextPossibleTokenTypes(grammarPath) {\n    const topRuleName = head(grammarPath.ruleStack);\n    const gastProductions = this.getGAstProductions();\n    const topProduction = gastProductions[topRuleName];\n    const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n    return nextPossibleTokenTypes;\n  }\n}\nconst RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nconst HANDLE_SEPARATOR = true;\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nconst RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1\n);\nObject.freeze(RECORDING_PHASE_TOKEN);\nconst RECORDING_PHASE_CSTNODE = {\n  name: \"This CSTNode indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n};\nclass GastRecorder {\n  initGastRecorder(config) {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  }\n  enableRecording() {\n    this.RECORDING_PHASE = true;\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        this[`CONSUME${idx}`] = function(arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n        this[`SUBRULE${idx}`] = function(arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2);\n        };\n        this[`OPTION${idx}`] = function(arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n        this[`OR${idx}`] = function(arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n        this[`MANY${idx}`] = function(arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n        this[`MANY_SEP${idx}`] = function(arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE${idx}`] = function(arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE_SEP${idx}`] = function(arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      }\n      this[`consume`] = function(idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n      this[`subrule`] = function(idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2);\n      };\n      this[`option`] = function(idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n      this[`or`] = function(idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n      this[`many`] = function(idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n      this[`atLeastOne`] = function(idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n      this.ACTION = this.ACTION_RECORD;\n      this.BACKTRACK = this.BACKTRACK_RECORD;\n      this.LA = this.LA_RECORD;\n    });\n  }\n  disableRecording() {\n    this.RECORDING_PHASE = false;\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      const that = this;\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        delete that[`CONSUME${idx}`];\n        delete that[`SUBRULE${idx}`];\n        delete that[`OPTION${idx}`];\n        delete that[`OR${idx}`];\n        delete that[`MANY${idx}`];\n        delete that[`MANY_SEP${idx}`];\n        delete that[`AT_LEAST_ONE${idx}`];\n        delete that[`AT_LEAST_ONE_SEP${idx}`];\n      }\n      delete that[`consume`];\n      delete that[`subrule`];\n      delete that[`option`];\n      delete that[`or`];\n      delete that[`many`];\n      delete that[`atLeastOne`];\n      delete that.ACTION;\n      delete that.BACKTRACK;\n      delete that.LA;\n    });\n  }\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  // @ts-expect-error -- noop place holder\n  ACTION_RECORD(impl) {\n  }\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD(grammarRule, args) {\n    return () => true;\n  }\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch) {\n    return END_OF_FILE;\n  }\n  topLevelRuleRecord(name, def) {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message = originalError.message + '\\n\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\thttps://chevrotain.io/docs/guide/internals.html#grammar-recording';\n        } catch (mutabilityError) {\n          throw originalError;\n        }\n      }\n      throw originalError;\n    }\n  }\n  // Implementation of parsing DSL\n  optionInternalRecord(actionORMethodDef, occurrence) {\n    return recordProd.call(this, Option$1, actionORMethodDef, occurrence);\n  }\n  atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n  }\n  atLeastOneSepFirstInternalRecord(occurrence, options) {\n    recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  }\n  manyInternalRecord(occurrence, actionORMethodDef) {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n  }\n  manySepFirstInternalRecord(occurrence, options) {\n    recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n  }\n  orInternalRecord(altsOrOpts, occurrence) {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  }\n  subruleInternalRecord(ruleToCall, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    const prevProd = last(this.recordingProdStack);\n    const ruleName = ruleToCall.ruleName;\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options === null || options === void 0 ? void 0 : options.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: void 0\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n  }\n  consumeInternalRecord(tokType, occurrence, options) {\n    assertMethodIdxIsValid(occurrence);\n    if (!hasShortKeyProperty(tokType)) {\n      const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(tokType)}>\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    const prevProd = last(this.recordingProdStack);\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options === null || options === void 0 ? void 0 : options.LABEL\n    });\n    prevProd.definition.push(newNoneTerminal);\n    return RECORDING_PHASE_TOKEN;\n  }\n}\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd = last(this.recordingProdStack);\n  const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n  const newProd = new prodConstructor({ definition: [], idx: occurrence });\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n  return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd = last(this.recordingProdStack);\n  const hasOptions = isArray(mainProdArg) === false;\n  const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  });\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n  const hasPredicates = some(alts, (currAlt) => isFunction(currAlt.GATE));\n  newOrProd.hasPredicates = hasPredicates;\n  prevProd.definition.push(newOrProd);\n  forEach(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] });\n    newOrProd.definition.push(currAltFlat);\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n    } else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n    this.recordingProdStack.push(currAltFlat);\n    currAlt.ALT.call(this);\n    this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n  return idx === 0 ? \"\" : `${idx}`;\n}\nfunction assertMethodIdxIsValid(idx) {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\n\tIdx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`\n    );\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}\nclass PerformanceTracer {\n  initPerformanceTracer(config) {\n    if (has(config, \"traceInitPerf\")) {\n      const userTraceInitPerf = config.traceInitPerf;\n      const traceIsNumber = typeof userTraceInitPerf === \"number\";\n      this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;\n      this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;\n    } else {\n      this.traceInitMaxIdent = 0;\n      this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n    }\n    this.traceInitIndent = -1;\n  }\n  TRACE_INIT(phaseDesc, phaseImpl) {\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      const indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n      }\n      const { time, value } = timer(phaseImpl);\n      const traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  }\n}\nfunction applyMixins(derivedCtor, baseCtors) {\n  baseCtors.forEach((baseCtor) => {\n    const baseProto = baseCtor.prototype;\n    Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n      if (propName === \"constructor\") {\n        return;\n      }\n      const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n      if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {\n        Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n      } else {\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n      }\n    });\n  });\n}\nconst END_OF_FILE = createTokenInstance(EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nconst DEFAULT_PARSER_CONFIG = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false\n});\nconst DEFAULT_RULE_CONFIG = Object.freeze({\n  recoveryValueFunc: () => void 0,\n  resyncEnabled: true\n});\nvar ParserDefinitionErrorType;\n(function(ParserDefinitionErrorType2) {\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n  ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nfunction EMPTY_ALT(value = void 0) {\n  return function() {\n    return value;\n  };\n}\nclass Parser {\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n  static performSelfAnalysis(parserInstance) {\n    throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\t\\nUse the **instance** method with the same name instead.\");\n  }\n  performSelfAnalysis() {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs;\n      this.selfAnalysisDone = true;\n      const className = this.className;\n      this.TRACE_INIT(\"toFastProps\", () => {\n        toFastProperties(this);\n      });\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording();\n          forEach(this.definedRulesNames, (currRuleName) => {\n            const wrappedRule = this[currRuleName];\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n            let recordedRuleGast;\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n            });\n            this.gastProductionsCache[currRuleName] = recordedRuleGast;\n          });\n        } finally {\n          this.disableRecording();\n        }\n      });\n      let resolverErrors = [];\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = resolveGrammar({\n          rules: values(this.gastProductionsCache)\n        });\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n      });\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        if (isEmpty(resolverErrors) && this.skipValidations === false) {\n          const validationErrors = validateGrammar({\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\n            grammarName: className\n          });\n          const lookaheadValidationErrors = validateLookahead({\n            lookaheadStrategy: this.lookaheadStrategy,\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            grammarName: className\n          });\n          this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n        }\n      });\n      if (isEmpty(this.definitionErrors)) {\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            const allFollows = computeAllProdsFollows(values(this.gastProductionsCache));\n            this.resyncFollows = allFollows;\n          });\n        }\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          var _a2, _b2;\n          (_b2 = (_a2 = this.lookaheadStrategy).initialize) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, {\n            rules: values(this.gastProductionsCache)\n          });\n          this.preComputeLookaheadFunctions(values(this.gastProductionsCache));\n        });\n      }\n      if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty(this.definitionErrors)) {\n        defErrorsMsgs = map(this.definitionErrors, (defError) => defError.message);\n        throw new Error(`Parser Definition Errors detected:\n ${defErrorsMsgs.join(\"\\n-------------------------------\\n\")}`);\n      }\n    });\n  }\n  constructor(tokenVocabulary, config) {\n    this.definitionErrors = [];\n    this.selfAnalysisDone = false;\n    const that = this;\n    that.initErrorHandler(config);\n    that.initLexerAdapter();\n    that.initLooksAhead(config);\n    that.initRecognizerEngine(tokenVocabulary, config);\n    that.initRecoverable(config);\n    that.initTreeBuilder(config);\n    that.initContentAssist();\n    that.initGastRecorder(config);\n    that.initPerformanceTracer(config);\n    if (has(config, \"ignoredIssues\")) {\n      throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\tPlease use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\tSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\tFor further details.\");\n    }\n    this.skipValidations = has(config, \"skipValidations\") ? config.skipValidations : DEFAULT_PARSER_CONFIG.skipValidations;\n  }\n}\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\napplyMixins(Parser, [\n  Recoverable,\n  LooksAhead,\n  TreeBuilder,\n  LexerAdapter,\n  RecognizerEngine,\n  RecognizerApi,\n  ErrorHandler,\n  ContentAssist,\n  GastRecorder,\n  PerformanceTracer\n]);\nclass EmbeddedActionsParser extends Parser {\n  constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n    const configClone = clone(config);\n    configClone.outputCst = false;\n    super(tokenVocabulary, configClone);\n  }\n}\nfunction buildATNKey(rule, type, occurrence) {\n  return `${rule.name}_${type}_${occurrence}`;\n}\nconst ATN_BASIC = 1;\nconst ATN_RULE_START = 2;\nconst ATN_PLUS_BLOCK_START = 4;\nconst ATN_STAR_BLOCK_START = 5;\nconst ATN_RULE_STOP = 7;\nconst ATN_BLOCK_END = 8;\nconst ATN_STAR_LOOP_BACK = 9;\nconst ATN_STAR_LOOP_ENTRY = 10;\nconst ATN_PLUS_LOOP_BACK = 11;\nconst ATN_LOOP_END = 12;\nclass AbstractTransition {\n  constructor(target) {\n    this.target = target;\n  }\n  isEpsilon() {\n    return false;\n  }\n}\nclass AtomTransition extends AbstractTransition {\n  constructor(target, tokenType) {\n    super(target);\n    this.tokenType = tokenType;\n  }\n}\nclass EpsilonTransition extends AbstractTransition {\n  constructor(target) {\n    super(target);\n  }\n  isEpsilon() {\n    return true;\n  }\n}\nclass RuleTransition extends AbstractTransition {\n  constructor(ruleStart, rule, followState) {\n    super(ruleStart);\n    this.rule = rule;\n    this.followState = followState;\n  }\n  isEpsilon() {\n    return true;\n  }\n}\nfunction createATN(rules) {\n  const atn = {\n    decisionMap: {},\n    decisionStates: [],\n    ruleToStartState: /* @__PURE__ */ new Map(),\n    ruleToStopState: /* @__PURE__ */ new Map(),\n    states: []\n  };\n  createRuleStartAndStopATNStates(atn, rules);\n  const ruleLength = rules.length;\n  for (let i = 0; i < ruleLength; i++) {\n    const rule = rules[i];\n    const ruleBlock = block(atn, rule, rule);\n    if (ruleBlock === void 0) {\n      continue;\n    }\n    buildRuleHandle(atn, rule, ruleBlock);\n  }\n  return atn;\n}\nfunction createRuleStartAndStopATNStates(atn, rules) {\n  const ruleLength = rules.length;\n  for (let i = 0; i < ruleLength; i++) {\n    const rule = rules[i];\n    const start = newState(atn, rule, void 0, {\n      type: ATN_RULE_START\n    });\n    const stop = newState(atn, rule, void 0, {\n      type: ATN_RULE_STOP\n    });\n    start.stop = stop;\n    atn.ruleToStartState.set(rule, start);\n    atn.ruleToStopState.set(rule, stop);\n  }\n}\nfunction atom(atn, rule, production) {\n  if (production instanceof Terminal) {\n    return tokenRef(atn, rule, production.terminalType, production);\n  } else if (production instanceof NonTerminal) {\n    return ruleRef(atn, rule, production);\n  } else if (production instanceof Alternation) {\n    return alternation(atn, rule, production);\n  } else if (production instanceof Option$1) {\n    return option(atn, rule, production);\n  } else if (production instanceof Repetition) {\n    return repetition(atn, rule, production);\n  } else if (production instanceof RepetitionWithSeparator) {\n    return repetitionSep(atn, rule, production);\n  } else if (production instanceof RepetitionMandatory) {\n    return repetitionMandatory(atn, rule, production);\n  } else if (production instanceof RepetitionMandatoryWithSeparator) {\n    return repetitionMandatorySep(atn, rule, production);\n  } else {\n    return block(atn, rule, production);\n  }\n}\nfunction repetition(atn, rule, repetition2) {\n  const starState = newState(atn, rule, repetition2, {\n    type: ATN_STAR_BLOCK_START\n  });\n  defineDecisionState(atn, starState);\n  const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));\n  return star(atn, rule, repetition2, handle);\n}\nfunction repetitionSep(atn, rule, repetition2) {\n  const starState = newState(atn, rule, repetition2, {\n    type: ATN_STAR_BLOCK_START\n  });\n  defineDecisionState(atn, starState);\n  const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));\n  const sep = tokenRef(atn, rule, repetition2.separator, repetition2);\n  return star(atn, rule, repetition2, handle, sep);\n}\nfunction repetitionMandatory(atn, rule, repetition2) {\n  const plusState = newState(atn, rule, repetition2, {\n    type: ATN_PLUS_BLOCK_START\n  });\n  defineDecisionState(atn, plusState);\n  const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));\n  return plus(atn, rule, repetition2, handle);\n}\nfunction repetitionMandatorySep(atn, rule, repetition2) {\n  const plusState = newState(atn, rule, repetition2, {\n    type: ATN_PLUS_BLOCK_START\n  });\n  defineDecisionState(atn, plusState);\n  const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));\n  const sep = tokenRef(atn, rule, repetition2.separator, repetition2);\n  return plus(atn, rule, repetition2, handle, sep);\n}\nfunction alternation(atn, rule, alternation2) {\n  const start = newState(atn, rule, alternation2, {\n    type: ATN_BASIC\n  });\n  defineDecisionState(atn, start);\n  const alts = map(alternation2.definition, (e) => atom(atn, rule, e));\n  const handle = makeAlts(atn, rule, start, alternation2, ...alts);\n  return handle;\n}\nfunction option(atn, rule, option2) {\n  const start = newState(atn, rule, option2, {\n    type: ATN_BASIC\n  });\n  defineDecisionState(atn, start);\n  const handle = makeAlts(atn, rule, start, option2, block(atn, rule, option2));\n  return optional(atn, rule, option2, handle);\n}\nfunction block(atn, rule, block2) {\n  const handles = filter(map(block2.definition, (e) => atom(atn, rule, e)), (e) => e !== void 0);\n  if (handles.length === 1) {\n    return handles[0];\n  } else if (handles.length === 0) {\n    return void 0;\n  } else {\n    return makeBlock(atn, handles);\n  }\n}\nfunction plus(atn, rule, plus2, handle, sep) {\n  const blkStart = handle.left;\n  const blkEnd = handle.right;\n  const loop = newState(atn, rule, plus2, {\n    type: ATN_PLUS_LOOP_BACK\n  });\n  defineDecisionState(atn, loop);\n  const end = newState(atn, rule, plus2, {\n    type: ATN_LOOP_END\n  });\n  blkStart.loopback = loop;\n  end.loopback = loop;\n  atn.decisionMap[buildATNKey(rule, sep ? \"RepetitionMandatoryWithSeparator\" : \"RepetitionMandatory\", plus2.idx)] = loop;\n  epsilon(blkEnd, loop);\n  if (sep === void 0) {\n    epsilon(loop, blkStart);\n    epsilon(loop, end);\n  } else {\n    epsilon(loop, end);\n    epsilon(loop, sep.left);\n    epsilon(sep.right, blkStart);\n  }\n  return {\n    left: blkStart,\n    right: end\n  };\n}\nfunction star(atn, rule, star2, handle, sep) {\n  const start = handle.left;\n  const end = handle.right;\n  const entry = newState(atn, rule, star2, {\n    type: ATN_STAR_LOOP_ENTRY\n  });\n  defineDecisionState(atn, entry);\n  const loopEnd = newState(atn, rule, star2, {\n    type: ATN_LOOP_END\n  });\n  const loop = newState(atn, rule, star2, {\n    type: ATN_STAR_LOOP_BACK\n  });\n  entry.loopback = loop;\n  loopEnd.loopback = loop;\n  epsilon(entry, start);\n  epsilon(entry, loopEnd);\n  epsilon(end, loop);\n  if (sep !== void 0) {\n    epsilon(loop, loopEnd);\n    epsilon(loop, sep.left);\n    epsilon(sep.right, start);\n  } else {\n    epsilon(loop, entry);\n  }\n  atn.decisionMap[buildATNKey(rule, sep ? \"RepetitionWithSeparator\" : \"Repetition\", star2.idx)] = entry;\n  return {\n    left: entry,\n    right: loopEnd\n  };\n}\nfunction optional(atn, rule, optional2, handle) {\n  const start = handle.left;\n  const end = handle.right;\n  epsilon(start, end);\n  atn.decisionMap[buildATNKey(rule, \"Option\", optional2.idx)] = start;\n  return handle;\n}\nfunction defineDecisionState(atn, state) {\n  atn.decisionStates.push(state);\n  state.decision = atn.decisionStates.length - 1;\n  return state.decision;\n}\nfunction makeAlts(atn, rule, start, production, ...alts) {\n  const end = newState(atn, rule, production, {\n    type: ATN_BLOCK_END,\n    start\n  });\n  start.end = end;\n  for (const alt of alts) {\n    if (alt !== void 0) {\n      epsilon(start, alt.left);\n      epsilon(alt.right, end);\n    } else {\n      epsilon(start, end);\n    }\n  }\n  const handle = {\n    left: start,\n    right: end\n  };\n  atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;\n  return handle;\n}\nfunction getProdType(production) {\n  if (production instanceof Alternation) {\n    return \"Alternation\";\n  } else if (production instanceof Option$1) {\n    return \"Option\";\n  } else if (production instanceof Repetition) {\n    return \"Repetition\";\n  } else if (production instanceof RepetitionWithSeparator) {\n    return \"RepetitionWithSeparator\";\n  } else if (production instanceof RepetitionMandatory) {\n    return \"RepetitionMandatory\";\n  } else if (production instanceof RepetitionMandatoryWithSeparator) {\n    return \"RepetitionMandatoryWithSeparator\";\n  } else {\n    throw new Error(\"Invalid production type encountered\");\n  }\n}\nfunction makeBlock(atn, alts) {\n  const altsLength = alts.length;\n  for (let i = 0; i < altsLength - 1; i++) {\n    const handle = alts[i];\n    let transition;\n    if (handle.left.transitions.length === 1) {\n      transition = handle.left.transitions[0];\n    }\n    const isRuleTransition = transition instanceof RuleTransition;\n    const ruleTransition = transition;\n    const next = alts[i + 1].left;\n    if (handle.left.type === ATN_BASIC && handle.right.type === ATN_BASIC && transition !== void 0 && (isRuleTransition && ruleTransition.followState === handle.right || transition.target === handle.right)) {\n      if (isRuleTransition) {\n        ruleTransition.followState = next;\n      } else {\n        transition.target = next;\n      }\n      removeState(atn, handle.right);\n    } else {\n      epsilon(handle.right, next);\n    }\n  }\n  const first2 = alts[0];\n  const last2 = alts[altsLength - 1];\n  return {\n    left: first2.left,\n    right: last2.right\n  };\n}\nfunction tokenRef(atn, rule, tokenType, production) {\n  const left = newState(atn, rule, production, {\n    type: ATN_BASIC\n  });\n  const right = newState(atn, rule, production, {\n    type: ATN_BASIC\n  });\n  addTransition(left, new AtomTransition(right, tokenType));\n  return {\n    left,\n    right\n  };\n}\nfunction ruleRef(atn, currentRule, nonTerminal) {\n  const rule = nonTerminal.referencedRule;\n  const start = atn.ruleToStartState.get(rule);\n  const left = newState(atn, currentRule, nonTerminal, {\n    type: ATN_BASIC\n  });\n  const right = newState(atn, currentRule, nonTerminal, {\n    type: ATN_BASIC\n  });\n  const call = new RuleTransition(start, rule, right);\n  addTransition(left, call);\n  return {\n    left,\n    right\n  };\n}\nfunction buildRuleHandle(atn, rule, block2) {\n  const start = atn.ruleToStartState.get(rule);\n  epsilon(start, block2.left);\n  const stop = atn.ruleToStopState.get(rule);\n  epsilon(block2.right, stop);\n  const handle = {\n    left: start,\n    right: stop\n  };\n  return handle;\n}\nfunction epsilon(a, b) {\n  const transition = new EpsilonTransition(b);\n  addTransition(a, transition);\n}\nfunction newState(atn, rule, production, partial) {\n  const t = Object.assign({\n    atn,\n    production,\n    epsilonOnlyTransitions: false,\n    rule,\n    transitions: [],\n    nextTokenWithinRule: [],\n    stateNumber: atn.states.length\n  }, partial);\n  atn.states.push(t);\n  return t;\n}\nfunction addTransition(state, transition) {\n  if (state.transitions.length === 0) {\n    state.epsilonOnlyTransitions = transition.isEpsilon();\n  }\n  state.transitions.push(transition);\n}\nfunction removeState(atn, state) {\n  atn.states.splice(atn.states.indexOf(state), 1);\n}\nconst DFA_ERROR = {};\nclass ATNConfigSet {\n  constructor() {\n    this.map = {};\n    this.configs = [];\n  }\n  get size() {\n    return this.configs.length;\n  }\n  finalize() {\n    this.map = {};\n  }\n  add(config) {\n    const key = getATNConfigKey(config);\n    if (!(key in this.map)) {\n      this.map[key] = this.configs.length;\n      this.configs.push(config);\n    }\n  }\n  get elements() {\n    return this.configs;\n  }\n  get alts() {\n    return map(this.configs, (e) => e.alt);\n  }\n  get key() {\n    let value = \"\";\n    for (const k in this.map) {\n      value += k + \":\";\n    }\n    return value;\n  }\n}\nfunction getATNConfigKey(config, alt = true) {\n  return `${alt ? `a${config.alt}` : \"\"}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join(\"_\")}`;\n}\nfunction createDFACache(startState, decision) {\n  const map2 = {};\n  return (predicateSet) => {\n    const key = predicateSet.toString();\n    let existing = map2[key];\n    if (existing !== void 0) {\n      return existing;\n    } else {\n      existing = {\n        atnStartState: startState,\n        decision,\n        states: {}\n      };\n      map2[key] = existing;\n      return existing;\n    }\n  };\n}\nclass PredicateSet {\n  constructor() {\n    this.predicates = [];\n  }\n  is(index) {\n    return index >= this.predicates.length || this.predicates[index];\n  }\n  set(index, value) {\n    this.predicates[index] = value;\n  }\n  toString() {\n    let value = \"\";\n    const size = this.predicates.length;\n    for (let i = 0; i < size; i++) {\n      value += this.predicates[i] === true ? \"1\" : \"0\";\n    }\n    return value;\n  }\n}\nconst EMPTY_PREDICATES = new PredicateSet();\nclass LLStarLookaheadStrategy extends LLkLookaheadStrategy {\n  constructor(options) {\n    var _a2;\n    super();\n    this.logging = (_a2 = options === null || options === void 0 ? void 0 : options.logging) !== null && _a2 !== void 0 ? _a2 : (message) => void 0;\n  }\n  initialize(options) {\n    this.atn = createATN(options.rules);\n    this.dfas = initATNSimulator(this.atn);\n  }\n  validateAmbiguousAlternationAlternatives() {\n    return [];\n  }\n  validateEmptyOrAlternatives() {\n    return [];\n  }\n  buildLookaheadForAlternation(options) {\n    const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;\n    const dfas = this.dfas;\n    const logging = this.logging;\n    const key = buildATNKey(rule, \"Alternation\", prodOccurrence);\n    const decisionState = this.atn.decisionMap[key];\n    const decisionIndex = decisionState.decision;\n    const partialAlts = map(getLookaheadPaths({\n      maxLookahead: 1,\n      occurrence: prodOccurrence,\n      prodType: \"Alternation\",\n      rule\n    }), (currAlt) => map(currAlt, (path) => path[0]));\n    if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {\n      const choiceToAlt = reduce(partialAlts, (result, currAlt, idx) => {\n        forEach(currAlt, (currTokType) => {\n          if (currTokType) {\n            result[currTokType.tokenTypeIdx] = idx;\n            forEach(currTokType.categoryMatches, (currExtendingType) => {\n              result[currExtendingType] = idx;\n            });\n          }\n        });\n        return result;\n      }, {});\n      if (hasPredicates) {\n        return function(orAlts) {\n          var _a2;\n          const nextToken = this.LA(1);\n          const prediction = choiceToAlt[nextToken.tokenTypeIdx];\n          if (orAlts !== void 0 && prediction !== void 0) {\n            const gate = (_a2 = orAlts[prediction]) === null || _a2 === void 0 ? void 0 : _a2.GATE;\n            if (gate !== void 0 && gate.call(this) === false) {\n              return void 0;\n            }\n          }\n          return prediction;\n        };\n      } else {\n        return function() {\n          const nextToken = this.LA(1);\n          return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n      }\n    } else if (hasPredicates) {\n      return function(orAlts) {\n        const predicates = new PredicateSet();\n        const length = orAlts === void 0 ? 0 : orAlts.length;\n        for (let i = 0; i < length; i++) {\n          const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;\n          predicates.set(i, gate === void 0 || gate.call(this));\n        }\n        const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);\n        return typeof result === \"number\" ? result : void 0;\n      };\n    } else {\n      return function() {\n        const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n        return typeof result === \"number\" ? result : void 0;\n      };\n    }\n  }\n  buildLookaheadForOptional(options) {\n    const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;\n    const dfas = this.dfas;\n    const logging = this.logging;\n    const key = buildATNKey(rule, prodType, prodOccurrence);\n    const decisionState = this.atn.decisionMap[key];\n    const decisionIndex = decisionState.decision;\n    const alts = map(getLookaheadPaths({\n      maxLookahead: 1,\n      occurrence: prodOccurrence,\n      prodType,\n      rule\n    }), (e) => {\n      return map(e, (g) => g[0]);\n    });\n    if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {\n      const alt = alts[0];\n      const singleTokensTypes = flatten(alt);\n      if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n        const expectedTokenType = singleTokensTypes[0];\n        const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n        return function() {\n          return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n        };\n      } else {\n        const choiceToAlt = reduce(singleTokensTypes, (result, currTokType) => {\n          if (currTokType !== void 0) {\n            result[currTokType.tokenTypeIdx] = true;\n            forEach(currTokType.categoryMatches, (currExtendingType) => {\n              result[currExtendingType] = true;\n            });\n          }\n          return result;\n        }, {});\n        return function() {\n          const nextToken = this.LA(1);\n          return choiceToAlt[nextToken.tokenTypeIdx] === true;\n        };\n      }\n    }\n    return function() {\n      const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n      return typeof result === \"object\" ? false : result === 0;\n    };\n  }\n}\nfunction isLL1Sequence(sequences, allowEmpty = true) {\n  const fullSet = /* @__PURE__ */ new Set();\n  for (const alt of sequences) {\n    const altSet = /* @__PURE__ */ new Set();\n    for (const tokType of alt) {\n      if (tokType === void 0) {\n        if (allowEmpty) {\n          break;\n        } else {\n          return false;\n        }\n      }\n      const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);\n      for (const index of indices) {\n        if (fullSet.has(index)) {\n          if (!altSet.has(index)) {\n            return false;\n          }\n        } else {\n          fullSet.add(index);\n          altSet.add(index);\n        }\n      }\n    }\n  }\n  return true;\n}\nfunction initATNSimulator(atn) {\n  const decisionLength = atn.decisionStates.length;\n  const decisionToDFA = Array(decisionLength);\n  for (let i = 0; i < decisionLength; i++) {\n    decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);\n  }\n  return decisionToDFA;\n}\nfunction adaptivePredict(dfaCaches, decision, predicateSet, logging) {\n  const dfa = dfaCaches[decision](predicateSet);\n  let start = dfa.start;\n  if (start === void 0) {\n    const closure2 = computeStartState(dfa.atnStartState);\n    start = addDFAState(dfa, newDFAState(closure2));\n    dfa.start = start;\n  }\n  const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);\n  return alt;\n}\nfunction performLookahead(dfa, s0, predicateSet, logging) {\n  let previousD = s0;\n  let i = 1;\n  const path = [];\n  let t = this.LA(i++);\n  while (true) {\n    let d = getExistingTargetState(previousD, t);\n    if (d === void 0) {\n      d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);\n    }\n    if (d === DFA_ERROR) {\n      return buildAdaptivePredictError(path, previousD, t);\n    }\n    if (d.isAcceptState === true) {\n      return d.prediction;\n    }\n    previousD = d;\n    path.push(t);\n    t = this.LA(i++);\n  }\n}\nfunction computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {\n  const reach = computeReachSet(previousD.configs, token, predicateSet);\n  if (reach.size === 0) {\n    addDFAEdge(dfa, previousD, token, DFA_ERROR);\n    return DFA_ERROR;\n  }\n  let newState2 = newDFAState(reach);\n  const predictedAlt = getUniqueAlt(reach, predicateSet);\n  if (predictedAlt !== void 0) {\n    newState2.isAcceptState = true;\n    newState2.prediction = predictedAlt;\n    newState2.configs.uniqueAlt = predictedAlt;\n  } else if (hasConflictTerminatingPrediction(reach)) {\n    const prediction = min(reach.alts);\n    newState2.isAcceptState = true;\n    newState2.prediction = prediction;\n    newState2.configs.uniqueAlt = prediction;\n    reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);\n  }\n  newState2 = addDFAEdge(dfa, previousD, token, newState2);\n  return newState2;\n}\nfunction reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {\n  const prefixPath = [];\n  for (let i = 1; i <= lookahead; i++) {\n    prefixPath.push(this.LA(i).tokenType);\n  }\n  const atnState = dfa.atnStartState;\n  const topLevelRule = atnState.rule;\n  const production = atnState.production;\n  const message = buildAmbiguityError({\n    topLevelRule,\n    ambiguityIndices,\n    production,\n    prefixPath\n  });\n  logging(message);\n}\nfunction buildAmbiguityError(options) {\n  const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(\", \");\n  const occurrence = options.production.idx === 0 ? \"\" : options.production.idx;\n  let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\", \")}> in <${getProductionDslName(options.production)}${occurrence}> inside <${options.topLevelRule.name}> Rule,\n<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;\n  currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.`;\n  return currMessage;\n}\nfunction getProductionDslName(prod) {\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\";\n  } else if (prod instanceof Option$1) {\n    return \"OPTION\";\n  } else if (prod instanceof Alternation) {\n    return \"OR\";\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\";\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\";\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\";\n  } else if (prod instanceof Repetition) {\n    return \"MANY\";\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\";\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nfunction buildAdaptivePredictError(path, previous, current) {\n  const nextTransitions = flatMap(previous.configs.elements, (e) => e.state.transitions);\n  const nextTokenTypes = uniqBy(nextTransitions.filter((e) => e instanceof AtomTransition).map((e) => e.tokenType), (e) => e.tokenTypeIdx);\n  return {\n    actualToken: current,\n    possibleTokenTypes: nextTokenTypes,\n    tokenPath: path\n  };\n}\nfunction getExistingTargetState(state, token) {\n  return state.edges[token.tokenTypeIdx];\n}\nfunction computeReachSet(configs, token, predicateSet) {\n  const intermediate = new ATNConfigSet();\n  const skippedStopStates = [];\n  for (const c of configs.elements) {\n    if (predicateSet.is(c.alt) === false) {\n      continue;\n    }\n    if (c.state.type === ATN_RULE_STOP) {\n      skippedStopStates.push(c);\n      continue;\n    }\n    const transitionLength = c.state.transitions.length;\n    for (let i = 0; i < transitionLength; i++) {\n      const transition = c.state.transitions[i];\n      const target = getReachableTarget(transition, token);\n      if (target !== void 0) {\n        intermediate.add({\n          state: target,\n          alt: c.alt,\n          stack: c.stack\n        });\n      }\n    }\n  }\n  let reach;\n  if (skippedStopStates.length === 0 && intermediate.size === 1) {\n    reach = intermediate;\n  }\n  if (reach === void 0) {\n    reach = new ATNConfigSet();\n    for (const c of intermediate.elements) {\n      closure(c, reach);\n    }\n  }\n  if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {\n    for (const c of skippedStopStates) {\n      reach.add(c);\n    }\n  }\n  return reach;\n}\nfunction getReachableTarget(transition, token) {\n  if (transition instanceof AtomTransition && tokenMatcher(token, transition.tokenType)) {\n    return transition.target;\n  }\n  return void 0;\n}\nfunction getUniqueAlt(configs, predicateSet) {\n  let alt;\n  for (const c of configs.elements) {\n    if (predicateSet.is(c.alt) === true) {\n      if (alt === void 0) {\n        alt = c.alt;\n      } else if (alt !== c.alt) {\n        return void 0;\n      }\n    }\n  }\n  return alt;\n}\nfunction newDFAState(closure2) {\n  return {\n    configs: closure2,\n    edges: {},\n    isAcceptState: false,\n    prediction: -1\n  };\n}\nfunction addDFAEdge(dfa, from, token, to) {\n  to = addDFAState(dfa, to);\n  from.edges[token.tokenTypeIdx] = to;\n  return to;\n}\nfunction addDFAState(dfa, state) {\n  if (state === DFA_ERROR) {\n    return state;\n  }\n  const mapKey = state.configs.key;\n  const existing = dfa.states[mapKey];\n  if (existing !== void 0) {\n    return existing;\n  }\n  state.configs.finalize();\n  dfa.states[mapKey] = state;\n  return state;\n}\nfunction computeStartState(atnState) {\n  const configs = new ATNConfigSet();\n  const numberOfTransitions = atnState.transitions.length;\n  for (let i = 0; i < numberOfTransitions; i++) {\n    const target = atnState.transitions[i].target;\n    const config = {\n      state: target,\n      alt: i,\n      stack: []\n    };\n    closure(config, configs);\n  }\n  return configs;\n}\nfunction closure(config, configs) {\n  const p = config.state;\n  if (p.type === ATN_RULE_STOP) {\n    if (config.stack.length > 0) {\n      const atnStack = [...config.stack];\n      const followState = atnStack.pop();\n      const followConfig = {\n        state: followState,\n        alt: config.alt,\n        stack: atnStack\n      };\n      closure(followConfig, configs);\n    } else {\n      configs.add(config);\n    }\n    return;\n  }\n  if (!p.epsilonOnlyTransitions) {\n    configs.add(config);\n  }\n  const transitionLength = p.transitions.length;\n  for (let i = 0; i < transitionLength; i++) {\n    const transition = p.transitions[i];\n    const c = getEpsilonTarget(config, transition);\n    if (c !== void 0) {\n      closure(c, configs);\n    }\n  }\n}\nfunction getEpsilonTarget(config, transition) {\n  if (transition instanceof EpsilonTransition) {\n    return {\n      state: transition.target,\n      alt: config.alt,\n      stack: config.stack\n    };\n  } else if (transition instanceof RuleTransition) {\n    const stack = [...config.stack, transition.followState];\n    return {\n      state: transition.target,\n      alt: config.alt,\n      stack\n    };\n  }\n  return void 0;\n}\nfunction hasConfigInRuleStopState(configs) {\n  for (const c of configs.elements) {\n    if (c.state.type === ATN_RULE_STOP) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction allConfigsInRuleStopStates(configs) {\n  for (const c of configs.elements) {\n    if (c.state.type !== ATN_RULE_STOP) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction hasConflictTerminatingPrediction(configs) {\n  if (allConfigsInRuleStopStates(configs)) {\n    return true;\n  }\n  const altSets = getConflictingAltSets(configs.elements);\n  const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);\n  return heuristic;\n}\nfunction getConflictingAltSets(configs) {\n  const configToAlts = /* @__PURE__ */ new Map();\n  for (const c of configs) {\n    const key = getATNConfigKey(c, false);\n    let alts = configToAlts.get(key);\n    if (alts === void 0) {\n      alts = {};\n      configToAlts.set(key, alts);\n    }\n    alts[c.alt] = true;\n  }\n  return configToAlts;\n}\nfunction hasConflictingAltSet(altSets) {\n  for (const value of Array.from(altSets.values())) {\n    if (Object.keys(value).length > 1) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction hasStateAssociatedWithOneAlt(altSets) {\n  for (const value of Array.from(altSets.values())) {\n    if (Object.keys(value).length === 1) {\n      return true;\n    }\n  }\n  return false;\n}\nvar DocumentUri;\n(function(DocumentUri2) {\n  function is2(value) {\n    return typeof value === \"string\";\n  }\n  DocumentUri2.is = is2;\n})(DocumentUri || (DocumentUri = {}));\nvar URI$1;\n(function(URI2) {\n  function is2(value) {\n    return typeof value === \"string\";\n  }\n  URI2.is = is2;\n})(URI$1 || (URI$1 = {}));\nvar integer;\n(function(integer2) {\n  integer2.MIN_VALUE = -2147483648;\n  integer2.MAX_VALUE = 2147483647;\n  function is2(value) {\n    return typeof value === \"number\" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;\n  }\n  integer2.is = is2;\n})(integer || (integer = {}));\nvar uinteger;\n(function(uinteger2) {\n  uinteger2.MIN_VALUE = 0;\n  uinteger2.MAX_VALUE = 2147483647;\n  function is2(value) {\n    return typeof value === \"number\" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;\n  }\n  uinteger2.is = is2;\n})(uinteger || (uinteger = {}));\nvar Position;\n(function(Position2) {\n  function create(line, character) {\n    if (line === Number.MAX_VALUE) {\n      line = uinteger.MAX_VALUE;\n    }\n    if (character === Number.MAX_VALUE) {\n      character = uinteger.MAX_VALUE;\n    }\n    return { line, character };\n  }\n  Position2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n  }\n  Position2.is = is2;\n})(Position || (Position = {}));\nvar Range;\n(function(Range2) {\n  function create(one, two, three, four) {\n    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n      return { start: Position.create(one, two), end: Position.create(three, four) };\n    } else if (Position.is(one) && Position.is(two)) {\n      return { start: one, end: two };\n    } else {\n      throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\n    }\n  }\n  Range2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n  }\n  Range2.is = is2;\n})(Range || (Range = {}));\nvar Location;\n(function(Location2) {\n  function create(uri, range) {\n    return { uri, range };\n  }\n  Location2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n  }\n  Location2.is = is2;\n})(Location || (Location = {}));\nvar LocationLink;\n(function(LocationLink2) {\n  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\n  }\n  LocationLink2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n  }\n  LocationLink2.is = is2;\n})(LocationLink || (LocationLink = {}));\nvar Color;\n(function(Color2) {\n  function create(red, green, blue, alpha) {\n    return {\n      red,\n      green,\n      blue,\n      alpha\n    };\n  }\n  Color2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);\n  }\n  Color2.is = is2;\n})(Color || (Color = {}));\nvar ColorInformation;\n(function(ColorInformation2) {\n  function create(range, color) {\n    return {\n      range,\n      color\n    };\n  }\n  ColorInformation2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n  }\n  ColorInformation2.is = is2;\n})(ColorInformation || (ColorInformation = {}));\nvar ColorPresentation;\n(function(ColorPresentation2) {\n  function create(label, textEdit, additionalTextEdits) {\n    return {\n      label,\n      textEdit,\n      additionalTextEdits\n    };\n  }\n  ColorPresentation2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n  }\n  ColorPresentation2.is = is2;\n})(ColorPresentation || (ColorPresentation = {}));\nvar FoldingRangeKind;\n(function(FoldingRangeKind2) {\n  FoldingRangeKind2.Comment = \"comment\";\n  FoldingRangeKind2.Imports = \"imports\";\n  FoldingRangeKind2.Region = \"region\";\n})(FoldingRangeKind || (FoldingRangeKind = {}));\nvar FoldingRange;\n(function(FoldingRange2) {\n  function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n    const result = {\n      startLine,\n      endLine\n    };\n    if (Is.defined(startCharacter)) {\n      result.startCharacter = startCharacter;\n    }\n    if (Is.defined(endCharacter)) {\n      result.endCharacter = endCharacter;\n    }\n    if (Is.defined(kind)) {\n      result.kind = kind;\n    }\n    if (Is.defined(collapsedText)) {\n      result.collapsedText = collapsedText;\n    }\n    return result;\n  }\n  FoldingRange2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n  }\n  FoldingRange2.is = is2;\n})(FoldingRange || (FoldingRange = {}));\nvar DiagnosticRelatedInformation;\n(function(DiagnosticRelatedInformation2) {\n  function create(location, message) {\n    return {\n      location,\n      message\n    };\n  }\n  DiagnosticRelatedInformation2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n  }\n  DiagnosticRelatedInformation2.is = is2;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\nvar DiagnosticSeverity;\n(function(DiagnosticSeverity2) {\n  DiagnosticSeverity2.Error = 1;\n  DiagnosticSeverity2.Warning = 2;\n  DiagnosticSeverity2.Information = 3;\n  DiagnosticSeverity2.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\nvar DiagnosticTag;\n(function(DiagnosticTag2) {\n  DiagnosticTag2.Unnecessary = 1;\n  DiagnosticTag2.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\nvar CodeDescription;\n(function(CodeDescription2) {\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.href);\n  }\n  CodeDescription2.is = is2;\n})(CodeDescription || (CodeDescription = {}));\nvar Diagnostic;\n(function(Diagnostic2) {\n  function create(range, message, severity, code, source, relatedInformation) {\n    let result = { range, message };\n    if (Is.defined(severity)) {\n      result.severity = severity;\n    }\n    if (Is.defined(code)) {\n      result.code = code;\n    }\n    if (Is.defined(source)) {\n      result.source = source;\n    }\n    if (Is.defined(relatedInformation)) {\n      result.relatedInformation = relatedInformation;\n    }\n    return result;\n  }\n  Diagnostic2.create = create;\n  function is2(value) {\n    var _a2;\n    let candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n  }\n  Diagnostic2.is = is2;\n})(Diagnostic || (Diagnostic = {}));\nvar Command;\n(function(Command2) {\n  function create(title, command, ...args) {\n    let result = { title, command };\n    if (Is.defined(args) && args.length > 0) {\n      result.arguments = args;\n    }\n    return result;\n  }\n  Command2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n  }\n  Command2.is = is2;\n})(Command || (Command = {}));\nvar TextEdit;\n(function(TextEdit2) {\n  function replace(range, newText) {\n    return { range, newText };\n  }\n  TextEdit2.replace = replace;\n  function insert(position, newText) {\n    return { range: { start: position, end: position }, newText };\n  }\n  TextEdit2.insert = insert;\n  function del(range) {\n    return { range, newText: \"\" };\n  }\n  TextEdit2.del = del;\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);\n  }\n  TextEdit2.is = is2;\n})(TextEdit || (TextEdit = {}));\nvar ChangeAnnotation;\n(function(ChangeAnnotation2) {\n  function create(label, needsConfirmation, description) {\n    const result = { label };\n    if (needsConfirmation !== void 0) {\n      result.needsConfirmation = needsConfirmation;\n    }\n    if (description !== void 0) {\n      result.description = description;\n    }\n    return result;\n  }\n  ChangeAnnotation2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);\n  }\n  ChangeAnnotation2.is = is2;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nvar ChangeAnnotationIdentifier;\n(function(ChangeAnnotationIdentifier2) {\n  function is2(value) {\n    const candidate = value;\n    return Is.string(candidate);\n  }\n  ChangeAnnotationIdentifier2.is = is2;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nvar AnnotatedTextEdit;\n(function(AnnotatedTextEdit2) {\n  function replace(range, newText, annotation) {\n    return { range, newText, annotationId: annotation };\n  }\n  AnnotatedTextEdit2.replace = replace;\n  function insert(position, newText, annotation) {\n    return { range: { start: position, end: position }, newText, annotationId: annotation };\n  }\n  AnnotatedTextEdit2.insert = insert;\n  function del(range, annotation) {\n    return { range, newText: \"\", annotationId: annotation };\n  }\n  AnnotatedTextEdit2.del = del;\n  function is2(value) {\n    const candidate = value;\n    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  AnnotatedTextEdit2.is = is2;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\nvar TextDocumentEdit;\n(function(TextDocumentEdit2) {\n  function create(textDocument, edits) {\n    return { textDocument, edits };\n  }\n  TextDocumentEdit2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);\n  }\n  TextDocumentEdit2.is = is2;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nvar CreateFile;\n(function(CreateFile2) {\n  function create(uri, options, annotation) {\n    let result = {\n      kind: \"create\",\n      uri\n    };\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result.options = options;\n    }\n    if (annotation !== void 0) {\n      result.annotationId = annotation;\n    }\n    return result;\n  }\n  CreateFile2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return candidate && candidate.kind === \"create\" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  CreateFile2.is = is2;\n})(CreateFile || (CreateFile = {}));\nvar RenameFile;\n(function(RenameFile2) {\n  function create(oldUri, newUri, options, annotation) {\n    let result = {\n      kind: \"rename\",\n      oldUri,\n      newUri\n    };\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result.options = options;\n    }\n    if (annotation !== void 0) {\n      result.annotationId = annotation;\n    }\n    return result;\n  }\n  RenameFile2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return candidate && candidate.kind === \"rename\" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  RenameFile2.is = is2;\n})(RenameFile || (RenameFile = {}));\nvar DeleteFile;\n(function(DeleteFile2) {\n  function create(uri, options, annotation) {\n    let result = {\n      kind: \"delete\",\n      uri\n    };\n    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\n      result.options = options;\n    }\n    if (annotation !== void 0) {\n      result.annotationId = annotation;\n    }\n    return result;\n  }\n  DeleteFile2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return candidate && candidate.kind === \"delete\" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  DeleteFile2.is = is2;\n})(DeleteFile || (DeleteFile = {}));\nvar WorkspaceEdit;\n(function(WorkspaceEdit2) {\n  function is2(value) {\n    let candidate = value;\n    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {\n      if (Is.string(change.kind)) {\n        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n      } else {\n        return TextDocumentEdit.is(change);\n      }\n    }));\n  }\n  WorkspaceEdit2.is = is2;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextDocumentIdentifier;\n(function(TextDocumentIdentifier2) {\n  function create(uri) {\n    return { uri };\n  }\n  TextDocumentIdentifier2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri);\n  }\n  TextDocumentIdentifier2.is = is2;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\nvar VersionedTextDocumentIdentifier;\n(function(VersionedTextDocumentIdentifier2) {\n  function create(uri, version) {\n    return { uri, version };\n  }\n  VersionedTextDocumentIdentifier2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n  }\n  VersionedTextDocumentIdentifier2.is = is2;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\nvar OptionalVersionedTextDocumentIdentifier;\n(function(OptionalVersionedTextDocumentIdentifier2) {\n  function create(uri, version) {\n    return { uri, version };\n  }\n  OptionalVersionedTextDocumentIdentifier2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n  }\n  OptionalVersionedTextDocumentIdentifier2.is = is2;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\nvar TextDocumentItem;\n(function(TextDocumentItem2) {\n  function create(uri, languageId, version, text) {\n    return { uri, languageId, version, text };\n  }\n  TextDocumentItem2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n  }\n  TextDocumentItem2.is = is2;\n})(TextDocumentItem || (TextDocumentItem = {}));\nvar MarkupKind;\n(function(MarkupKind2) {\n  MarkupKind2.PlainText = \"plaintext\";\n  MarkupKind2.Markdown = \"markdown\";\n  function is2(value) {\n    const candidate = value;\n    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;\n  }\n  MarkupKind2.is = is2;\n})(MarkupKind || (MarkupKind = {}));\nvar MarkupContent;\n(function(MarkupContent2) {\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n  }\n  MarkupContent2.is = is2;\n})(MarkupContent || (MarkupContent = {}));\nvar CompletionItemKind;\n(function(CompletionItemKind2) {\n  CompletionItemKind2.Text = 1;\n  CompletionItemKind2.Method = 2;\n  CompletionItemKind2.Function = 3;\n  CompletionItemKind2.Constructor = 4;\n  CompletionItemKind2.Field = 5;\n  CompletionItemKind2.Variable = 6;\n  CompletionItemKind2.Class = 7;\n  CompletionItemKind2.Interface = 8;\n  CompletionItemKind2.Module = 9;\n  CompletionItemKind2.Property = 10;\n  CompletionItemKind2.Unit = 11;\n  CompletionItemKind2.Value = 12;\n  CompletionItemKind2.Enum = 13;\n  CompletionItemKind2.Keyword = 14;\n  CompletionItemKind2.Snippet = 15;\n  CompletionItemKind2.Color = 16;\n  CompletionItemKind2.File = 17;\n  CompletionItemKind2.Reference = 18;\n  CompletionItemKind2.Folder = 19;\n  CompletionItemKind2.EnumMember = 20;\n  CompletionItemKind2.Constant = 21;\n  CompletionItemKind2.Struct = 22;\n  CompletionItemKind2.Event = 23;\n  CompletionItemKind2.Operator = 24;\n  CompletionItemKind2.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\nvar InsertTextFormat;\n(function(InsertTextFormat2) {\n  InsertTextFormat2.PlainText = 1;\n  InsertTextFormat2.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\nvar CompletionItemTag;\n(function(CompletionItemTag2) {\n  CompletionItemTag2.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\nvar InsertReplaceEdit;\n(function(InsertReplaceEdit2) {\n  function create(newText, insert, replace) {\n    return { newText, insert, replace };\n  }\n  InsertReplaceEdit2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n  }\n  InsertReplaceEdit2.is = is2;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\nvar InsertTextMode;\n(function(InsertTextMode2) {\n  InsertTextMode2.asIs = 1;\n  InsertTextMode2.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nvar CompletionItemLabelDetails;\n(function(CompletionItemLabelDetails2) {\n  function is2(value) {\n    const candidate = value;\n    return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);\n  }\n  CompletionItemLabelDetails2.is = is2;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\nvar CompletionItem;\n(function(CompletionItem2) {\n  function create(label) {\n    return { label };\n  }\n  CompletionItem2.create = create;\n})(CompletionItem || (CompletionItem = {}));\nvar CompletionList;\n(function(CompletionList2) {\n  function create(items, isIncomplete) {\n    return { items: items ? items : [], isIncomplete: !!isIncomplete };\n  }\n  CompletionList2.create = create;\n})(CompletionList || (CompletionList = {}));\nvar MarkedString;\n(function(MarkedString2) {\n  function fromPlainText(plainText) {\n    return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\");\n  }\n  MarkedString2.fromPlainText = fromPlainText;\n  function is2(value) {\n    const candidate = value;\n    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);\n  }\n  MarkedString2.is = is2;\n})(MarkedString || (MarkedString = {}));\nvar Hover;\n(function(Hover2) {\n  function is2(value) {\n    let candidate = value;\n    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));\n  }\n  Hover2.is = is2;\n})(Hover || (Hover = {}));\nvar ParameterInformation;\n(function(ParameterInformation2) {\n  function create(label, documentation) {\n    return documentation ? { label, documentation } : { label };\n  }\n  ParameterInformation2.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\nvar SignatureInformation;\n(function(SignatureInformation2) {\n  function create(label, documentation, ...parameters) {\n    let result = { label };\n    if (Is.defined(documentation)) {\n      result.documentation = documentation;\n    }\n    if (Is.defined(parameters)) {\n      result.parameters = parameters;\n    } else {\n      result.parameters = [];\n    }\n    return result;\n  }\n  SignatureInformation2.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\nvar DocumentHighlightKind;\n(function(DocumentHighlightKind2) {\n  DocumentHighlightKind2.Text = 1;\n  DocumentHighlightKind2.Read = 2;\n  DocumentHighlightKind2.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\nvar DocumentHighlight;\n(function(DocumentHighlight2) {\n  function create(range, kind) {\n    let result = { range };\n    if (Is.number(kind)) {\n      result.kind = kind;\n    }\n    return result;\n  }\n  DocumentHighlight2.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\nvar SymbolKind;\n(function(SymbolKind2) {\n  SymbolKind2.File = 1;\n  SymbolKind2.Module = 2;\n  SymbolKind2.Namespace = 3;\n  SymbolKind2.Package = 4;\n  SymbolKind2.Class = 5;\n  SymbolKind2.Method = 6;\n  SymbolKind2.Property = 7;\n  SymbolKind2.Field = 8;\n  SymbolKind2.Constructor = 9;\n  SymbolKind2.Enum = 10;\n  SymbolKind2.Interface = 11;\n  SymbolKind2.Function = 12;\n  SymbolKind2.Variable = 13;\n  SymbolKind2.Constant = 14;\n  SymbolKind2.String = 15;\n  SymbolKind2.Number = 16;\n  SymbolKind2.Boolean = 17;\n  SymbolKind2.Array = 18;\n  SymbolKind2.Object = 19;\n  SymbolKind2.Key = 20;\n  SymbolKind2.Null = 21;\n  SymbolKind2.EnumMember = 22;\n  SymbolKind2.Struct = 23;\n  SymbolKind2.Event = 24;\n  SymbolKind2.Operator = 25;\n  SymbolKind2.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\nvar SymbolTag;\n(function(SymbolTag2) {\n  SymbolTag2.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nvar SymbolInformation;\n(function(SymbolInformation2) {\n  function create(name, kind, range, uri, containerName) {\n    let result = {\n      name,\n      kind,\n      location: { uri, range }\n    };\n    if (containerName) {\n      result.containerName = containerName;\n    }\n    return result;\n  }\n  SymbolInformation2.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nvar WorkspaceSymbol;\n(function(WorkspaceSymbol2) {\n  function create(name, kind, uri, range) {\n    return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };\n  }\n  WorkspaceSymbol2.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nvar DocumentSymbol;\n(function(DocumentSymbol2) {\n  function create(name, detail, kind, range, selectionRange, children) {\n    let result = {\n      name,\n      detail,\n      kind,\n      range,\n      selectionRange\n    };\n    if (children !== void 0) {\n      result.children = children;\n    }\n    return result;\n  }\n  DocumentSymbol2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));\n  }\n  DocumentSymbol2.is = is2;\n})(DocumentSymbol || (DocumentSymbol = {}));\nvar CodeActionKind;\n(function(CodeActionKind2) {\n  CodeActionKind2.Empty = \"\";\n  CodeActionKind2.QuickFix = \"quickfix\";\n  CodeActionKind2.Refactor = \"refactor\";\n  CodeActionKind2.RefactorExtract = \"refactor.extract\";\n  CodeActionKind2.RefactorInline = \"refactor.inline\";\n  CodeActionKind2.RefactorRewrite = \"refactor.rewrite\";\n  CodeActionKind2.Source = \"source\";\n  CodeActionKind2.SourceOrganizeImports = \"source.organizeImports\";\n  CodeActionKind2.SourceFixAll = \"source.fixAll\";\n})(CodeActionKind || (CodeActionKind = {}));\nvar CodeActionTriggerKind;\n(function(CodeActionTriggerKind2) {\n  CodeActionTriggerKind2.Invoked = 1;\n  CodeActionTriggerKind2.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\nvar CodeActionContext;\n(function(CodeActionContext2) {\n  function create(diagnostics, only, triggerKind) {\n    let result = { diagnostics };\n    if (only !== void 0 && only !== null) {\n      result.only = only;\n    }\n    if (triggerKind !== void 0 && triggerKind !== null) {\n      result.triggerKind = triggerKind;\n    }\n    return result;\n  }\n  CodeActionContext2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n  }\n  CodeActionContext2.is = is2;\n})(CodeActionContext || (CodeActionContext = {}));\nvar CodeAction;\n(function(CodeAction2) {\n  function create(title, kindOrCommandOrEdit, kind) {\n    let result = { title };\n    let checkKind = true;\n    if (typeof kindOrCommandOrEdit === \"string\") {\n      checkKind = false;\n      result.kind = kindOrCommandOrEdit;\n    } else if (Command.is(kindOrCommandOrEdit)) {\n      result.command = kindOrCommandOrEdit;\n    } else {\n      result.edit = kindOrCommandOrEdit;\n    }\n    if (checkKind && kind !== void 0) {\n      result.kind = kind;\n    }\n    return result;\n  }\n  CodeAction2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\n  }\n  CodeAction2.is = is2;\n})(CodeAction || (CodeAction = {}));\nvar CodeLens;\n(function(CodeLens2) {\n  function create(range, data) {\n    let result = { range };\n    if (Is.defined(data)) {\n      result.data = data;\n    }\n    return result;\n  }\n  CodeLens2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n  }\n  CodeLens2.is = is2;\n})(CodeLens || (CodeLens = {}));\nvar FormattingOptions;\n(function(FormattingOptions2) {\n  function create(tabSize, insertSpaces) {\n    return { tabSize, insertSpaces };\n  }\n  FormattingOptions2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n  }\n  FormattingOptions2.is = is2;\n})(FormattingOptions || (FormattingOptions = {}));\nvar DocumentLink;\n(function(DocumentLink2) {\n  function create(range, target, data) {\n    return { range, target, data };\n  }\n  DocumentLink2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n  }\n  DocumentLink2.is = is2;\n})(DocumentLink || (DocumentLink = {}));\nvar SelectionRange;\n(function(SelectionRange2) {\n  function create(range, parent) {\n    return { range, parent };\n  }\n  SelectionRange2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));\n  }\n  SelectionRange2.is = is2;\n})(SelectionRange || (SelectionRange = {}));\nvar SemanticTokenTypes;\n(function(SemanticTokenTypes2) {\n  SemanticTokenTypes2[\"namespace\"] = \"namespace\";\n  SemanticTokenTypes2[\"type\"] = \"type\";\n  SemanticTokenTypes2[\"class\"] = \"class\";\n  SemanticTokenTypes2[\"enum\"] = \"enum\";\n  SemanticTokenTypes2[\"interface\"] = \"interface\";\n  SemanticTokenTypes2[\"struct\"] = \"struct\";\n  SemanticTokenTypes2[\"typeParameter\"] = \"typeParameter\";\n  SemanticTokenTypes2[\"parameter\"] = \"parameter\";\n  SemanticTokenTypes2[\"variable\"] = \"variable\";\n  SemanticTokenTypes2[\"property\"] = \"property\";\n  SemanticTokenTypes2[\"enumMember\"] = \"enumMember\";\n  SemanticTokenTypes2[\"event\"] = \"event\";\n  SemanticTokenTypes2[\"function\"] = \"function\";\n  SemanticTokenTypes2[\"method\"] = \"method\";\n  SemanticTokenTypes2[\"macro\"] = \"macro\";\n  SemanticTokenTypes2[\"keyword\"] = \"keyword\";\n  SemanticTokenTypes2[\"modifier\"] = \"modifier\";\n  SemanticTokenTypes2[\"comment\"] = \"comment\";\n  SemanticTokenTypes2[\"string\"] = \"string\";\n  SemanticTokenTypes2[\"number\"] = \"number\";\n  SemanticTokenTypes2[\"regexp\"] = \"regexp\";\n  SemanticTokenTypes2[\"operator\"] = \"operator\";\n  SemanticTokenTypes2[\"decorator\"] = \"decorator\";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\nvar SemanticTokenModifiers;\n(function(SemanticTokenModifiers2) {\n  SemanticTokenModifiers2[\"declaration\"] = \"declaration\";\n  SemanticTokenModifiers2[\"definition\"] = \"definition\";\n  SemanticTokenModifiers2[\"readonly\"] = \"readonly\";\n  SemanticTokenModifiers2[\"static\"] = \"static\";\n  SemanticTokenModifiers2[\"deprecated\"] = \"deprecated\";\n  SemanticTokenModifiers2[\"abstract\"] = \"abstract\";\n  SemanticTokenModifiers2[\"async\"] = \"async\";\n  SemanticTokenModifiers2[\"modification\"] = \"modification\";\n  SemanticTokenModifiers2[\"documentation\"] = \"documentation\";\n  SemanticTokenModifiers2[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\nvar SemanticTokens;\n(function(SemanticTokens2) {\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === \"string\") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === \"number\");\n  }\n  SemanticTokens2.is = is2;\n})(SemanticTokens || (SemanticTokens = {}));\nvar InlineValueText;\n(function(InlineValueText2) {\n  function create(range, text) {\n    return { range, text };\n  }\n  InlineValueText2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n  }\n  InlineValueText2.is = is2;\n})(InlineValueText || (InlineValueText = {}));\nvar InlineValueVariableLookup;\n(function(InlineValueVariableLookup2) {\n  function create(range, variableName, caseSensitiveLookup) {\n    return { range, variableName, caseSensitiveLookup };\n  }\n  InlineValueVariableLookup2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);\n  }\n  InlineValueVariableLookup2.is = is2;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\nvar InlineValueEvaluatableExpression;\n(function(InlineValueEvaluatableExpression2) {\n  function create(range, expression) {\n    return { range, expression };\n  }\n  InlineValueEvaluatableExpression2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);\n  }\n  InlineValueEvaluatableExpression2.is = is2;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\nvar InlineValueContext;\n(function(InlineValueContext2) {\n  function create(frameId, stoppedLocation) {\n    return { frameId, stoppedLocation };\n  }\n  InlineValueContext2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return Is.defined(candidate) && Range.is(value.stoppedLocation);\n  }\n  InlineValueContext2.is = is2;\n})(InlineValueContext || (InlineValueContext = {}));\nvar InlayHintKind;\n(function(InlayHintKind2) {\n  InlayHintKind2.Type = 1;\n  InlayHintKind2.Parameter = 2;\n  function is2(value) {\n    return value === 1 || value === 2;\n  }\n  InlayHintKind2.is = is2;\n})(InlayHintKind || (InlayHintKind = {}));\nvar InlayHintLabelPart;\n(function(InlayHintLabelPart2) {\n  function create(value) {\n    return { value };\n  }\n  InlayHintLabelPart2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));\n  }\n  InlayHintLabelPart2.is = is2;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nvar InlayHint;\n(function(InlayHint2) {\n  function create(position, label, kind) {\n    const result = { position, label };\n    if (kind !== void 0) {\n      result.kind = kind;\n    }\n    return result;\n  }\n  InlayHint2.create = create;\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));\n  }\n  InlayHint2.is = is2;\n})(InlayHint || (InlayHint = {}));\nvar StringValue;\n(function(StringValue2) {\n  function createSnippet(value) {\n    return { kind: \"snippet\", value };\n  }\n  StringValue2.createSnippet = createSnippet;\n})(StringValue || (StringValue = {}));\nvar InlineCompletionItem;\n(function(InlineCompletionItem2) {\n  function create(insertText, filterText, range, command) {\n    return { insertText, filterText, range, command };\n  }\n  InlineCompletionItem2.create = create;\n})(InlineCompletionItem || (InlineCompletionItem = {}));\nvar InlineCompletionList;\n(function(InlineCompletionList2) {\n  function create(items) {\n    return { items };\n  }\n  InlineCompletionList2.create = create;\n})(InlineCompletionList || (InlineCompletionList = {}));\nvar InlineCompletionTriggerKind;\n(function(InlineCompletionTriggerKind2) {\n  InlineCompletionTriggerKind2.Invoked = 0;\n  InlineCompletionTriggerKind2.Automatic = 1;\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nvar SelectedCompletionInfo;\n(function(SelectedCompletionInfo2) {\n  function create(range, text) {\n    return { range, text };\n  }\n  SelectedCompletionInfo2.create = create;\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\nvar InlineCompletionContext;\n(function(InlineCompletionContext2) {\n  function create(triggerKind, selectedCompletionInfo) {\n    return { triggerKind, selectedCompletionInfo };\n  }\n  InlineCompletionContext2.create = create;\n})(InlineCompletionContext || (InlineCompletionContext = {}));\nvar WorkspaceFolder;\n(function(WorkspaceFolder2) {\n  function is2(value) {\n    const candidate = value;\n    return Is.objectLiteral(candidate) && URI$1.is(candidate.uri) && Is.string(candidate.name);\n  }\n  WorkspaceFolder2.is = is2;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nvar TextDocument$1;\n(function(TextDocument2) {\n  function create(uri, languageId, version, content) {\n    return new FullTextDocument$1(uri, languageId, version, content);\n  }\n  TextDocument2.create = create;\n  function is2(value) {\n    let candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n  }\n  TextDocument2.is = is2;\n  function applyEdits(document, edits) {\n    let text = document.getText();\n    let sortedEdits = mergeSort2(edits, (a, b) => {\n      let diff = a.range.start.line - b.range.start.line;\n      if (diff === 0) {\n        return a.range.start.character - b.range.start.character;\n      }\n      return diff;\n    });\n    let lastModifiedOffset = text.length;\n    for (let i = sortedEdits.length - 1; i >= 0; i--) {\n      let e = sortedEdits[i];\n      let startOffset = document.offsetAt(e.range.start);\n      let endOffset = document.offsetAt(e.range.end);\n      if (endOffset <= lastModifiedOffset) {\n        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n      } else {\n        throw new Error(\"Overlapping edit\");\n      }\n      lastModifiedOffset = startOffset;\n    }\n    return text;\n  }\n  TextDocument2.applyEdits = applyEdits;\n  function mergeSort2(data, compare) {\n    if (data.length <= 1) {\n      return data;\n    }\n    const p = data.length / 2 | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    mergeSort2(left, compare);\n    mergeSort2(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n      let ret = compare(left[leftIdx], right[rightIdx]);\n      if (ret <= 0) {\n        data[i++] = left[leftIdx++];\n      } else {\n        data[i++] = right[rightIdx++];\n      }\n    }\n    while (leftIdx < left.length) {\n      data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n      data[i++] = right[rightIdx++];\n    }\n    return data;\n  }\n})(TextDocument$1 || (TextDocument$1 = {}));\nlet FullTextDocument$1 = class FullTextDocument {\n  constructor(uri, languageId, version, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version;\n    this._content = content;\n    this._lineOffsets = void 0;\n  }\n  get uri() {\n    return this._uri;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get version() {\n    return this._version;\n  }\n  getText(range) {\n    if (range) {\n      let start = this.offsetAt(range.start);\n      let end = this.offsetAt(range.end);\n      return this._content.substring(start, end);\n    }\n    return this._content;\n  }\n  update(event, version) {\n    this._content = event.text;\n    this._version = version;\n    this._lineOffsets = void 0;\n  }\n  getLineOffsets() {\n    if (this._lineOffsets === void 0) {\n      let lineOffsets = [];\n      let text = this._content;\n      let isLineStart = true;\n      for (let i = 0; i < text.length; i++) {\n        if (isLineStart) {\n          lineOffsets.push(i);\n          isLineStart = false;\n        }\n        let ch = text.charAt(i);\n        isLineStart = ch === \"\\r\" || ch === \"\\n\";\n        if (ch === \"\\r\" && i + 1 < text.length && text.charAt(i + 1) === \"\\n\") {\n          i++;\n        }\n      }\n      if (isLineStart && text.length > 0) {\n        lineOffsets.push(text.length);\n      }\n      this._lineOffsets = lineOffsets;\n    }\n    return this._lineOffsets;\n  }\n  positionAt(offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    let lineOffsets = this.getLineOffsets();\n    let low = 0, high = lineOffsets.length;\n    if (high === 0) {\n      return Position.create(0, offset);\n    }\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      if (lineOffsets[mid] > offset) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    let line = low - 1;\n    return Position.create(line, offset - lineOffsets[line]);\n  }\n  offsetAt(position) {\n    let lineOffsets = this.getLineOffsets();\n    if (position.line >= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line < 0) {\n      return 0;\n    }\n    let lineOffset = lineOffsets[position.line];\n    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n  }\n  get lineCount() {\n    return this.getLineOffsets().length;\n  }\n};\nvar Is;\n(function(Is2) {\n  const toString2 = Object.prototype.toString;\n  function defined(value) {\n    return typeof value !== \"undefined\";\n  }\n  Is2.defined = defined;\n  function undefined$1(value) {\n    return typeof value === \"undefined\";\n  }\n  Is2.undefined = undefined$1;\n  function boolean(value) {\n    return value === true || value === false;\n  }\n  Is2.boolean = boolean;\n  function string(value) {\n    return toString2.call(value) === \"[object String]\";\n  }\n  Is2.string = string;\n  function number(value) {\n    return toString2.call(value) === \"[object Number]\";\n  }\n  Is2.number = number;\n  function numberRange(value, min2, max) {\n    return toString2.call(value) === \"[object Number]\" && min2 <= value && value <= max;\n  }\n  Is2.numberRange = numberRange;\n  function integer2(value) {\n    return toString2.call(value) === \"[object Number]\" && -2147483648 <= value && value <= 2147483647;\n  }\n  Is2.integer = integer2;\n  function uinteger2(value) {\n    return toString2.call(value) === \"[object Number]\" && 0 <= value && value <= 2147483647;\n  }\n  Is2.uinteger = uinteger2;\n  function func(value) {\n    return toString2.call(value) === \"[object Function]\";\n  }\n  Is2.func = func;\n  function objectLiteral(value) {\n    return value !== null && typeof value === \"object\";\n  }\n  Is2.objectLiteral = objectLiteral;\n  function typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n  }\n  Is2.typedArray = typedArray;\n})(Is || (Is = {}));\nclass CstNodeBuilder {\n  constructor() {\n    this.nodeStack = [];\n  }\n  get current() {\n    var _a2;\n    return (_a2 = this.nodeStack[this.nodeStack.length - 1]) !== null && _a2 !== void 0 ? _a2 : this.rootNode;\n  }\n  buildRootNode(input) {\n    this.rootNode = new RootCstNodeImpl(input);\n    this.rootNode.root = this.rootNode;\n    this.nodeStack = [this.rootNode];\n    return this.rootNode;\n  }\n  buildCompositeNode(feature) {\n    const compositeNode = new CompositeCstNodeImpl();\n    compositeNode.grammarSource = feature;\n    compositeNode.root = this.rootNode;\n    this.current.content.push(compositeNode);\n    this.nodeStack.push(compositeNode);\n    return compositeNode;\n  }\n  buildLeafNode(token, feature) {\n    const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, !feature);\n    leafNode.grammarSource = feature;\n    leafNode.root = this.rootNode;\n    this.current.content.push(leafNode);\n    return leafNode;\n  }\n  removeNode(node) {\n    const parent = node.container;\n    if (parent) {\n      const index = parent.content.indexOf(node);\n      if (index >= 0) {\n        parent.content.splice(index, 1);\n      }\n    }\n  }\n  addHiddenNodes(tokens) {\n    const nodes = [];\n    for (const token of tokens) {\n      const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\n      leafNode.root = this.rootNode;\n      nodes.push(leafNode);\n    }\n    let current = this.current;\n    let added = false;\n    if (current.content.length > 0) {\n      current.content.push(...nodes);\n      return;\n    }\n    while (current.container) {\n      const index = current.container.content.indexOf(current);\n      if (index > 0) {\n        current.container.content.splice(index, 0, ...nodes);\n        added = true;\n        break;\n      }\n      current = current.container;\n    }\n    if (!added) {\n      this.rootNode.content.unshift(...nodes);\n    }\n  }\n  construct(item) {\n    const current = this.current;\n    if (typeof item.$type === \"string\") {\n      this.current.astNode = item;\n    }\n    item.$cstNode = current;\n    const node = this.nodeStack.pop();\n    if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {\n      this.removeNode(node);\n    }\n  }\n}\nclass AbstractCstNode {\n  /** @deprecated use `container` instead. */\n  get parent() {\n    return this.container;\n  }\n  /** @deprecated use `grammarSource` instead. */\n  get feature() {\n    return this.grammarSource;\n  }\n  get hidden() {\n    return false;\n  }\n  get astNode() {\n    var _a2, _b2;\n    const node = typeof ((_a2 = this._astNode) === null || _a2 === void 0 ? void 0 : _a2.$type) === \"string\" ? this._astNode : (_b2 = this.container) === null || _b2 === void 0 ? void 0 : _b2.astNode;\n    if (!node) {\n      throw new Error(\"This node has no associated AST element\");\n    }\n    return node;\n  }\n  set astNode(value) {\n    this._astNode = value;\n  }\n  /** @deprecated use `astNode` instead. */\n  get element() {\n    return this.astNode;\n  }\n  get text() {\n    return this.root.fullText.substring(this.offset, this.end);\n  }\n}\nclass LeafCstNodeImpl extends AbstractCstNode {\n  get offset() {\n    return this._offset;\n  }\n  get length() {\n    return this._length;\n  }\n  get end() {\n    return this._offset + this._length;\n  }\n  get hidden() {\n    return this._hidden;\n  }\n  get tokenType() {\n    return this._tokenType;\n  }\n  get range() {\n    return this._range;\n  }\n  constructor(offset, length, range, tokenType, hidden = false) {\n    super();\n    this._hidden = hidden;\n    this._offset = offset;\n    this._tokenType = tokenType;\n    this._length = length;\n    this._range = range;\n  }\n}\nclass CompositeCstNodeImpl extends AbstractCstNode {\n  constructor() {\n    super(...arguments);\n    this.content = new CstNodeContainer(this);\n  }\n  /** @deprecated use `content` instead. */\n  get children() {\n    return this.content;\n  }\n  get offset() {\n    var _a2, _b2;\n    return (_b2 = (_a2 = this.firstNonHiddenNode) === null || _a2 === void 0 ? void 0 : _a2.offset) !== null && _b2 !== void 0 ? _b2 : 0;\n  }\n  get length() {\n    return this.end - this.offset;\n  }\n  get end() {\n    var _a2, _b2;\n    return (_b2 = (_a2 = this.lastNonHiddenNode) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b2 !== void 0 ? _b2 : 0;\n  }\n  get range() {\n    const firstNode = this.firstNonHiddenNode;\n    const lastNode = this.lastNonHiddenNode;\n    if (firstNode && lastNode) {\n      if (this._rangeCache === void 0) {\n        const { range: firstRange } = firstNode;\n        const { range: lastRange } = lastNode;\n        this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\n      }\n      return this._rangeCache;\n    } else {\n      return { start: Position.create(0, 0), end: Position.create(0, 0) };\n    }\n  }\n  get firstNonHiddenNode() {\n    for (const child of this.content) {\n      if (!child.hidden) {\n        return child;\n      }\n    }\n    return this.content[0];\n  }\n  get lastNonHiddenNode() {\n    for (let i = this.content.length - 1; i >= 0; i--) {\n      const child = this.content[i];\n      if (!child.hidden) {\n        return child;\n      }\n    }\n    return this.content[this.content.length - 1];\n  }\n}\nclass CstNodeContainer extends Array {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    Object.setPrototypeOf(this, CstNodeContainer.prototype);\n  }\n  push(...items) {\n    this.addParents(items);\n    return super.push(...items);\n  }\n  unshift(...items) {\n    this.addParents(items);\n    return super.unshift(...items);\n  }\n  splice(start, count, ...items) {\n    this.addParents(items);\n    return super.splice(start, count, ...items);\n  }\n  addParents(items) {\n    for (const item of items) {\n      item.container = this.parent;\n    }\n  }\n}\nclass RootCstNodeImpl extends CompositeCstNodeImpl {\n  get text() {\n    return this._text.substring(this.offset, this.end);\n  }\n  get fullText() {\n    return this._text;\n  }\n  constructor(input) {\n    super();\n    this._text = \"\";\n    this._text = input !== null && input !== void 0 ? input : \"\";\n  }\n}\nconst DatatypeSymbol = Symbol(\"Datatype\");\nfunction isDataTypeNode(node) {\n  return node.$type === DatatypeSymbol;\n}\nconst ruleSuffix = \"​\";\nconst withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;\nclass AbstractLangiumParser {\n  constructor(services) {\n    this._unorderedGroups = /* @__PURE__ */ new Map();\n    this.allRules = /* @__PURE__ */ new Map();\n    this.lexer = services.parser.Lexer;\n    const tokens = this.lexer.definition;\n    const production = services.LanguageMetaData.mode === \"production\";\n    this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { skipValidations: production, errorMessageProvider: services.parser.ParserErrorMessageProvider }));\n  }\n  alternatives(idx, choices) {\n    this.wrapper.wrapOr(idx, choices);\n  }\n  optional(idx, callback) {\n    this.wrapper.wrapOption(idx, callback);\n  }\n  many(idx, callback) {\n    this.wrapper.wrapMany(idx, callback);\n  }\n  atLeastOne(idx, callback) {\n    this.wrapper.wrapAtLeastOne(idx, callback);\n  }\n  getRule(name) {\n    return this.allRules.get(name);\n  }\n  isRecording() {\n    return this.wrapper.IS_RECORDING;\n  }\n  get unorderedGroups() {\n    return this._unorderedGroups;\n  }\n  getRuleStack() {\n    return this.wrapper.RULE_STACK;\n  }\n  finalize() {\n    this.wrapper.wrapSelfAnalysis();\n  }\n}\nclass LangiumParser extends AbstractLangiumParser {\n  get current() {\n    return this.stack[this.stack.length - 1];\n  }\n  constructor(services) {\n    super(services);\n    this.nodeBuilder = new CstNodeBuilder();\n    this.stack = [];\n    this.assignmentMap = /* @__PURE__ */ new Map();\n    this.linker = services.references.Linker;\n    this.converter = services.parser.ValueConverter;\n    this.astReflection = services.shared.AstReflection;\n  }\n  rule(rule, impl) {\n    const type = this.computeRuleType(rule);\n    const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\n    this.allRules.set(rule.name, ruleMethod);\n    if (rule.entry) {\n      this.mainRule = ruleMethod;\n    }\n    return ruleMethod;\n  }\n  computeRuleType(rule) {\n    if (rule.fragment) {\n      return void 0;\n    } else if (isDataTypeRule(rule)) {\n      return DatatypeSymbol;\n    } else {\n      const explicit = getExplicitRuleType(rule);\n      return explicit !== null && explicit !== void 0 ? explicit : rule.name;\n    }\n  }\n  parse(input, options = {}) {\n    this.nodeBuilder.buildRootNode(input);\n    const lexerResult = this.lexerResult = this.lexer.tokenize(input);\n    this.wrapper.input = lexerResult.tokens;\n    const ruleMethod = options.rule ? this.allRules.get(options.rule) : this.mainRule;\n    if (!ruleMethod) {\n      throw new Error(options.rule ? `No rule found with name '${options.rule}'` : \"No main rule available.\");\n    }\n    const result = ruleMethod.call(this.wrapper, {});\n    this.nodeBuilder.addHiddenNodes(lexerResult.hidden);\n    this.unorderedGroups.clear();\n    this.lexerResult = void 0;\n    return {\n      value: result,\n      lexerErrors: lexerResult.errors,\n      lexerReport: lexerResult.report,\n      parserErrors: this.wrapper.errors\n    };\n  }\n  startImplementation($type, implementation) {\n    return (args) => {\n      const createNode = !this.isRecording() && $type !== void 0;\n      if (createNode) {\n        const node = { $type };\n        this.stack.push(node);\n        if ($type === DatatypeSymbol) {\n          node.value = \"\";\n        }\n      }\n      let result;\n      try {\n        result = implementation(args);\n      } catch (err) {\n        result = void 0;\n      }\n      if (result === void 0 && createNode) {\n        result = this.construct();\n      }\n      return result;\n    };\n  }\n  extractHiddenTokens(token) {\n    const hiddenTokens = this.lexerResult.hidden;\n    if (!hiddenTokens.length) {\n      return [];\n    }\n    const offset = token.startOffset;\n    for (let i = 0; i < hiddenTokens.length; i++) {\n      const token2 = hiddenTokens[i];\n      if (token2.startOffset > offset) {\n        return hiddenTokens.splice(0, i);\n      }\n    }\n    return hiddenTokens.splice(0, hiddenTokens.length);\n  }\n  consume(idx, tokenType, feature) {\n    const token = this.wrapper.wrapConsume(idx, tokenType);\n    if (!this.isRecording() && this.isValidToken(token)) {\n      const hiddenTokens = this.extractHiddenTokens(token);\n      this.nodeBuilder.addHiddenNodes(hiddenTokens);\n      const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\n      const { assignment, isCrossRef } = this.getAssignment(feature);\n      const current = this.current;\n      if (assignment) {\n        const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\n        this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\n      } else if (isDataTypeNode(current)) {\n        let text = token.image;\n        if (!isKeyword(feature)) {\n          text = this.converter.convert(text, leafNode).toString();\n        }\n        current.value += text;\n      }\n    }\n  }\n  /**\n   * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\n   *\n   * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\n   * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\n   */\n  isValidToken(token) {\n    return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === \"number\" && !isNaN(token.endOffset);\n  }\n  subrule(idx, rule, fragment, feature, args) {\n    let cstNode;\n    if (!this.isRecording() && !fragment) {\n      cstNode = this.nodeBuilder.buildCompositeNode(feature);\n    }\n    const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);\n    if (!this.isRecording() && cstNode && cstNode.length > 0) {\n      this.performSubruleAssignment(subruleResult, feature, cstNode);\n    }\n  }\n  performSubruleAssignment(result, feature, cstNode) {\n    const { assignment, isCrossRef } = this.getAssignment(feature);\n    if (assignment) {\n      this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\n    } else if (!assignment) {\n      const current = this.current;\n      if (isDataTypeNode(current)) {\n        current.value += result.toString();\n      } else if (typeof result === \"object\" && result) {\n        const object = this.assignWithoutOverride(result, current);\n        const newItem = object;\n        this.stack.pop();\n        this.stack.push(newItem);\n      }\n    }\n  }\n  action($type, action) {\n    if (!this.isRecording()) {\n      let last2 = this.current;\n      if (action.feature && action.operator) {\n        last2 = this.construct();\n        this.nodeBuilder.removeNode(last2.$cstNode);\n        const node = this.nodeBuilder.buildCompositeNode(action);\n        node.content.push(last2.$cstNode);\n        const newItem = { $type };\n        this.stack.push(newItem);\n        this.assign(action.operator, action.feature, last2, last2.$cstNode, false);\n      } else {\n        last2.$type = $type;\n      }\n    }\n  }\n  construct() {\n    if (this.isRecording()) {\n      return void 0;\n    }\n    const obj = this.current;\n    linkContentToContainer(obj);\n    this.nodeBuilder.construct(obj);\n    this.stack.pop();\n    if (isDataTypeNode(obj)) {\n      return this.converter.convert(obj.value, obj.$cstNode);\n    } else {\n      assignMandatoryProperties(this.astReflection, obj);\n    }\n    return obj;\n  }\n  getAssignment(feature) {\n    if (!this.assignmentMap.has(feature)) {\n      const assignment = getContainerOfType(feature, isAssignment);\n      this.assignmentMap.set(feature, {\n        assignment,\n        isCrossRef: assignment ? isCrossReference(assignment.terminal) : false\n      });\n    }\n    return this.assignmentMap.get(feature);\n  }\n  assign(operator, feature, value, cstNode, isCrossRef) {\n    const obj = this.current;\n    let item;\n    if (isCrossRef && typeof value === \"string\") {\n      item = this.linker.buildReference(obj, feature, cstNode, value);\n    } else {\n      item = value;\n    }\n    switch (operator) {\n      case \"=\": {\n        obj[feature] = item;\n        break;\n      }\n      case \"?=\": {\n        obj[feature] = true;\n        break;\n      }\n      case \"+=\": {\n        if (!Array.isArray(obj[feature])) {\n          obj[feature] = [];\n        }\n        obj[feature].push(item);\n      }\n    }\n  }\n  assignWithoutOverride(target, source) {\n    for (const [name, existingValue] of Object.entries(source)) {\n      const newValue = target[name];\n      if (newValue === void 0) {\n        target[name] = existingValue;\n      } else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\n        existingValue.push(...newValue);\n        target[name] = existingValue;\n      }\n    }\n    const targetCstNode = target.$cstNode;\n    if (targetCstNode) {\n      targetCstNode.astNode = void 0;\n      target.$cstNode = void 0;\n    }\n    return target;\n  }\n  get definitionErrors() {\n    return this.wrapper.definitionErrors;\n  }\n}\nclass AbstractParserErrorMessageProvider {\n  buildMismatchTokenMessage(options) {\n    return defaultParserErrorProvider.buildMismatchTokenMessage(options);\n  }\n  buildNotAllInputParsedMessage(options) {\n    return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n  }\n  buildNoViableAltMessage(options) {\n    return defaultParserErrorProvider.buildNoViableAltMessage(options);\n  }\n  buildEarlyExitMessage(options) {\n    return defaultParserErrorProvider.buildEarlyExitMessage(options);\n  }\n}\nclass LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {\n  buildMismatchTokenMessage({ expected, actual }) {\n    const expectedMsg = expected.LABEL ? \"`\" + expected.LABEL + \"`\" : expected.name.endsWith(\":KW\") ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'` : `token of type '${expected.name}'`;\n    return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\n  }\n  buildNotAllInputParsedMessage({ firstRedundant }) {\n    return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\n  }\n}\nclass LangiumCompletionParser extends AbstractLangiumParser {\n  constructor() {\n    super(...arguments);\n    this.tokens = [];\n    this.elementStack = [];\n    this.lastElementStack = [];\n    this.nextTokenIndex = 0;\n    this.stackSize = 0;\n  }\n  action() {\n  }\n  construct() {\n    return void 0;\n  }\n  parse(input) {\n    this.resetState();\n    const tokens = this.lexer.tokenize(input, { mode: \"partial\" });\n    this.tokens = tokens.tokens;\n    this.wrapper.input = [...this.tokens];\n    this.mainRule.call(this.wrapper, {});\n    this.unorderedGroups.clear();\n    return {\n      tokens: this.tokens,\n      elementStack: [...this.lastElementStack],\n      tokenIndex: this.nextTokenIndex\n    };\n  }\n  rule(rule, impl) {\n    const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\n    this.allRules.set(rule.name, ruleMethod);\n    if (rule.entry) {\n      this.mainRule = ruleMethod;\n    }\n    return ruleMethod;\n  }\n  resetState() {\n    this.elementStack = [];\n    this.lastElementStack = [];\n    this.nextTokenIndex = 0;\n    this.stackSize = 0;\n  }\n  startImplementation(implementation) {\n    return (args) => {\n      const size = this.keepStackSize();\n      try {\n        implementation(args);\n      } finally {\n        this.resetStackSize(size);\n      }\n    };\n  }\n  removeUnexpectedElements() {\n    this.elementStack.splice(this.stackSize);\n  }\n  keepStackSize() {\n    const size = this.elementStack.length;\n    this.stackSize = size;\n    return size;\n  }\n  resetStackSize(size) {\n    this.removeUnexpectedElements();\n    this.stackSize = size;\n  }\n  consume(idx, tokenType, feature) {\n    this.wrapper.wrapConsume(idx, tokenType);\n    if (!this.isRecording()) {\n      this.lastElementStack = [...this.elementStack, feature];\n      this.nextTokenIndex = this.currIdx + 1;\n    }\n  }\n  subrule(idx, rule, fragment, feature, args) {\n    this.before(feature);\n    this.wrapper.wrapSubrule(idx, rule, args);\n    this.after(feature);\n  }\n  before(element) {\n    if (!this.isRecording()) {\n      this.elementStack.push(element);\n    }\n  }\n  after(element) {\n    if (!this.isRecording()) {\n      const index = this.elementStack.lastIndexOf(element);\n      if (index >= 0) {\n        this.elementStack.splice(index);\n      }\n    }\n  }\n  get currIdx() {\n    return this.wrapper.currIdx;\n  }\n}\nconst defaultConfig = {\n  recoveryEnabled: true,\n  nodeLocationTracking: \"full\",\n  skipValidations: true,\n  errorMessageProvider: new LangiumParserErrorMessageProvider()\n};\nclass ChevrotainWrapper extends EmbeddedActionsParser {\n  constructor(tokens, config) {\n    const useDefaultLookahead = config && \"maxLookahead\" in config;\n    super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead }) : new LLStarLookaheadStrategy({\n      // If validations are skipped, don't log the lookahead warnings\n      logging: config.skipValidations ? () => {\n      } : void 0\n    }) }), config));\n  }\n  get IS_RECORDING() {\n    return this.RECORDING_PHASE;\n  }\n  DEFINE_RULE(name, impl) {\n    return this.RULE(name, impl);\n  }\n  wrapSelfAnalysis() {\n    this.performSelfAnalysis();\n  }\n  wrapConsume(idx, tokenType) {\n    return this.consume(idx, tokenType);\n  }\n  wrapSubrule(idx, rule, args) {\n    return this.subrule(idx, rule, {\n      ARGS: [args]\n    });\n  }\n  wrapOr(idx, choices) {\n    this.or(idx, choices);\n  }\n  wrapOption(idx, callback) {\n    this.option(idx, callback);\n  }\n  wrapMany(idx, callback) {\n    this.many(idx, callback);\n  }\n  wrapAtLeastOne(idx, callback) {\n    this.atLeastOne(idx, callback);\n  }\n}\nfunction createParser(grammar, parser, tokens) {\n  const parserContext = {\n    parser,\n    tokens,\n    ruleNames: /* @__PURE__ */ new Map()\n  };\n  buildRules(parserContext, grammar);\n  return parser;\n}\nfunction buildRules(parserContext, grammar) {\n  const reachable = getAllReachableRules(grammar, false);\n  const parserRules = stream(grammar.rules).filter(isParserRule).filter((rule) => reachable.has(rule));\n  for (const rule of parserRules) {\n    const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });\n    parserContext.parser.rule(rule, buildElement(ctx, rule.definition));\n  }\n}\nfunction buildElement(ctx, element, ignoreGuard = false) {\n  let method;\n  if (isKeyword(element)) {\n    method = buildKeyword(ctx, element);\n  } else if (isAction(element)) {\n    method = buildAction(ctx, element);\n  } else if (isAssignment(element)) {\n    method = buildElement(ctx, element.terminal);\n  } else if (isCrossReference(element)) {\n    method = buildCrossReference(ctx, element);\n  } else if (isRuleCall(element)) {\n    method = buildRuleCall(ctx, element);\n  } else if (isAlternatives(element)) {\n    method = buildAlternatives(ctx, element);\n  } else if (isUnorderedGroup(element)) {\n    method = buildUnorderedGroup(ctx, element);\n  } else if (isGroup(element)) {\n    method = buildGroup(ctx, element);\n  } else if (isEndOfFile(element)) {\n    const idx = ctx.consume++;\n    method = () => ctx.parser.consume(idx, EOF, element);\n  } else {\n    throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n  }\n  return wrap(ctx, ignoreGuard ? void 0 : getGuardCondition(element), method, element.cardinality);\n}\nfunction buildAction(ctx, action) {\n  const actionType = getTypeName(action);\n  return () => ctx.parser.action(actionType, action);\n}\nfunction buildRuleCall(ctx, ruleCall) {\n  const rule = ruleCall.rule.ref;\n  if (isParserRule(rule)) {\n    const idx = ctx.subrule++;\n    const fragment = rule.fragment;\n    const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n    return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));\n  } else if (isTerminalRule(rule)) {\n    const idx = ctx.consume++;\n    const method = getToken(ctx, rule.name);\n    return () => ctx.parser.consume(idx, method, ruleCall);\n  } else if (!rule) {\n    throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);\n  } else {\n    assertUnreachable();\n  }\n}\nfunction buildRuleCallPredicate(rule, namedArgs) {\n  const predicates = namedArgs.map((e) => buildPredicate(e.value));\n  return (args) => {\n    const ruleArgs = {};\n    for (let i = 0; i < predicates.length; i++) {\n      const ruleTarget = rule.parameters[i];\n      const predicate = predicates[i];\n      ruleArgs[ruleTarget.name] = predicate(args);\n    }\n    return ruleArgs;\n  };\n}\nfunction buildPredicate(condition) {\n  if (isDisjunction(condition)) {\n    const left = buildPredicate(condition.left);\n    const right = buildPredicate(condition.right);\n    return (args) => left(args) || right(args);\n  } else if (isConjunction(condition)) {\n    const left = buildPredicate(condition.left);\n    const right = buildPredicate(condition.right);\n    return (args) => left(args) && right(args);\n  } else if (isNegation(condition)) {\n    const value = buildPredicate(condition.value);\n    return (args) => !value(args);\n  } else if (isParameterReference(condition)) {\n    const name = condition.parameter.ref.name;\n    return (args) => args !== void 0 && args[name] === true;\n  } else if (isBooleanLiteral(condition)) {\n    const value = Boolean(condition.true);\n    return () => value;\n  }\n  assertUnreachable();\n}\nfunction buildAlternatives(ctx, alternatives) {\n  if (alternatives.elements.length === 1) {\n    return buildElement(ctx, alternatives.elements[0]);\n  } else {\n    const methods = [];\n    for (const element of alternatives.elements) {\n      const predicatedMethod = {\n        // Since we handle the guard condition in the alternative already\n        // We can ignore the group guard condition inside\n        ALT: buildElement(ctx, element, true)\n      };\n      const guard = getGuardCondition(element);\n      if (guard) {\n        predicatedMethod.GATE = buildPredicate(guard);\n      }\n      methods.push(predicatedMethod);\n    }\n    const idx = ctx.or++;\n    return (args) => ctx.parser.alternatives(idx, methods.map((method) => {\n      const alt = {\n        ALT: () => method.ALT(args)\n      };\n      const gate = method.GATE;\n      if (gate) {\n        alt.GATE = () => gate(args);\n      }\n      return alt;\n    }));\n  }\n}\nfunction buildUnorderedGroup(ctx, group) {\n  if (group.elements.length === 1) {\n    return buildElement(ctx, group.elements[0]);\n  }\n  const methods = [];\n  for (const element of group.elements) {\n    const predicatedMethod = {\n      // Since we handle the guard condition in the alternative already\n      // We can ignore the group guard condition inside\n      ALT: buildElement(ctx, element, true)\n    };\n    const guard = getGuardCondition(element);\n    if (guard) {\n      predicatedMethod.GATE = buildPredicate(guard);\n    }\n    methods.push(predicatedMethod);\n  }\n  const orIdx = ctx.or++;\n  const idFunc = (groupIdx, lParser) => {\n    const stackId = lParser.getRuleStack().join(\"-\");\n    return `uGroup_${groupIdx}_${stackId}`;\n  };\n  const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n    const alt = { ALT: () => true };\n    const parser = ctx.parser;\n    alt.ALT = () => {\n      method.ALT(args);\n      if (!parser.isRecording()) {\n        const key = idFunc(orIdx, parser);\n        if (!parser.unorderedGroups.get(key)) {\n          parser.unorderedGroups.set(key, []);\n        }\n        const groupState = parser.unorderedGroups.get(key);\n        if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === \"undefined\") {\n          groupState[idx] = true;\n        }\n      }\n    };\n    const gate = method.GATE;\n    if (gate) {\n      alt.GATE = () => gate(args);\n    } else {\n      alt.GATE = () => {\n        const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n        const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n        return allow;\n      };\n    }\n    return alt;\n  }));\n  const wrapped = wrap(ctx, getGuardCondition(group), alternatives, \"*\");\n  return (args) => {\n    wrapped(args);\n    if (!ctx.parser.isRecording()) {\n      ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n    }\n  };\n}\nfunction buildGroup(ctx, group) {\n  const methods = group.elements.map((e) => buildElement(ctx, e));\n  return (args) => methods.forEach((method) => method(args));\n}\nfunction getGuardCondition(element) {\n  if (isGroup(element)) {\n    return element.guardCondition;\n  }\n  return void 0;\n}\nfunction buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {\n  if (!terminal) {\n    if (!crossRef.type.ref) {\n      throw new Error(\"Could not resolve reference to type: \" + crossRef.type.$refText);\n    }\n    const assignment = findNameAssignment(crossRef.type.ref);\n    const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n    if (!assignTerminal) {\n      throw new Error(\"Could not find name assignment for type: \" + getTypeName(crossRef.type.ref));\n    }\n    return buildCrossReference(ctx, crossRef, assignTerminal);\n  } else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\n    const rule = terminal.rule.ref;\n    const idx = ctx.subrule++;\n    return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);\n  } else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\n    const idx = ctx.consume++;\n    const terminalRule = getToken(ctx, terminal.rule.ref.name);\n    return () => ctx.parser.consume(idx, terminalRule, crossRef);\n  } else if (isKeyword(terminal)) {\n    const idx = ctx.consume++;\n    const keyword = getToken(ctx, terminal.value);\n    return () => ctx.parser.consume(idx, keyword, crossRef);\n  } else {\n    throw new Error(\"Could not build cross reference parser\");\n  }\n}\nfunction buildKeyword(ctx, keyword) {\n  const idx = ctx.consume++;\n  const token = ctx.tokens[keyword.value];\n  if (!token) {\n    throw new Error(\"Could not find token for keyword: \" + keyword.value);\n  }\n  return () => ctx.parser.consume(idx, token, keyword);\n}\nfunction wrap(ctx, guard, method, cardinality) {\n  const gate = guard && buildPredicate(guard);\n  if (!cardinality) {\n    if (gate) {\n      const idx = ctx.or++;\n      return (args) => ctx.parser.alternatives(idx, [\n        {\n          ALT: () => method(args),\n          GATE: () => gate(args)\n        },\n        {\n          ALT: EMPTY_ALT(),\n          GATE: () => !gate(args)\n        }\n      ]);\n    } else {\n      return method;\n    }\n  }\n  if (cardinality === \"*\") {\n    const idx = ctx.many++;\n    return (args) => ctx.parser.many(idx, {\n      DEF: () => method(args),\n      GATE: gate ? () => gate(args) : void 0\n    });\n  } else if (cardinality === \"+\") {\n    const idx = ctx.many++;\n    if (gate) {\n      const orIdx = ctx.or++;\n      return (args) => ctx.parser.alternatives(orIdx, [\n        {\n          ALT: () => ctx.parser.atLeastOne(idx, {\n            DEF: () => method(args)\n          }),\n          GATE: () => gate(args)\n        },\n        {\n          ALT: EMPTY_ALT(),\n          GATE: () => !gate(args)\n        }\n      ]);\n    } else {\n      return (args) => ctx.parser.atLeastOne(idx, {\n        DEF: () => method(args)\n      });\n    }\n  } else if (cardinality === \"?\") {\n    const idx = ctx.optional++;\n    return (args) => ctx.parser.optional(idx, {\n      DEF: () => method(args),\n      GATE: gate ? () => gate(args) : void 0\n    });\n  } else {\n    assertUnreachable();\n  }\n}\nfunction getRule(ctx, element) {\n  const name = getRuleName(ctx, element);\n  const rule = ctx.parser.getRule(name);\n  if (!rule)\n    throw new Error(`Rule \"${name}\" not found.\"`);\n  return rule;\n}\nfunction getRuleName(ctx, element) {\n  if (isParserRule(element)) {\n    return element.name;\n  } else if (ctx.ruleNames.has(element)) {\n    return ctx.ruleNames.get(element);\n  } else {\n    let item = element;\n    let parent = item.$container;\n    let ruleName = element.$type;\n    while (!isParserRule(parent)) {\n      if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\n        const index = parent.elements.indexOf(item);\n        ruleName = index.toString() + \":\" + ruleName;\n      }\n      item = parent;\n      parent = parent.$container;\n    }\n    const rule = parent;\n    ruleName = rule.name + \":\" + ruleName;\n    ctx.ruleNames.set(element, ruleName);\n    return ruleName;\n  }\n}\nfunction getToken(ctx, name) {\n  const token = ctx.tokens[name];\n  if (!token)\n    throw new Error(`Token \"${name}\" not found.\"`);\n  return token;\n}\nfunction createCompletionParser(services) {\n  const grammar = services.Grammar;\n  const lexer = services.parser.Lexer;\n  const parser = new LangiumCompletionParser(services);\n  createParser(grammar, parser, lexer.definition);\n  parser.finalize();\n  return parser;\n}\nfunction createLangiumParser(services) {\n  const parser = prepareLangiumParser(services);\n  parser.finalize();\n  return parser;\n}\nfunction prepareLangiumParser(services) {\n  const grammar = services.Grammar;\n  const lexer = services.parser.Lexer;\n  const parser = new LangiumParser(services);\n  return createParser(grammar, parser, lexer.definition);\n}\nclass DefaultTokenBuilder {\n  constructor() {\n    this.diagnostics = [];\n  }\n  buildTokens(grammar, options) {\n    const reachableRules = stream(getAllReachableRules(grammar, false));\n    const terminalTokens = this.buildTerminalTokens(reachableRules);\n    const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);\n    terminalTokens.forEach((terminalToken) => {\n      const pattern = terminalToken.PATTERN;\n      if (typeof pattern === \"object\" && pattern && \"test\" in pattern && isWhitespace(pattern)) {\n        tokens.unshift(terminalToken);\n      } else {\n        tokens.push(terminalToken);\n      }\n    });\n    return tokens;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  flushLexingReport(text) {\n    return { diagnostics: this.popDiagnostics() };\n  }\n  popDiagnostics() {\n    const diagnostics = [...this.diagnostics];\n    this.diagnostics = [];\n    return diagnostics;\n  }\n  buildTerminalTokens(rules) {\n    return rules.filter(isTerminalRule).filter((e) => !e.fragment).map((terminal) => this.buildTerminalToken(terminal)).toArray();\n  }\n  buildTerminalToken(terminal) {\n    const regex = terminalRegex(terminal);\n    const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\n    const tokenType = {\n      name: terminal.name,\n      PATTERN: pattern\n    };\n    if (typeof pattern === \"function\") {\n      tokenType.LINE_BREAKS = true;\n    }\n    if (terminal.hidden) {\n      tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : \"hidden\";\n    }\n    return tokenType;\n  }\n  requiresCustomPattern(regex) {\n    if (regex.flags.includes(\"u\") || regex.flags.includes(\"s\")) {\n      return true;\n    } else if (regex.source.includes(\"?<=\") || regex.source.includes(\"?<!\")) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  regexPatternFunction(regex) {\n    const stickyRegex = new RegExp(regex, regex.flags + \"y\");\n    return (text, offset) => {\n      stickyRegex.lastIndex = offset;\n      const execResult = stickyRegex.exec(text);\n      return execResult;\n    };\n  }\n  buildKeywordTokens(rules, terminalTokens, options) {\n    return rules.filter(isParserRule).flatMap((rule) => streamAllContents(rule).filter(isKeyword)).distinct((e) => e.value).toArray().sort((a, b) => b.value.length - a.value.length).map((keyword) => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));\n  }\n  buildKeywordToken(keyword, terminalTokens, caseInsensitive) {\n    const keywordPattern = this.buildKeywordPattern(keyword, caseInsensitive);\n    const tokenType = {\n      name: keyword.value,\n      PATTERN: keywordPattern,\n      LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\n    };\n    if (typeof keywordPattern === \"function\") {\n      tokenType.LINE_BREAKS = true;\n    }\n    return tokenType;\n  }\n  buildKeywordPattern(keyword, caseInsensitive) {\n    return caseInsensitive ? new RegExp(getCaseInsensitivePattern(keyword.value)) : keyword.value;\n  }\n  findLongerAlt(keyword, terminalTokens) {\n    return terminalTokens.reduce((longerAlts, token) => {\n      const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;\n      if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && partialMatches(\"^\" + pattern.source + \"$\", keyword.value)) {\n        longerAlts.push(token);\n      }\n      return longerAlts;\n    }, []);\n  }\n}\nclass DefaultValueConverter {\n  convert(input, cstNode) {\n    let feature = cstNode.grammarSource;\n    if (isCrossReference(feature)) {\n      feature = getCrossReferenceTerminal(feature);\n    }\n    if (isRuleCall(feature)) {\n      const rule = feature.rule.ref;\n      if (!rule) {\n        throw new Error(\"This cst node was not parsed by a rule.\");\n      }\n      return this.runConverter(rule, input, cstNode);\n    }\n    return input;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  runConverter(rule, input, cstNode) {\n    var _a2;\n    switch (rule.name.toUpperCase()) {\n      case \"INT\":\n        return ValueConverter.convertInt(input);\n      case \"STRING\":\n        return ValueConverter.convertString(input);\n      case \"ID\":\n        return ValueConverter.convertID(input);\n    }\n    switch ((_a2 = getRuleType(rule)) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) {\n      case \"number\":\n        return ValueConverter.convertNumber(input);\n      case \"boolean\":\n        return ValueConverter.convertBoolean(input);\n      case \"bigint\":\n        return ValueConverter.convertBigint(input);\n      case \"date\":\n        return ValueConverter.convertDate(input);\n      default:\n        return input;\n    }\n  }\n}\nvar ValueConverter;\n(function(ValueConverter2) {\n  function convertString(input) {\n    let result = \"\";\n    for (let i = 1; i < input.length - 1; i++) {\n      const c = input.charAt(i);\n      if (c === \"\\\\\") {\n        const c1 = input.charAt(++i);\n        result += convertEscapeCharacter(c1);\n      } else {\n        result += c;\n      }\n    }\n    return result;\n  }\n  ValueConverter2.convertString = convertString;\n  function convertEscapeCharacter(char) {\n    switch (char) {\n      case \"b\":\n        return \"\\b\";\n      case \"f\":\n        return \"\\f\";\n      case \"n\":\n        return \"\\n\";\n      case \"r\":\n        return \"\\r\";\n      case \"t\":\n        return \"\t\";\n      case \"v\":\n        return \"\\v\";\n      case \"0\":\n        return \"\\0\";\n      default:\n        return char;\n    }\n  }\n  function convertID(input) {\n    if (input.charAt(0) === \"^\") {\n      return input.substring(1);\n    } else {\n      return input;\n    }\n  }\n  ValueConverter2.convertID = convertID;\n  function convertInt(input) {\n    return parseInt(input);\n  }\n  ValueConverter2.convertInt = convertInt;\n  function convertBigint(input) {\n    return BigInt(input);\n  }\n  ValueConverter2.convertBigint = convertBigint;\n  function convertDate(input) {\n    return new Date(input);\n  }\n  ValueConverter2.convertDate = convertDate;\n  function convertNumber(input) {\n    return Number(input);\n  }\n  ValueConverter2.convertNumber = convertNumber;\n  function convertBoolean(input) {\n    return input.toLowerCase() === \"true\";\n  }\n  ValueConverter2.convertBoolean = convertBoolean;\n})(ValueConverter || (ValueConverter = {}));\nvar cancellation = {};\nvar ral = {};\nvar hasRequiredRal;\nfunction requireRal() {\n  if (hasRequiredRal) return ral;\n  hasRequiredRal = 1;\n  Object.defineProperty(ral, \"__esModule\", { value: true });\n  let _ral;\n  function RAL() {\n    if (_ral === void 0) {\n      throw new Error(`No runtime abstraction layer installed`);\n    }\n    return _ral;\n  }\n  (function(RAL2) {\n    function install(ral2) {\n      if (ral2 === void 0) {\n        throw new Error(`No runtime abstraction layer provided`);\n      }\n      _ral = ral2;\n    }\n    RAL2.install = install;\n  })(RAL || (RAL = {}));\n  ral.default = RAL;\n  return ral;\n}\nvar is = {};\nvar hasRequiredIs;\nfunction requireIs() {\n  if (hasRequiredIs) return is;\n  hasRequiredIs = 1;\n  Object.defineProperty(is, \"__esModule\", { value: true });\n  is.stringArray = is.array = is.func = is.error = is.number = is.string = is.boolean = void 0;\n  function boolean(value) {\n    return value === true || value === false;\n  }\n  is.boolean = boolean;\n  function string(value) {\n    return typeof value === \"string\" || value instanceof String;\n  }\n  is.string = string;\n  function number(value) {\n    return typeof value === \"number\" || value instanceof Number;\n  }\n  is.number = number;\n  function error(value) {\n    return value instanceof Error;\n  }\n  is.error = error;\n  function func(value) {\n    return typeof value === \"function\";\n  }\n  is.func = func;\n  function array(value) {\n    return Array.isArray(value);\n  }\n  is.array = array;\n  function stringArray(value) {\n    return array(value) && value.every((elem) => string(elem));\n  }\n  is.stringArray = stringArray;\n  return is;\n}\nvar events = {};\nvar hasRequiredEvents;\nfunction requireEvents() {\n  if (hasRequiredEvents) return events;\n  hasRequiredEvents = 1;\n  Object.defineProperty(events, \"__esModule\", { value: true });\n  events.Emitter = events.Event = void 0;\n  const ral_1 = requireRal();\n  var Event;\n  (function(Event2) {\n    const _disposable = { dispose() {\n    } };\n    Event2.None = function() {\n      return _disposable;\n    };\n  })(Event || (events.Event = Event = {}));\n  class CallbackList {\n    add(callback, context = null, bucket) {\n      if (!this._callbacks) {\n        this._callbacks = [];\n        this._contexts = [];\n      }\n      this._callbacks.push(callback);\n      this._contexts.push(context);\n      if (Array.isArray(bucket)) {\n        bucket.push({ dispose: () => this.remove(callback, context) });\n      }\n    }\n    remove(callback, context = null) {\n      if (!this._callbacks) {\n        return;\n      }\n      let foundCallbackWithDifferentContext = false;\n      for (let i = 0, len = this._callbacks.length; i < len; i++) {\n        if (this._callbacks[i] === callback) {\n          if (this._contexts[i] === context) {\n            this._callbacks.splice(i, 1);\n            this._contexts.splice(i, 1);\n            return;\n          } else {\n            foundCallbackWithDifferentContext = true;\n          }\n        }\n      }\n      if (foundCallbackWithDifferentContext) {\n        throw new Error(\"When adding a listener with a context, you should remove it with the same context\");\n      }\n    }\n    invoke(...args) {\n      if (!this._callbacks) {\n        return [];\n      }\n      const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n      for (let i = 0, len = callbacks.length; i < len; i++) {\n        try {\n          ret.push(callbacks[i].apply(contexts[i], args));\n        } catch (e) {\n          (0, ral_1.default)().console.error(e);\n        }\n      }\n      return ret;\n    }\n    isEmpty() {\n      return !this._callbacks || this._callbacks.length === 0;\n    }\n    dispose() {\n      this._callbacks = void 0;\n      this._contexts = void 0;\n    }\n  }\n  class Emitter {\n    constructor(_options) {\n      this._options = _options;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n      if (!this._event) {\n        this._event = (listener, thisArgs, disposables) => {\n          if (!this._callbacks) {\n            this._callbacks = new CallbackList();\n          }\n          if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n            this._options.onFirstListenerAdd(this);\n          }\n          this._callbacks.add(listener, thisArgs);\n          const result = {\n            dispose: () => {\n              if (!this._callbacks) {\n                return;\n              }\n              this._callbacks.remove(listener, thisArgs);\n              result.dispose = Emitter._noop;\n              if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                this._options.onLastListenerRemove(this);\n              }\n            }\n          };\n          if (Array.isArray(disposables)) {\n            disposables.push(result);\n          }\n          return result;\n        };\n      }\n      return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n      if (this._callbacks) {\n        this._callbacks.invoke.call(this._callbacks, event);\n      }\n    }\n    dispose() {\n      if (this._callbacks) {\n        this._callbacks.dispose();\n        this._callbacks = void 0;\n      }\n    }\n  }\n  events.Emitter = Emitter;\n  Emitter._noop = function() {\n  };\n  return events;\n}\nvar hasRequiredCancellation;\nfunction requireCancellation() {\n  if (hasRequiredCancellation) return cancellation;\n  hasRequiredCancellation = 1;\n  Object.defineProperty(cancellation, \"__esModule\", { value: true });\n  cancellation.CancellationTokenSource = cancellation.CancellationToken = void 0;\n  const ral_1 = requireRal();\n  const Is2 = requireIs();\n  const events_1 = requireEvents();\n  var CancellationToken;\n  (function(CancellationToken2) {\n    CancellationToken2.None = Object.freeze({\n      isCancellationRequested: false,\n      onCancellationRequested: events_1.Event.None\n    });\n    CancellationToken2.Cancelled = Object.freeze({\n      isCancellationRequested: true,\n      onCancellationRequested: events_1.Event.None\n    });\n    function is2(value) {\n      const candidate = value;\n      return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);\n    }\n    CancellationToken2.is = is2;\n  })(CancellationToken || (cancellation.CancellationToken = CancellationToken = {}));\n  const shortcutEvent = Object.freeze(function(callback, context) {\n    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n    return { dispose() {\n      handle.dispose();\n    } };\n  });\n  class MutableToken {\n    constructor() {\n      this._isCancelled = false;\n    }\n    cancel() {\n      if (!this._isCancelled) {\n        this._isCancelled = true;\n        if (this._emitter) {\n          this._emitter.fire(void 0);\n          this.dispose();\n        }\n      }\n    }\n    get isCancellationRequested() {\n      return this._isCancelled;\n    }\n    get onCancellationRequested() {\n      if (this._isCancelled) {\n        return shortcutEvent;\n      }\n      if (!this._emitter) {\n        this._emitter = new events_1.Emitter();\n      }\n      return this._emitter.event;\n    }\n    dispose() {\n      if (this._emitter) {\n        this._emitter.dispose();\n        this._emitter = void 0;\n      }\n    }\n  }\n  class CancellationTokenSource {\n    get token() {\n      if (!this._token) {\n        this._token = new MutableToken();\n      }\n      return this._token;\n    }\n    cancel() {\n      if (!this._token) {\n        this._token = CancellationToken.Cancelled;\n      } else {\n        this._token.cancel();\n      }\n    }\n    dispose() {\n      if (!this._token) {\n        this._token = CancellationToken.None;\n      } else if (this._token instanceof MutableToken) {\n        this._token.dispose();\n      }\n    }\n  }\n  cancellation.CancellationTokenSource = CancellationTokenSource;\n  return cancellation;\n}\nvar cancellationExports = requireCancellation();\nfunction delayNextTick() {\n  return new Promise((resolve) => {\n    if (typeof setImmediate === \"undefined\") {\n      setTimeout(resolve, 0);\n    } else {\n      setImmediate(resolve);\n    }\n  });\n}\nlet lastTick = 0;\nlet globalInterruptionPeriod = 10;\nfunction startCancelableOperation() {\n  lastTick = performance.now();\n  return new cancellationExports.CancellationTokenSource();\n}\nconst OperationCancelled = Symbol(\"OperationCancelled\");\nfunction isOperationCancelled(err) {\n  return err === OperationCancelled;\n}\nasync function interruptAndCheck(token) {\n  if (token === cancellationExports.CancellationToken.None) {\n    return;\n  }\n  const current = performance.now();\n  if (current - lastTick >= globalInterruptionPeriod) {\n    lastTick = current;\n    await delayNextTick();\n    lastTick = performance.now();\n  }\n  if (token.isCancellationRequested) {\n    throw OperationCancelled;\n  }\n}\nclass Deferred {\n  constructor() {\n    this.promise = new Promise((resolve, reject2) => {\n      this.resolve = (arg) => {\n        resolve(arg);\n        return this;\n      };\n      this.reject = (err) => {\n        reject2(err);\n        return this;\n      };\n    });\n  }\n}\nclass FullTextDocument2 {\n  constructor(uri, languageId, version, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version;\n    this._content = content;\n    this._lineOffsets = void 0;\n  }\n  get uri() {\n    return this._uri;\n  }\n  get languageId() {\n    return this._languageId;\n  }\n  get version() {\n    return this._version;\n  }\n  getText(range) {\n    if (range) {\n      const start = this.offsetAt(range.start);\n      const end = this.offsetAt(range.end);\n      return this._content.substring(start, end);\n    }\n    return this._content;\n  }\n  update(changes, version) {\n    for (const change of changes) {\n      if (FullTextDocument2.isIncremental(change)) {\n        const range = getWellformedRange(change.range);\n        const startOffset = this.offsetAt(range.start);\n        const endOffset = this.offsetAt(range.end);\n        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n        const startLine = Math.max(range.start.line, 0);\n        const endLine = Math.max(range.end.line, 0);\n        let lineOffsets = this._lineOffsets;\n        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n        if (endLine - startLine === addedLineOffsets.length) {\n          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\n            lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n          }\n        } else {\n          if (addedLineOffsets.length < 1e4) {\n            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n          } else {\n            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n          }\n        }\n        const diff = change.text.length - (endOffset - startOffset);\n        if (diff !== 0) {\n          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n            lineOffsets[i] = lineOffsets[i] + diff;\n          }\n        }\n      } else if (FullTextDocument2.isFull(change)) {\n        this._content = change.text;\n        this._lineOffsets = void 0;\n      } else {\n        throw new Error(\"Unknown change event received\");\n      }\n    }\n    this._version = version;\n  }\n  getLineOffsets() {\n    if (this._lineOffsets === void 0) {\n      this._lineOffsets = computeLineOffsets(this._content, true);\n    }\n    return this._lineOffsets;\n  }\n  positionAt(offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    const lineOffsets = this.getLineOffsets();\n    let low = 0, high = lineOffsets.length;\n    if (high === 0) {\n      return { line: 0, character: offset };\n    }\n    while (low < high) {\n      const mid = Math.floor((low + high) / 2);\n      if (lineOffsets[mid] > offset) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    const line = low - 1;\n    offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n    return { line, character: offset - lineOffsets[line] };\n  }\n  offsetAt(position) {\n    const lineOffsets = this.getLineOffsets();\n    if (position.line >= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line < 0) {\n      return 0;\n    }\n    const lineOffset = lineOffsets[position.line];\n    if (position.character <= 0) {\n      return lineOffset;\n    }\n    const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    const offset = Math.min(lineOffset + position.character, nextLineOffset);\n    return this.ensureBeforeEOL(offset, lineOffset);\n  }\n  ensureBeforeEOL(offset, lineOffset) {\n    while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {\n      offset--;\n    }\n    return offset;\n  }\n  get lineCount() {\n    return this.getLineOffsets().length;\n  }\n  static isIncremental(event) {\n    const candidate = event;\n    return candidate !== void 0 && candidate !== null && typeof candidate.text === \"string\" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === \"number\");\n  }\n  static isFull(event) {\n    const candidate = event;\n    return candidate !== void 0 && candidate !== null && typeof candidate.text === \"string\" && candidate.range === void 0 && candidate.rangeLength === void 0;\n  }\n}\nvar TextDocument;\n(function(TextDocument2) {\n  function create(uri, languageId, version, content) {\n    return new FullTextDocument2(uri, languageId, version, content);\n  }\n  TextDocument2.create = create;\n  function update(document, changes, version) {\n    if (document instanceof FullTextDocument2) {\n      document.update(changes, version);\n      return document;\n    } else {\n      throw new Error(\"TextDocument.update: document must be created by TextDocument.create\");\n    }\n  }\n  TextDocument2.update = update;\n  function applyEdits(document, edits) {\n    const text = document.getText();\n    const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\n      const diff = a.range.start.line - b.range.start.line;\n      if (diff === 0) {\n        return a.range.start.character - b.range.start.character;\n      }\n      return diff;\n    });\n    let lastModifiedOffset = 0;\n    const spans = [];\n    for (const e of sortedEdits) {\n      const startOffset = document.offsetAt(e.range.start);\n      if (startOffset < lastModifiedOffset) {\n        throw new Error(\"Overlapping edit\");\n      } else if (startOffset > lastModifiedOffset) {\n        spans.push(text.substring(lastModifiedOffset, startOffset));\n      }\n      if (e.newText.length) {\n        spans.push(e.newText);\n      }\n      lastModifiedOffset = document.offsetAt(e.range.end);\n    }\n    spans.push(text.substr(lastModifiedOffset));\n    return spans.join(\"\");\n  }\n  TextDocument2.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n  if (data.length <= 1) {\n    return data;\n  }\n  const p = data.length / 2 | 0;\n  const left = data.slice(0, p);\n  const right = data.slice(p);\n  mergeSort(left, compare);\n  mergeSort(right, compare);\n  let leftIdx = 0;\n  let rightIdx = 0;\n  let i = 0;\n  while (leftIdx < left.length && rightIdx < right.length) {\n    const ret = compare(left[leftIdx], right[rightIdx]);\n    if (ret <= 0) {\n      data[i++] = left[leftIdx++];\n    } else {\n      data[i++] = right[rightIdx++];\n    }\n  }\n  while (leftIdx < left.length) {\n    data[i++] = left[leftIdx++];\n  }\n  while (rightIdx < right.length) {\n    data[i++] = right[rightIdx++];\n  }\n  return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n  const result = isAtLineStart ? [textOffset] : [];\n  for (let i = 0; i < text.length; i++) {\n    const ch = text.charCodeAt(i);\n    if (isEOL(ch)) {\n      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {\n        i++;\n      }\n      result.push(textOffset + i + 1);\n    }\n  }\n  return result;\n}\nfunction isEOL(char) {\n  return char === 13 || char === 10;\n}\nfunction getWellformedRange(range) {\n  const start = range.start;\n  const end = range.end;\n  if (start.line > end.line || start.line === end.line && start.character > end.character) {\n    return { start: end, end: start };\n  }\n  return range;\n}\nfunction getWellformedEdit(textEdit) {\n  const range = getWellformedRange(textEdit.range);\n  if (range !== textEdit.range) {\n    return { newText: textEdit.newText, range };\n  }\n  return textEdit;\n}\nvar LIB;\n(() => {\n  var t = { 470: (t2) => {\n    function e2(t3) {\n      if (\"string\" != typeof t3) throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(t3));\n    }\n    function r2(t3, e3) {\n      for (var r3, n3 = \"\", i = 0, o = -1, s = 0, h = 0; h <= t3.length; ++h) {\n        if (h < t3.length) r3 = t3.charCodeAt(h);\n        else {\n          if (47 === r3) break;\n          r3 = 47;\n        }\n        if (47 === r3) {\n          if (o === h - 1 || 1 === s) ;\n          else if (o !== h - 1 && 2 === s) {\n            if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {\n              if (n3.length > 2) {\n                var a = n3.lastIndexOf(\"/\");\n                if (a !== n3.length - 1) {\n                  -1 === a ? (n3 = \"\", i = 0) : i = (n3 = n3.slice(0, a)).length - 1 - n3.lastIndexOf(\"/\"), o = h, s = 0;\n                  continue;\n                }\n              } else if (2 === n3.length || 1 === n3.length) {\n                n3 = \"\", i = 0, o = h, s = 0;\n                continue;\n              }\n            }\n            e3 && (n3.length > 0 ? n3 += \"/..\" : n3 = \"..\", i = 2);\n          } else n3.length > 0 ? n3 += \"/\" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;\n          o = h, s = 0;\n        } else 46 === r3 && -1 !== s ? ++s : s = -1;\n      }\n      return n3;\n    }\n    var n2 = { resolve: function() {\n      for (var t3, n3 = \"\", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {\n        var s;\n        o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + \"/\" + n3, i = 47 === s.charCodeAt(0));\n      }\n      return n3 = r2(n3, !i), i ? n3.length > 0 ? \"/\" + n3 : \"/\" : n3.length > 0 ? n3 : \".\";\n    }, normalize: function(t3) {\n      if (e2(t3), 0 === t3.length) return \".\";\n      var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);\n      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = \".\"), t3.length > 0 && i && (t3 += \"/\"), n3 ? \"/\" + t3 : t3;\n    }, isAbsolute: function(t3) {\n      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);\n    }, join: function() {\n      if (0 === arguments.length) return \".\";\n      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {\n        var i = arguments[r3];\n        e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += \"/\" + i);\n      }\n      return void 0 === t3 ? \".\" : n2.normalize(t3);\n    }, relative: function(t3, r3) {\n      if (e2(t3), e2(r3), t3 === r3) return \"\";\n      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return \"\";\n      for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i) ;\n      for (var o = t3.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h) ;\n      for (var a = r3.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u) {\n        if (u === c) {\n          if (a > c) {\n            if (47 === r3.charCodeAt(h + u)) return r3.slice(h + u + 1);\n            if (0 === u) return r3.slice(h + u);\n          } else s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));\n          break;\n        }\n        var l = t3.charCodeAt(i + u);\n        if (l !== r3.charCodeAt(h + u)) break;\n        47 === l && (f = u);\n      }\n      var g = \"\";\n      for (u = i + f + 1; u <= o; ++u) u !== o && 47 !== t3.charCodeAt(u) || (0 === g.length ? g += \"..\" : g += \"/..\");\n      return g.length > 0 ? g + r3.slice(h + f) : (h += f, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));\n    }, _makeLong: function(t3) {\n      return t3;\n    }, dirname: function(t3) {\n      if (e2(t3), 0 === t3.length) return \".\";\n      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s) if (47 === (r3 = t3.charCodeAt(s))) {\n        if (!o) {\n          i = s;\n          break;\n        }\n      } else o = false;\n      return -1 === i ? n3 ? \"/\" : \".\" : n3 && 1 === i ? \"//\" : t3.slice(0, i);\n    }, basename: function(t3, r3) {\n      if (void 0 !== r3 && \"string\" != typeof r3) throw new TypeError('\"ext\" argument must be a string');\n      e2(t3);\n      var n3, i = 0, o = -1, s = true;\n      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {\n        if (r3.length === t3.length && r3 === t3) return \"\";\n        var h = r3.length - 1, a = -1;\n        for (n3 = t3.length - 1; n3 >= 0; --n3) {\n          var c = t3.charCodeAt(n3);\n          if (47 === c) {\n            if (!s) {\n              i = n3 + 1;\n              break;\n            }\n          } else -1 === a && (s = false, a = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a));\n        }\n        return i === o ? o = a : -1 === o && (o = t3.length), t3.slice(i, o);\n      }\n      for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {\n        if (!s) {\n          i = n3 + 1;\n          break;\n        }\n      } else -1 === o && (s = false, o = n3 + 1);\n      return -1 === o ? \"\" : t3.slice(i, o);\n    }, extname: function(t3) {\n      e2(t3);\n      for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1; h >= 0; --h) {\n        var a = t3.charCodeAt(h);\n        if (47 !== a) -1 === i && (o = false, i = h + 1), 46 === a ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);\n        else if (!o) {\n          n3 = h + 1;\n          break;\n        }\n      }\n      return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? \"\" : t3.slice(r3, i);\n    }, format: function(t3) {\n      if (null === t3 || \"object\" != typeof t3) throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof t3);\n      return function(t4, e3) {\n        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || \"\") + (e3.ext || \"\");\n        return r3 ? r3 === e3.root ? r3 + n3 : r3 + \"/\" + n3 : n3;\n      }(0, t3);\n    }, parse: function(t3) {\n      e2(t3);\n      var r3 = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n      if (0 === t3.length) return r3;\n      var n3, i = t3.charCodeAt(0), o = 47 === i;\n      o ? (r3.root = \"/\", n3 = 1) : n3 = 0;\n      for (var s = -1, h = 0, a = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f) if (47 !== (i = t3.charCodeAt(f))) -1 === a && (c = false, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);\n      else if (!c) {\n        h = f + 1;\n        break;\n      }\n      return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r3.base = r3.name = 0 === h && o ? t3.slice(1, a) : t3.slice(h, a)) : (0 === h && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a)), r3.ext = t3.slice(s, a)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = \"/\"), r3;\n    }, sep: \"/\", delimiter: \":\", win32: null, posix: null };\n    n2.posix = n2, t2.exports = n2;\n  } }, e = {};\n  function r(n2) {\n    var i = e[n2];\n    if (void 0 !== i) return i.exports;\n    var o = e[n2] = { exports: {} };\n    return t[n2](o, o.exports, r), o.exports;\n  }\n  r.d = (t2, e2) => {\n    for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });\n  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(t2, \"__esModule\", { value: true });\n  };\n  var n = {};\n  (() => {\n    let t2;\n    if (r.r(n), r.d(n, { URI: () => f, Utils: () => P }), \"object\" == typeof process) t2 = \"win32\" === process.platform;\n    else if (\"object\" == typeof navigator) {\n      let e3 = navigator.userAgent;\n      t2 = e3.indexOf(\"Windows\") >= 0;\n    }\n    const e2 = /^\\w[\\w\\d+.-]*$/, i = /^\\//, o = /^\\/\\//;\n    function s(t3, r2) {\n      if (!t3.scheme && r2) throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${t3.authority}\", path: \"${t3.path}\", query: \"${t3.query}\", fragment: \"${t3.fragment}\"}`);\n      if (t3.scheme && !e2.test(t3.scheme)) throw new Error(\"[UriError]: Scheme contains illegal characters.\");\n      if (t3.path) {\n        if (t3.authority) {\n          if (!i.test(t3.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n        } else if (o.test(t3.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n      }\n    }\n    const h = \"\", a = \"/\", c = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n    class f {\n      constructor(t3, e3, r2, n2, i2, o2 = false) {\n        __publicField(this, \"scheme\");\n        __publicField(this, \"authority\");\n        __publicField(this, \"path\");\n        __publicField(this, \"query\");\n        __publicField(this, \"fragment\");\n        \"object\" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ function(t4, e4) {\n          return t4 || e4 ? t4 : \"file\";\n        }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {\n          switch (t4) {\n            case \"https\":\n            case \"http\":\n            case \"file\":\n              e4 ? e4[0] !== a && (e4 = a + e4) : e4 = a;\n          }\n          return e4;\n        }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));\n      }\n      static isUri(t3) {\n        return t3 instanceof f || !!t3 && \"string\" == typeof t3.authority && \"string\" == typeof t3.fragment && \"string\" == typeof t3.path && \"string\" == typeof t3.query && \"string\" == typeof t3.scheme && \"string\" == typeof t3.fsPath && \"function\" == typeof t3.with && \"function\" == typeof t3.toString;\n      }\n      get fsPath() {\n        return m(this);\n      }\n      with(t3) {\n        if (!t3) return this;\n        let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;\n        return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);\n      }\n      static parse(t3, e3 = false) {\n        const r2 = c.exec(t3);\n        return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);\n      }\n      static file(e3) {\n        let r2 = h;\n        if (t2 && (e3 = e3.replace(/\\\\/g, a)), e3[0] === a && e3[1] === a) {\n          const t3 = e3.indexOf(a, 2);\n          -1 === t3 ? (r2 = e3.substring(2), e3 = a) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a);\n        }\n        return new l(\"file\", r2, e3, h, h);\n      }\n      static from(t3) {\n        const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);\n        return s(e3, true), e3;\n      }\n      toString(t3 = false) {\n        return y(this, t3);\n      }\n      toJSON() {\n        return this;\n      }\n      static revive(t3) {\n        if (t3) {\n          if (t3 instanceof f) return t3;\n          {\n            const e3 = new l(t3);\n            return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;\n          }\n        }\n        return t3;\n      }\n    }\n    const u = t2 ? 1 : void 0;\n    class l extends f {\n      constructor() {\n        super(...arguments);\n        __publicField(this, \"_formatted\", null);\n        __publicField(this, \"_fsPath\", null);\n      }\n      get fsPath() {\n        return this._fsPath || (this._fsPath = m(this)), this._fsPath;\n      }\n      toString(t3 = false) {\n        return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);\n      }\n      toJSON() {\n        const t3 = { $mid: 1 };\n        return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;\n      }\n    }\n    const g = { 58: \"%3A\", 47: \"%2F\", 63: \"%3F\", 35: \"%23\", 91: \"%5B\", 93: \"%5D\", 64: \"%40\", 33: \"%21\", 36: \"%24\", 38: \"%26\", 39: \"%27\", 40: \"%28\", 41: \"%29\", 42: \"%2A\", 43: \"%2B\", 44: \"%2C\", 59: \"%3B\", 61: \"%3D\", 32: \"%20\" };\n    function d(t3, e3, r2) {\n      let n2, i2 = -1;\n      for (let o2 = 0; o2 < t3.length; o2++) {\n        const s2 = t3.charCodeAt(o2);\n        if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t3.charAt(o2));\n        else {\n          void 0 === n2 && (n2 = t3.substr(0, o2));\n          const e4 = g[s2];\n          void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);\n        }\n      }\n      return -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2))), void 0 !== n2 ? n2 : t3;\n    }\n    function p(t3) {\n      let e3;\n      for (let r2 = 0; r2 < t3.length; r2++) {\n        const n2 = t3.charCodeAt(r2);\n        35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t3[r2]);\n      }\n      return void 0 !== e3 ? e3 : t3;\n    }\n    function m(e3, r2) {\n      let n2;\n      return n2 = e3.authority && e3.path.length > 1 && \"file\" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\\//g, \"\\\\\")), n2;\n    }\n    function y(t3, e3) {\n      const r2 = e3 ? p : d;\n      let n2 = \"\", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;\n      if (i2 && (n2 += i2, n2 += \":\"), (o2 || \"file\" === i2) && (n2 += a, n2 += a), o2) {\n        let t4 = o2.indexOf(\"@\");\n        if (-1 !== t4) {\n          const e4 = o2.substr(0, t4);\n          o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(\":\"), -1 === t4 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += \":\", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += \"@\";\n        }\n        o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(\":\"), -1 === t4 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));\n      }\n      if (s2) {\n        if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {\n          const t4 = s2.charCodeAt(1);\n          t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);\n        } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {\n          const t4 = s2.charCodeAt(0);\n          t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);\n        }\n        n2 += r2(s2, true, false);\n      }\n      return h2 && (n2 += \"?\", n2 += r2(h2, false, false)), c2 && (n2 += \"#\", n2 += e3 ? c2 : d(c2, false, false)), n2;\n    }\n    function v(t3) {\n      try {\n        return decodeURIComponent(t3);\n      } catch {\n        return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;\n      }\n    }\n    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n    function C(t3) {\n      return t3.match(b) ? t3.replace(b, (t4) => v(t4)) : t3;\n    }\n    var A = r(470);\n    const w = A.posix || A, x = \"/\";\n    var P;\n    !function(t3) {\n      t3.joinPath = function(t4, ...e3) {\n        return t4.with({ path: w.join(t4.path, ...e3) });\n      }, t3.resolvePath = function(t4, ...e3) {\n        let r2 = t4.path, n2 = false;\n        r2[0] !== x && (r2 = x + r2, n2 = true);\n        let i2 = w.resolve(r2, ...e3);\n        return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });\n      }, t3.dirname = function(t4) {\n        if (0 === t4.path.length || t4.path === x) return t4;\n        let e3 = w.dirname(t4.path);\n        return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = \"\"), t4.with({ path: e3 });\n      }, t3.basename = function(t4) {\n        return w.basename(t4.path);\n      }, t3.extname = function(t4) {\n        return w.extname(t4.path);\n      };\n    }(P || (P = {}));\n  })(), LIB = n;\n})();\nconst { URI, Utils } = LIB;\nvar UriUtils;\n(function(UriUtils2) {\n  UriUtils2.basename = Utils.basename;\n  UriUtils2.dirname = Utils.dirname;\n  UriUtils2.extname = Utils.extname;\n  UriUtils2.joinPath = Utils.joinPath;\n  UriUtils2.resolvePath = Utils.resolvePath;\n  function equals(a, b) {\n    return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());\n  }\n  UriUtils2.equals = equals;\n  function relative(from, to) {\n    const fromPath = typeof from === \"string\" ? from : from.path;\n    const toPath = typeof to === \"string\" ? to : to.path;\n    const fromParts = fromPath.split(\"/\").filter((e) => e.length > 0);\n    const toParts = toPath.split(\"/\").filter((e) => e.length > 0);\n    let i = 0;\n    for (; i < fromParts.length; i++) {\n      if (fromParts[i] !== toParts[i]) {\n        break;\n      }\n    }\n    const backPart = \"../\".repeat(fromParts.length - i);\n    const toPart = toParts.slice(i).join(\"/\");\n    return backPart + toPart;\n  }\n  UriUtils2.relative = relative;\n  function normalize(uri) {\n    return URI.parse(uri.toString()).toString();\n  }\n  UriUtils2.normalize = normalize;\n})(UriUtils || (UriUtils = {}));\nvar DocumentState;\n(function(DocumentState2) {\n  DocumentState2[DocumentState2[\"Changed\"] = 0] = \"Changed\";\n  DocumentState2[DocumentState2[\"Parsed\"] = 1] = \"Parsed\";\n  DocumentState2[DocumentState2[\"IndexedContent\"] = 2] = \"IndexedContent\";\n  DocumentState2[DocumentState2[\"ComputedScopes\"] = 3] = \"ComputedScopes\";\n  DocumentState2[DocumentState2[\"Linked\"] = 4] = \"Linked\";\n  DocumentState2[DocumentState2[\"IndexedReferences\"] = 5] = \"IndexedReferences\";\n  DocumentState2[DocumentState2[\"Validated\"] = 6] = \"Validated\";\n})(DocumentState || (DocumentState = {}));\nclass DefaultLangiumDocumentFactory {\n  constructor(services) {\n    this.serviceRegistry = services.ServiceRegistry;\n    this.textDocuments = services.workspace.TextDocuments;\n    this.fileSystemProvider = services.workspace.FileSystemProvider;\n  }\n  async fromUri(uri, cancellationToken = cancellationExports.CancellationToken.None) {\n    const content = await this.fileSystemProvider.readFile(uri);\n    return this.createAsync(uri, content, cancellationToken);\n  }\n  fromTextDocument(textDocument, uri, token) {\n    uri = uri !== null && uri !== void 0 ? uri : URI.parse(textDocument.uri);\n    if (cancellationExports.CancellationToken.is(token)) {\n      return this.createAsync(uri, textDocument, token);\n    } else {\n      return this.create(uri, textDocument, token);\n    }\n  }\n  fromString(text, uri, token) {\n    if (cancellationExports.CancellationToken.is(token)) {\n      return this.createAsync(uri, text, token);\n    } else {\n      return this.create(uri, text, token);\n    }\n  }\n  fromModel(model, uri) {\n    return this.create(uri, { $model: model });\n  }\n  create(uri, content, options) {\n    if (typeof content === \"string\") {\n      const parseResult = this.parse(uri, content, options);\n      return this.createLangiumDocument(parseResult, uri, void 0, content);\n    } else if (\"$model\" in content) {\n      const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\n      return this.createLangiumDocument(parseResult, uri);\n    } else {\n      const parseResult = this.parse(uri, content.getText(), options);\n      return this.createLangiumDocument(parseResult, uri, content);\n    }\n  }\n  async createAsync(uri, content, cancelToken) {\n    if (typeof content === \"string\") {\n      const parseResult = await this.parseAsync(uri, content, cancelToken);\n      return this.createLangiumDocument(parseResult, uri, void 0, content);\n    } else {\n      const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);\n      return this.createLangiumDocument(parseResult, uri, content);\n    }\n  }\n  /**\n   * Create a LangiumDocument from a given parse result.\n   *\n   * A TextDocument is created on demand if it is not provided as argument here. Usually this\n   * should not be necessary because the main purpose of the TextDocument is to convert between\n   * text ranges and offsets, which is done solely in LSP request handling.\n   *\n   * With the introduction of {@link update} below this method is supposed to be mainly called\n   * during workspace initialization and on addition/recognition of new files, while changes in\n   * existing documents are processed via {@link update}.\n   */\n  createLangiumDocument(parseResult, uri, textDocument, text) {\n    let document;\n    if (textDocument) {\n      document = {\n        parseResult,\n        uri,\n        state: DocumentState.Parsed,\n        references: [],\n        textDocument\n      };\n    } else {\n      const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n      document = {\n        parseResult,\n        uri,\n        state: DocumentState.Parsed,\n        references: [],\n        get textDocument() {\n          return textDocumentGetter();\n        }\n      };\n    }\n    parseResult.value.$document = document;\n    return document;\n  }\n  async update(document, cancellationToken) {\n    var _a2, _b2;\n    const oldText = (_a2 = document.parseResult.value.$cstNode) === null || _a2 === void 0 ? void 0 : _a2.root.fullText;\n    const textDocument = (_b2 = this.textDocuments) === null || _b2 === void 0 ? void 0 : _b2.get(document.uri.toString());\n    const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n    if (textDocument) {\n      Object.defineProperty(document, \"textDocument\", {\n        value: textDocument\n      });\n    } else {\n      const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n      Object.defineProperty(document, \"textDocument\", {\n        get: textDocumentGetter\n      });\n    }\n    if (oldText !== text) {\n      document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n      document.parseResult.value.$document = document;\n    }\n    document.state = DocumentState.Parsed;\n    return document;\n  }\n  parse(uri, text, options) {\n    const services = this.serviceRegistry.getServices(uri);\n    return services.parser.LangiumParser.parse(text, options);\n  }\n  parseAsync(uri, text, cancellationToken) {\n    const services = this.serviceRegistry.getServices(uri);\n    return services.parser.AsyncParser.parse(text, cancellationToken);\n  }\n  createTextDocumentGetter(uri, text) {\n    const serviceRegistry = this.serviceRegistry;\n    let textDoc = void 0;\n    return () => {\n      return textDoc !== null && textDoc !== void 0 ? textDoc : textDoc = TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : \"\");\n    };\n  }\n}\nclass DefaultLangiumDocuments {\n  constructor(services) {\n    this.documentMap = /* @__PURE__ */ new Map();\n    this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n    this.serviceRegistry = services.ServiceRegistry;\n  }\n  get all() {\n    return stream(this.documentMap.values());\n  }\n  addDocument(document) {\n    const uriString = document.uri.toString();\n    if (this.documentMap.has(uriString)) {\n      throw new Error(`A document with the URI '${uriString}' is already present.`);\n    }\n    this.documentMap.set(uriString, document);\n  }\n  getDocument(uri) {\n    const uriString = uri.toString();\n    return this.documentMap.get(uriString);\n  }\n  async getOrCreateDocument(uri, cancellationToken) {\n    let document = this.getDocument(uri);\n    if (document) {\n      return document;\n    }\n    document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n    this.addDocument(document);\n    return document;\n  }\n  createDocument(uri, text, cancellationToken) {\n    if (cancellationToken) {\n      return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then((document) => {\n        this.addDocument(document);\n        return document;\n      });\n    } else {\n      const document = this.langiumDocumentFactory.fromString(text, uri);\n      this.addDocument(document);\n      return document;\n    }\n  }\n  hasDocument(uri) {\n    return this.documentMap.has(uri.toString());\n  }\n  invalidateDocument(uri) {\n    const uriString = uri.toString();\n    const langiumDoc = this.documentMap.get(uriString);\n    if (langiumDoc) {\n      const linker = this.serviceRegistry.getServices(uri).references.Linker;\n      linker.unlink(langiumDoc);\n      langiumDoc.state = DocumentState.Changed;\n      langiumDoc.precomputedScopes = void 0;\n      langiumDoc.diagnostics = void 0;\n    }\n    return langiumDoc;\n  }\n  deleteDocument(uri) {\n    const uriString = uri.toString();\n    const langiumDoc = this.documentMap.get(uriString);\n    if (langiumDoc) {\n      langiumDoc.state = DocumentState.Changed;\n      this.documentMap.delete(uriString);\n    }\n    return langiumDoc;\n  }\n}\nconst ref_resolving = Symbol(\"ref_resolving\");\nclass DefaultLinker {\n  constructor(services) {\n    this.reflection = services.shared.AstReflection;\n    this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\n    this.scopeProvider = services.references.ScopeProvider;\n    this.astNodeLocator = services.workspace.AstNodeLocator;\n  }\n  async link(document, cancelToken = cancellationExports.CancellationToken.None) {\n    for (const node of streamAst(document.parseResult.value)) {\n      await interruptAndCheck(cancelToken);\n      streamReferences(node).forEach((ref) => this.doLink(ref, document));\n    }\n  }\n  doLink(refInfo, document) {\n    var _a2;\n    const ref = refInfo.reference;\n    if (ref._ref === void 0) {\n      ref._ref = ref_resolving;\n      try {\n        const description = this.getCandidate(refInfo);\n        if (isLinkingError(description)) {\n          ref._ref = description;\n        } else {\n          ref._nodeDescription = description;\n          if (this.langiumDocuments().hasDocument(description.documentUri)) {\n            const linkedNode = this.loadAstNode(description);\n            ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);\n          } else {\n            ref._ref = void 0;\n          }\n        }\n      } catch (err) {\n        const errorMessage = (_a2 = err.message) !== null && _a2 !== void 0 ? _a2 : String(err);\n        ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${errorMessage}` });\n      }\n      document.references.push(ref);\n    }\n  }\n  unlink(document) {\n    for (const ref of document.references) {\n      delete ref._ref;\n      delete ref._nodeDescription;\n    }\n    document.references = [];\n  }\n  getCandidate(refInfo) {\n    const scope = this.scopeProvider.getScope(refInfo);\n    const description = scope.getElement(refInfo.reference.$refText);\n    return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);\n  }\n  buildReference(node, property, refNode, refText) {\n    const linker = this;\n    const reference = {\n      $refNode: refNode,\n      $refText: refText,\n      get ref() {\n        var _a2;\n        if (isAstNode(this._ref)) {\n          return this._ref;\n        } else if (isAstNodeDescription(this._nodeDescription)) {\n          const linkedNode = linker.loadAstNode(this._nodeDescription);\n          this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\n        } else if (this._ref === void 0) {\n          this._ref = ref_resolving;\n          const document = findRootNode(node).$document;\n          const refData = linker.getLinkedNode({ reference, container: node, property });\n          if (refData.error && document && document.state < DocumentState.ComputedScopes) {\n            return this._ref = void 0;\n          }\n          this._ref = (_a2 = refData.node) !== null && _a2 !== void 0 ? _a2 : refData.error;\n          this._nodeDescription = refData.descr;\n          document === null || document === void 0 ? void 0 : document.references.push(this);\n        } else if (this._ref === ref_resolving) {\n          throw new Error(`Cyclic reference resolution detected: ${linker.astNodeLocator.getAstNodePath(node)}/${property} (symbol '${refText}')`);\n        }\n        return isAstNode(this._ref) ? this._ref : void 0;\n      },\n      get $nodeDescription() {\n        return this._nodeDescription;\n      },\n      get error() {\n        return isLinkingError(this._ref) ? this._ref : void 0;\n      }\n    };\n    return reference;\n  }\n  getLinkedNode(refInfo) {\n    var _a2;\n    try {\n      const description = this.getCandidate(refInfo);\n      if (isLinkingError(description)) {\n        return { error: description };\n      }\n      const linkedNode = this.loadAstNode(description);\n      if (linkedNode) {\n        return { node: linkedNode, descr: description };\n      } else {\n        return {\n          descr: description,\n          error: this.createLinkingError(refInfo, description)\n        };\n      }\n    } catch (err) {\n      const errorMessage = (_a2 = err.message) !== null && _a2 !== void 0 ? _a2 : String(err);\n      return {\n        error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${errorMessage}` })\n      };\n    }\n  }\n  loadAstNode(nodeDescription) {\n    if (nodeDescription.node) {\n      return nodeDescription.node;\n    }\n    const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n    if (!doc) {\n      return void 0;\n    }\n    return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n  }\n  createLinkingError(refInfo, targetDescription) {\n    const document = findRootNode(refInfo.container).$document;\n    if (document && document.state < DocumentState.ComputedScopes) {\n    }\n    const referenceType = this.reflection.getReferenceType(refInfo);\n    return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });\n  }\n}\nfunction isNamed(node) {\n  return typeof node.name === \"string\";\n}\nclass DefaultNameProvider {\n  getName(node) {\n    if (isNamed(node)) {\n      return node.name;\n    }\n    return void 0;\n  }\n  getNameNode(node) {\n    return findNodeForProperty(node.$cstNode, \"name\");\n  }\n}\nclass DefaultReferences {\n  constructor(services) {\n    this.nameProvider = services.references.NameProvider;\n    this.index = services.shared.workspace.IndexManager;\n    this.nodeLocator = services.workspace.AstNodeLocator;\n  }\n  findDeclaration(sourceCstNode) {\n    if (sourceCstNode) {\n      const assignment = findAssignment(sourceCstNode);\n      const nodeElem = sourceCstNode.astNode;\n      if (assignment && nodeElem) {\n        const reference = nodeElem[assignment.feature];\n        if (isReference(reference)) {\n          return reference.ref;\n        } else if (Array.isArray(reference)) {\n          for (const ref of reference) {\n            if (isReference(ref) && ref.$refNode && ref.$refNode.offset <= sourceCstNode.offset && ref.$refNode.end >= sourceCstNode.end) {\n              return ref.ref;\n            }\n          }\n        }\n      }\n      if (nodeElem) {\n        const nameNode = this.nameProvider.getNameNode(nodeElem);\n        if (nameNode && (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {\n          return nodeElem;\n        }\n      }\n    }\n    return void 0;\n  }\n  findDeclarationNode(sourceCstNode) {\n    const astNode = this.findDeclaration(sourceCstNode);\n    if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {\n      const targetNode = this.nameProvider.getNameNode(astNode);\n      return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;\n    }\n    return void 0;\n  }\n  findReferences(targetNode, options) {\n    const refs = [];\n    if (options.includeDeclaration) {\n      const ref = this.getReferenceToSelf(targetNode);\n      if (ref) {\n        refs.push(ref);\n      }\n    }\n    let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\n    if (options.documentUri) {\n      indexReferences = indexReferences.filter((ref) => UriUtils.equals(ref.sourceUri, options.documentUri));\n    }\n    refs.push(...indexReferences);\n    return stream(refs);\n  }\n  getReferenceToSelf(targetNode) {\n    const nameNode = this.nameProvider.getNameNode(targetNode);\n    if (nameNode) {\n      const doc = getDocument(targetNode);\n      const path = this.nodeLocator.getAstNodePath(targetNode);\n      return {\n        sourceUri: doc.uri,\n        sourcePath: path,\n        targetUri: doc.uri,\n        targetPath: path,\n        segment: toDocumentSegment(nameNode),\n        local: true\n      };\n    }\n    return void 0;\n  }\n}\nclass MultiMap {\n  constructor(elements) {\n    this.map = /* @__PURE__ */ new Map();\n    if (elements) {\n      for (const [key, value] of elements) {\n        this.add(key, value);\n      }\n    }\n  }\n  /**\n   * The total number of values in the multimap.\n   */\n  get size() {\n    return Reduction.sum(stream(this.map.values()).map((a) => a.length));\n  }\n  /**\n   * Clear all entries in the multimap.\n   */\n  clear() {\n    this.map.clear();\n  }\n  /**\n   * Operates differently depending on whether a `value` is given:\n   *  * With a value, this method deletes the specific key / value pair from the multimap.\n   *  * Without a value, all values associated with the given key are deleted.\n   *\n   * @returns `true` if a value existed and has been removed, or `false` if the specified\n   *     key / value does not exist.\n   */\n  delete(key, value) {\n    if (value === void 0) {\n      return this.map.delete(key);\n    } else {\n      const values2 = this.map.get(key);\n      if (values2) {\n        const index = values2.indexOf(value);\n        if (index >= 0) {\n          if (values2.length === 1) {\n            this.map.delete(key);\n          } else {\n            values2.splice(index, 1);\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  /**\n   * Returns an array of all values associated with the given key. If no value exists,\n   * an empty array is returned.\n   *\n   * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\n   * value and `delete` to remove a value from the multimap.\n   */\n  get(key) {\n    var _a2;\n    return (_a2 = this.map.get(key)) !== null && _a2 !== void 0 ? _a2 : [];\n  }\n  /**\n   * Operates differently depending on whether a `value` is given:\n   *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\n   *  * Without a value, this method returns `true` if the given key is present in the multimap.\n   */\n  has(key, value) {\n    if (value === void 0) {\n      return this.map.has(key);\n    } else {\n      const values2 = this.map.get(key);\n      if (values2) {\n        return values2.indexOf(value) >= 0;\n      }\n      return false;\n    }\n  }\n  /**\n   * Add the given key / value pair to the multimap.\n   */\n  add(key, value) {\n    if (this.map.has(key)) {\n      this.map.get(key).push(value);\n    } else {\n      this.map.set(key, [value]);\n    }\n    return this;\n  }\n  /**\n   * Add the given set of key / value pairs to the multimap.\n   */\n  addAll(key, values2) {\n    if (this.map.has(key)) {\n      this.map.get(key).push(...values2);\n    } else {\n      this.map.set(key, Array.from(values2));\n    }\n    return this;\n  }\n  /**\n   * Invokes the given callback function for every key / value pair in the multimap.\n   */\n  forEach(callbackfn) {\n    this.map.forEach((array, key) => array.forEach((value) => callbackfn(value, key, this)));\n  }\n  /**\n   * Returns an iterator of key, value pairs for every entry in the map.\n   */\n  [Symbol.iterator]() {\n    return this.entries().iterator();\n  }\n  /**\n   * Returns a stream of key, value pairs for every entry in the map.\n   */\n  entries() {\n    return stream(this.map.entries()).flatMap(([key, array]) => array.map((value) => [key, value]));\n  }\n  /**\n   * Returns a stream of keys in the map.\n   */\n  keys() {\n    return stream(this.map.keys());\n  }\n  /**\n   * Returns a stream of values in the map.\n   */\n  values() {\n    return stream(this.map.values()).flat();\n  }\n  /**\n   * Returns a stream of key, value set pairs for every key in the map.\n   */\n  entriesGroupedByKey() {\n    return stream(this.map.entries());\n  }\n}\nclass BiMap {\n  get size() {\n    return this.map.size;\n  }\n  constructor(elements) {\n    this.map = /* @__PURE__ */ new Map();\n    this.inverse = /* @__PURE__ */ new Map();\n    if (elements) {\n      for (const [key, value] of elements) {\n        this.set(key, value);\n      }\n    }\n  }\n  clear() {\n    this.map.clear();\n    this.inverse.clear();\n  }\n  set(key, value) {\n    this.map.set(key, value);\n    this.inverse.set(value, key);\n    return this;\n  }\n  get(key) {\n    return this.map.get(key);\n  }\n  getKey(value) {\n    return this.inverse.get(value);\n  }\n  delete(key) {\n    const value = this.map.get(key);\n    if (value !== void 0) {\n      this.map.delete(key);\n      this.inverse.delete(value);\n      return true;\n    }\n    return false;\n  }\n}\nclass DefaultScopeComputation {\n  constructor(services) {\n    this.nameProvider = services.references.NameProvider;\n    this.descriptions = services.workspace.AstNodeDescriptionProvider;\n  }\n  async computeExports(document, cancelToken = cancellationExports.CancellationToken.None) {\n    return this.computeExportsForNode(document.parseResult.value, document, void 0, cancelToken);\n  }\n  /**\n   * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\n   * The list of children to be considered is determined by the function parameter {@link children}.\n   * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\n   *\n   * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\n   * @param document The document containing the AST node to be exported.\n   * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\n   * @param cancelToken Indicates when to cancel the current operation.\n   * @throws `OperationCancelled` if a user action occurs during execution.\n   * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\n   */\n  async computeExportsForNode(parentNode, document, children = streamContents, cancelToken = cancellationExports.CancellationToken.None) {\n    const exports = [];\n    this.exportNode(parentNode, exports, document);\n    for (const node of children(parentNode)) {\n      await interruptAndCheck(cancelToken);\n      this.exportNode(node, exports, document);\n    }\n    return exports;\n  }\n  /**\n   * Add a single node to the list of exports if it has a name. Override this method to change how\n   * symbols are exported, e.g. by modifying their exported name.\n   */\n  exportNode(node, exports, document) {\n    const name = this.nameProvider.getName(node);\n    if (name) {\n      exports.push(this.descriptions.createDescription(node, name, document));\n    }\n  }\n  async computeLocalScopes(document, cancelToken = cancellationExports.CancellationToken.None) {\n    const rootNode = document.parseResult.value;\n    const scopes = new MultiMap();\n    for (const node of streamAllContents(rootNode)) {\n      await interruptAndCheck(cancelToken);\n      this.processNode(node, document, scopes);\n    }\n    return scopes;\n  }\n  /**\n   * Process a single node during scopes computation. The default implementation makes the node visible\n   * in the subtree of its container (if the node has a name). Override this method to change this,\n   * e.g. by increasing the visibility to a higher level in the AST.\n   */\n  processNode(node, document, scopes) {\n    const container = node.$container;\n    if (container) {\n      const name = this.nameProvider.getName(node);\n      if (name) {\n        scopes.add(container, this.descriptions.createDescription(node, name, document));\n      }\n    }\n  }\n}\nclass StreamScope {\n  constructor(elements, outerScope, options) {\n    var _a2;\n    this.elements = elements;\n    this.outerScope = outerScope;\n    this.caseInsensitive = (_a2 = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a2 !== void 0 ? _a2 : false;\n  }\n  getAllElements() {\n    if (this.outerScope) {\n      return this.elements.concat(this.outerScope.getAllElements());\n    } else {\n      return this.elements;\n    }\n  }\n  getElement(name) {\n    const local = this.caseInsensitive ? this.elements.find((e) => e.name.toLowerCase() === name.toLowerCase()) : this.elements.find((e) => e.name === name);\n    if (local) {\n      return local;\n    }\n    if (this.outerScope) {\n      return this.outerScope.getElement(name);\n    }\n    return void 0;\n  }\n}\nclass MapScope {\n  constructor(elements, outerScope, options) {\n    var _a2;\n    this.elements = /* @__PURE__ */ new Map();\n    this.caseInsensitive = (_a2 = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a2 !== void 0 ? _a2 : false;\n    for (const element of elements) {\n      const name = this.caseInsensitive ? element.name.toLowerCase() : element.name;\n      this.elements.set(name, element);\n    }\n    this.outerScope = outerScope;\n  }\n  getElement(name) {\n    const localName = this.caseInsensitive ? name.toLowerCase() : name;\n    const local = this.elements.get(localName);\n    if (local) {\n      return local;\n    }\n    if (this.outerScope) {\n      return this.outerScope.getElement(name);\n    }\n    return void 0;\n  }\n  getAllElements() {\n    let elementStream = stream(this.elements.values());\n    if (this.outerScope) {\n      elementStream = elementStream.concat(this.outerScope.getAllElements());\n    }\n    return elementStream;\n  }\n}\nclass DisposableCache {\n  constructor() {\n    this.toDispose = [];\n    this.isDisposed = false;\n  }\n  onDispose(disposable) {\n    this.toDispose.push(disposable);\n  }\n  dispose() {\n    this.throwIfDisposed();\n    this.clear();\n    this.isDisposed = true;\n    this.toDispose.forEach((disposable) => disposable.dispose());\n  }\n  throwIfDisposed() {\n    if (this.isDisposed) {\n      throw new Error(\"This cache has already been disposed\");\n    }\n  }\n}\nclass SimpleCache extends DisposableCache {\n  constructor() {\n    super(...arguments);\n    this.cache = /* @__PURE__ */ new Map();\n  }\n  has(key) {\n    this.throwIfDisposed();\n    return this.cache.has(key);\n  }\n  set(key, value) {\n    this.throwIfDisposed();\n    this.cache.set(key, value);\n  }\n  get(key, provider) {\n    this.throwIfDisposed();\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    } else if (provider) {\n      const value = provider();\n      this.cache.set(key, value);\n      return value;\n    } else {\n      return void 0;\n    }\n  }\n  delete(key) {\n    this.throwIfDisposed();\n    return this.cache.delete(key);\n  }\n  clear() {\n    this.throwIfDisposed();\n    this.cache.clear();\n  }\n}\nclass ContextCache extends DisposableCache {\n  constructor(converter) {\n    super();\n    this.cache = /* @__PURE__ */ new Map();\n    this.converter = converter !== null && converter !== void 0 ? converter : (value) => value;\n  }\n  has(contextKey, key) {\n    this.throwIfDisposed();\n    return this.cacheForContext(contextKey).has(key);\n  }\n  set(contextKey, key, value) {\n    this.throwIfDisposed();\n    this.cacheForContext(contextKey).set(key, value);\n  }\n  get(contextKey, key, provider) {\n    this.throwIfDisposed();\n    const contextCache = this.cacheForContext(contextKey);\n    if (contextCache.has(key)) {\n      return contextCache.get(key);\n    } else if (provider) {\n      const value = provider();\n      contextCache.set(key, value);\n      return value;\n    } else {\n      return void 0;\n    }\n  }\n  delete(contextKey, key) {\n    this.throwIfDisposed();\n    return this.cacheForContext(contextKey).delete(key);\n  }\n  clear(contextKey) {\n    this.throwIfDisposed();\n    if (contextKey) {\n      const mapKey = this.converter(contextKey);\n      this.cache.delete(mapKey);\n    } else {\n      this.cache.clear();\n    }\n  }\n  cacheForContext(contextKey) {\n    const mapKey = this.converter(contextKey);\n    let documentCache = this.cache.get(mapKey);\n    if (!documentCache) {\n      documentCache = /* @__PURE__ */ new Map();\n      this.cache.set(mapKey, documentCache);\n    }\n    return documentCache;\n  }\n}\nclass WorkspaceCache extends SimpleCache {\n  /**\n   * Creates a new workspace cache.\n   *\n   * @param sharedServices Service container instance to hook into document lifecycle events.\n   * @param state Optional document state on which the cache should evict.\n   * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.\n   * *Deleted* documents are considered in both cases.\n   */\n  constructor(sharedServices, state) {\n    super();\n    if (state) {\n      this.toDispose.push(sharedServices.workspace.DocumentBuilder.onBuildPhase(state, () => {\n        this.clear();\n      }));\n      this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {\n        if (deleted.length > 0) {\n          this.clear();\n        }\n      }));\n    } else {\n      this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate(() => {\n        this.clear();\n      }));\n    }\n  }\n}\nclass DefaultScopeProvider {\n  constructor(services) {\n    this.reflection = services.shared.AstReflection;\n    this.nameProvider = services.references.NameProvider;\n    this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    this.indexManager = services.shared.workspace.IndexManager;\n    this.globalScopeCache = new WorkspaceCache(services.shared);\n  }\n  getScope(context) {\n    const scopes = [];\n    const referenceType = this.reflection.getReferenceType(context);\n    const precomputed = getDocument(context.container).precomputedScopes;\n    if (precomputed) {\n      let currentNode = context.container;\n      do {\n        const allDescriptions = precomputed.get(currentNode);\n        if (allDescriptions.length > 0) {\n          scopes.push(stream(allDescriptions).filter((desc) => this.reflection.isSubtype(desc.type, referenceType)));\n        }\n        currentNode = currentNode.$container;\n      } while (currentNode);\n    }\n    let result = this.getGlobalScope(referenceType, context);\n    for (let i = scopes.length - 1; i >= 0; i--) {\n      result = this.createScope(scopes[i], result);\n    }\n    return result;\n  }\n  /**\n   * Create a scope for the given collection of AST node descriptions.\n   */\n  createScope(elements, outerScope, options) {\n    return new StreamScope(stream(elements), outerScope, options);\n  }\n  /**\n   * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n   * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n   */\n  createScopeForNodes(elements, outerScope, options) {\n    const s = stream(elements).map((e) => {\n      const name = this.nameProvider.getName(e);\n      if (name) {\n        return this.descriptions.createDescription(e, name);\n      }\n      return void 0;\n    }).nonNullable();\n    return new StreamScope(s, outerScope, options);\n  }\n  /**\n   * Create a global scope filtered for the given reference type.\n   */\n  getGlobalScope(referenceType, _context) {\n    return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\n  }\n}\nfunction isAstNodeWithComment(node) {\n  return typeof node.$comment === \"string\";\n}\nfunction isIntermediateReference(obj) {\n  return typeof obj === \"object\" && !!obj && (\"$ref\" in obj || \"$error\" in obj);\n}\nclass DefaultJsonSerializer {\n  constructor(services) {\n    this.ignoreProperties = /* @__PURE__ */ new Set([\"$container\", \"$containerProperty\", \"$containerIndex\", \"$document\", \"$cstNode\"]);\n    this.langiumDocuments = services.shared.workspace.LangiumDocuments;\n    this.astNodeLocator = services.workspace.AstNodeLocator;\n    this.nameProvider = services.references.NameProvider;\n    this.commentProvider = services.documentation.CommentProvider;\n  }\n  serialize(node, options) {\n    const serializeOptions = options !== null && options !== void 0 ? options : {};\n    const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;\n    const defaultReplacer = (key, value) => this.replacer(key, value, serializeOptions);\n    const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\n    try {\n      this.currentDocument = getDocument(node);\n      return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);\n    } finally {\n      this.currentDocument = void 0;\n    }\n  }\n  deserialize(content, options) {\n    const deserializeOptions = options !== null && options !== void 0 ? options : {};\n    const root = JSON.parse(content);\n    this.linkNode(root, root, deserializeOptions);\n    return root;\n  }\n  replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {\n    var _a2, _b2, _c2, _d2;\n    if (this.ignoreProperties.has(key)) {\n      return void 0;\n    } else if (isReference(value)) {\n      const refValue = value.ref;\n      const $refText = refText ? value.$refText : void 0;\n      if (refValue) {\n        const targetDocument = getDocument(refValue);\n        let targetUri = \"\";\n        if (this.currentDocument && this.currentDocument !== targetDocument) {\n          if (uriConverter) {\n            targetUri = uriConverter(targetDocument.uri, value);\n          } else {\n            targetUri = targetDocument.uri.toString();\n          }\n        }\n        const targetPath = this.astNodeLocator.getAstNodePath(refValue);\n        return {\n          $ref: `${targetUri}#${targetPath}`,\n          $refText\n        };\n      } else {\n        return {\n          $error: (_b2 = (_a2 = value.error) === null || _a2 === void 0 ? void 0 : _a2.message) !== null && _b2 !== void 0 ? _b2 : \"Could not resolve reference\",\n          $refText\n        };\n      }\n    } else if (isAstNode(value)) {\n      let astNode = void 0;\n      if (textRegions) {\n        astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));\n        if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {\n          astNode.$textRegion.documentURI = (_c2 = this.currentDocument) === null || _c2 === void 0 ? void 0 : _c2.uri.toString();\n        }\n      }\n      if (sourceText && !key) {\n        astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);\n        astNode.$sourceText = (_d2 = value.$cstNode) === null || _d2 === void 0 ? void 0 : _d2.text;\n      }\n      if (comments) {\n        astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);\n        const comment = this.commentProvider.getComment(value);\n        if (comment) {\n          astNode.$comment = comment.replace(/\\r/g, \"\");\n        }\n      }\n      return astNode !== null && astNode !== void 0 ? astNode : value;\n    } else {\n      return value;\n    }\n  }\n  addAstNodeRegionWithAssignmentsTo(node) {\n    const createDocumentSegment = (cstNode) => ({\n      offset: cstNode.offset,\n      end: cstNode.end,\n      length: cstNode.length,\n      range: cstNode.range\n    });\n    if (node.$cstNode) {\n      const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\n      const assignments = textRegion.assignments = {};\n      Object.keys(node).filter((key) => !key.startsWith(\"$\")).forEach((key) => {\n        const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\n        if (propertyAssignments.length !== 0) {\n          assignments[key] = propertyAssignments;\n        }\n      });\n      return node;\n    }\n    return void 0;\n  }\n  linkNode(node, root, options, container, containerProperty, containerIndex) {\n    for (const [propertyName, item] of Object.entries(node)) {\n      if (Array.isArray(item)) {\n        for (let index = 0; index < item.length; index++) {\n          const element = item[index];\n          if (isIntermediateReference(element)) {\n            item[index] = this.reviveReference(node, propertyName, root, element, options);\n          } else if (isAstNode(element)) {\n            this.linkNode(element, root, options, node, propertyName, index);\n          }\n        }\n      } else if (isIntermediateReference(item)) {\n        node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\n      } else if (isAstNode(item)) {\n        this.linkNode(item, root, options, node, propertyName);\n      }\n    }\n    const mutable = node;\n    mutable.$container = container;\n    mutable.$containerProperty = containerProperty;\n    mutable.$containerIndex = containerIndex;\n  }\n  reviveReference(container, property, root, reference, options) {\n    let refText = reference.$refText;\n    let error = reference.$error;\n    if (reference.$ref) {\n      const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\n      if (isAstNode(ref)) {\n        if (!refText) {\n          refText = this.nameProvider.getName(ref);\n        }\n        return {\n          $refText: refText !== null && refText !== void 0 ? refText : \"\",\n          ref\n        };\n      } else {\n        error = ref;\n      }\n    }\n    if (error) {\n      const ref = {\n        $refText: refText !== null && refText !== void 0 ? refText : \"\"\n      };\n      ref.error = {\n        container,\n        property,\n        message: error,\n        reference: ref\n      };\n      return ref;\n    } else {\n      return void 0;\n    }\n  }\n  getRefNode(root, uri, uriConverter) {\n    try {\n      const fragmentIndex = uri.indexOf(\"#\");\n      if (fragmentIndex === 0) {\n        const node2 = this.astNodeLocator.getAstNode(root, uri.substring(1));\n        if (!node2) {\n          return \"Could not resolve path: \" + uri;\n        }\n        return node2;\n      }\n      if (fragmentIndex < 0) {\n        const documentUri2 = uriConverter ? uriConverter(uri) : URI.parse(uri);\n        const document2 = this.langiumDocuments.getDocument(documentUri2);\n        if (!document2) {\n          return \"Could not find document for URI: \" + uri;\n        }\n        return document2.parseResult.value;\n      }\n      const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : URI.parse(uri.substring(0, fragmentIndex));\n      const document = this.langiumDocuments.getDocument(documentUri);\n      if (!document) {\n        return \"Could not find document for URI: \" + uri;\n      }\n      if (fragmentIndex === uri.length - 1) {\n        return document.parseResult.value;\n      }\n      const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\n      if (!node) {\n        return \"Could not resolve URI: \" + uri;\n      }\n      return node;\n    } catch (err) {\n      return String(err);\n    }\n  }\n}\nclass DefaultServiceRegistry {\n  /**\n   * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.\n   */\n  get map() {\n    return this.fileExtensionMap;\n  }\n  constructor(services) {\n    this.languageIdMap = /* @__PURE__ */ new Map();\n    this.fileExtensionMap = /* @__PURE__ */ new Map();\n    this.textDocuments = services === null || services === void 0 ? void 0 : services.workspace.TextDocuments;\n  }\n  register(language) {\n    const data = language.LanguageMetaData;\n    for (const ext of data.fileExtensions) {\n      if (this.fileExtensionMap.has(ext)) {\n      }\n      this.fileExtensionMap.set(ext, language);\n    }\n    this.languageIdMap.set(data.languageId, language);\n    if (this.languageIdMap.size === 1) {\n      this.singleton = language;\n    } else {\n      this.singleton = void 0;\n    }\n  }\n  getServices(uri) {\n    var _a2, _b2;\n    if (this.singleton !== void 0) {\n      return this.singleton;\n    }\n    if (this.languageIdMap.size === 0) {\n      throw new Error(\"The service registry is empty. Use `register` to register the services of a language.\");\n    }\n    const languageId = (_b2 = (_a2 = this.textDocuments) === null || _a2 === void 0 ? void 0 : _a2.get(uri)) === null || _b2 === void 0 ? void 0 : _b2.languageId;\n    if (languageId !== void 0) {\n      const services2 = this.languageIdMap.get(languageId);\n      if (services2) {\n        return services2;\n      }\n    }\n    const ext = UriUtils.extname(uri);\n    const services = this.fileExtensionMap.get(ext);\n    if (!services) {\n      if (languageId) {\n        throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);\n      } else {\n        throw new Error(`The service registry contains no services for the extension '${ext}'.`);\n      }\n    }\n    return services;\n  }\n  hasServices(uri) {\n    try {\n      this.getServices(uri);\n      return true;\n    } catch (_a2) {\n      return false;\n    }\n  }\n  get all() {\n    return Array.from(this.languageIdMap.values());\n  }\n}\nfunction diagnosticData(code) {\n  return { code };\n}\nvar ValidationCategory;\n(function(ValidationCategory2) {\n  ValidationCategory2.all = [\"fast\", \"slow\", \"built-in\"];\n})(ValidationCategory || (ValidationCategory = {}));\nclass ValidationRegistry {\n  constructor(services) {\n    this.entries = new MultiMap();\n    this.entriesBefore = [];\n    this.entriesAfter = [];\n    this.reflection = services.shared.AstReflection;\n  }\n  /**\n   * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n   * or an array of validation checks.\n   *\n   * @param checksRecord Set of validation checks to register.\n   * @param category Optional category for the validation checks (defaults to `'fast'`).\n   * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n   */\n  register(checksRecord, thisObj = this, category = \"fast\") {\n    if (category === \"built-in\") {\n      throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\n    }\n    for (const [type, ch] of Object.entries(checksRecord)) {\n      const callbacks = ch;\n      if (Array.isArray(callbacks)) {\n        for (const check of callbacks) {\n          const entry = {\n            check: this.wrapValidationException(check, thisObj),\n            category\n          };\n          this.addEntry(type, entry);\n        }\n      } else if (typeof callbacks === \"function\") {\n        const entry = {\n          check: this.wrapValidationException(callbacks, thisObj),\n          category\n        };\n        this.addEntry(type, entry);\n      } else {\n        assertUnreachable();\n      }\n    }\n  }\n  wrapValidationException(check, thisObj) {\n    return async (node, accept, cancelToken) => {\n      await this.handleException(() => check.call(thisObj, node, accept, cancelToken), \"An error occurred during validation\", accept, node);\n    };\n  }\n  async handleException(functionality, messageContext, accept, node) {\n    try {\n      await functionality();\n    } catch (err) {\n      if (isOperationCancelled(err)) {\n        throw err;\n      }\n      if (err instanceof Error && err.stack) {\n      }\n      const messageDetails = err instanceof Error ? err.message : String(err);\n      accept(\"error\", `${messageContext}: ${messageDetails}`, { node });\n    }\n  }\n  addEntry(type, entry) {\n    if (type === \"AstNode\") {\n      this.entries.add(\"AstNode\", entry);\n      return;\n    }\n    for (const subtype of this.reflection.getAllSubTypes(type)) {\n      this.entries.add(subtype, entry);\n    }\n  }\n  getChecks(type, categories) {\n    let checks = stream(this.entries.get(type)).concat(this.entries.get(\"AstNode\"));\n    if (categories) {\n      checks = checks.filter((entry) => categories.includes(entry.category));\n    }\n    return checks.map((entry) => entry.check);\n  }\n  /**\n   * Register logic which will be executed once before validating all the nodes of an AST/Langium document.\n   * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.\n   *\n   * As an example, for validating unique fully-qualified names of nodes in the AST,\n   * here the map for mapping names to nodes could be established.\n   * During the usual checks on the nodes, they are put into this map with their name.\n   *\n   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n   * Therefore it is recommended to clear stored information\n   * _before_ validating an AST to validate each AST unaffected from other ASTs\n   * AND _after_ validating the AST to free memory by information which are no longer used.\n   *\n   * @param checkBefore a set-up function which will be called once before actually validating an AST\n   * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n   */\n  registerBeforeDocument(checkBefore, thisObj = this) {\n    this.entriesBefore.push(this.wrapPreparationException(checkBefore, \"An error occurred during set-up of the validation\", thisObj));\n  }\n  /**\n   * Register logic which will be executed once after validating all the nodes of an AST/Langium document.\n   * This helps to finally evaluate information which are collected during the checks on the AstNodes.\n   *\n   * As an example, for validating unique fully-qualified names of nodes in the AST,\n   * here the map with all the collected nodes and their names is checked\n   * and validation hints are created for all nodes with the same name.\n   *\n   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.\n   * Therefore it is recommended to clear stored information\n   * _before_ validating an AST to validate each AST unaffected from other ASTs\n   * AND _after_ validating the AST to free memory by information which are no longer used.\n   *\n   * @param checkBefore a set-up function which will be called once before actually validating an AST\n   * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n   */\n  registerAfterDocument(checkAfter, thisObj = this) {\n    this.entriesAfter.push(this.wrapPreparationException(checkAfter, \"An error occurred during tear-down of the validation\", thisObj));\n  }\n  wrapPreparationException(check, messageContext, thisObj) {\n    return async (rootNode, accept, categories, cancelToken) => {\n      await this.handleException(() => check.call(thisObj, rootNode, accept, categories, cancelToken), messageContext, accept, rootNode);\n    };\n  }\n  get checksBefore() {\n    return this.entriesBefore;\n  }\n  get checksAfter() {\n    return this.entriesAfter;\n  }\n}\nclass DefaultDocumentValidator {\n  constructor(services) {\n    this.validationRegistry = services.validation.ValidationRegistry;\n    this.metadata = services.LanguageMetaData;\n  }\n  async validateDocument(document, options = {}, cancelToken = cancellationExports.CancellationToken.None) {\n    const parseResult = document.parseResult;\n    const diagnostics = [];\n    await interruptAndCheck(cancelToken);\n    if (!options.categories || options.categories.includes(\"built-in\")) {\n      this.processLexingErrors(parseResult, diagnostics, options);\n      if (options.stopAfterLexingErrors && diagnostics.some((d) => {\n        var _a2;\n        return ((_a2 = d.data) === null || _a2 === void 0 ? void 0 : _a2.code) === DocumentValidator.LexingError;\n      })) {\n        return diagnostics;\n      }\n      this.processParsingErrors(parseResult, diagnostics, options);\n      if (options.stopAfterParsingErrors && diagnostics.some((d) => {\n        var _a2;\n        return ((_a2 = d.data) === null || _a2 === void 0 ? void 0 : _a2.code) === DocumentValidator.ParsingError;\n      })) {\n        return diagnostics;\n      }\n      this.processLinkingErrors(document, diagnostics, options);\n      if (options.stopAfterLinkingErrors && diagnostics.some((d) => {\n        var _a2;\n        return ((_a2 = d.data) === null || _a2 === void 0 ? void 0 : _a2.code) === DocumentValidator.LinkingError;\n      })) {\n        return diagnostics;\n      }\n    }\n    try {\n      diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\n    } catch (err) {\n      if (isOperationCancelled(err)) {\n        throw err;\n      }\n    }\n    await interruptAndCheck(cancelToken);\n    return diagnostics;\n  }\n  processLexingErrors(parseResult, diagnostics, _options) {\n    var _a2, _b2, _c2;\n    const lexerDiagnostics = [...parseResult.lexerErrors, ...(_b2 = (_a2 = parseResult.lexerReport) === null || _a2 === void 0 ? void 0 : _a2.diagnostics) !== null && _b2 !== void 0 ? _b2 : []];\n    for (const lexerDiagnostic of lexerDiagnostics) {\n      const severity = (_c2 = lexerDiagnostic.severity) !== null && _c2 !== void 0 ? _c2 : \"error\";\n      const diagnostic = {\n        severity: toDiagnosticSeverity(severity),\n        range: {\n          start: {\n            line: lexerDiagnostic.line - 1,\n            character: lexerDiagnostic.column - 1\n          },\n          end: {\n            line: lexerDiagnostic.line - 1,\n            character: lexerDiagnostic.column + lexerDiagnostic.length - 1\n          }\n        },\n        message: lexerDiagnostic.message,\n        data: toDiagnosticData(severity),\n        source: this.getSource()\n      };\n      diagnostics.push(diagnostic);\n    }\n  }\n  processParsingErrors(parseResult, diagnostics, _options) {\n    for (const parserError of parseResult.parserErrors) {\n      let range = void 0;\n      if (isNaN(parserError.token.startOffset)) {\n        if (\"previousToken\" in parserError) {\n          const token = parserError.previousToken;\n          if (!isNaN(token.startOffset)) {\n            const position = { line: token.endLine - 1, character: token.endColumn };\n            range = { start: position, end: position };\n          } else {\n            const position = { line: 0, character: 0 };\n            range = { start: position, end: position };\n          }\n        }\n      } else {\n        range = tokenToRange(parserError.token);\n      }\n      if (range) {\n        const diagnostic = {\n          severity: toDiagnosticSeverity(\"error\"),\n          range,\n          message: parserError.message,\n          data: diagnosticData(DocumentValidator.ParsingError),\n          source: this.getSource()\n        };\n        diagnostics.push(diagnostic);\n      }\n    }\n  }\n  processLinkingErrors(document, diagnostics, _options) {\n    for (const reference of document.references) {\n      const linkingError = reference.error;\n      if (linkingError) {\n        const info = {\n          node: linkingError.container,\n          property: linkingError.property,\n          index: linkingError.index,\n          data: {\n            code: DocumentValidator.LinkingError,\n            containerType: linkingError.container.$type,\n            property: linkingError.property,\n            refText: linkingError.reference.$refText\n          }\n        };\n        diagnostics.push(this.toDiagnostic(\"error\", linkingError.message, info));\n      }\n    }\n  }\n  async validateAst(rootNode, options, cancelToken = cancellationExports.CancellationToken.None) {\n    const validationItems = [];\n    const acceptor = (severity, message, info) => {\n      validationItems.push(this.toDiagnostic(severity, message, info));\n    };\n    await this.validateAstBefore(rootNode, options, acceptor, cancelToken);\n    await this.validateAstNodes(rootNode, options, acceptor, cancelToken);\n    await this.validateAstAfter(rootNode, options, acceptor, cancelToken);\n    return validationItems;\n  }\n  async validateAstBefore(rootNode, options, acceptor, cancelToken = cancellationExports.CancellationToken.None) {\n    var _a2;\n    const checksBefore = this.validationRegistry.checksBefore;\n    for (const checkBefore of checksBefore) {\n      await interruptAndCheck(cancelToken);\n      await checkBefore(rootNode, acceptor, (_a2 = options.categories) !== null && _a2 !== void 0 ? _a2 : [], cancelToken);\n    }\n  }\n  async validateAstNodes(rootNode, options, acceptor, cancelToken = cancellationExports.CancellationToken.None) {\n    await Promise.all(streamAst(rootNode).map(async (node) => {\n      await interruptAndCheck(cancelToken);\n      const checks = this.validationRegistry.getChecks(node.$type, options.categories);\n      for (const check of checks) {\n        await check(node, acceptor, cancelToken);\n      }\n    }));\n  }\n  async validateAstAfter(rootNode, options, acceptor, cancelToken = cancellationExports.CancellationToken.None) {\n    var _a2;\n    const checksAfter = this.validationRegistry.checksAfter;\n    for (const checkAfter of checksAfter) {\n      await interruptAndCheck(cancelToken);\n      await checkAfter(rootNode, acceptor, (_a2 = options.categories) !== null && _a2 !== void 0 ? _a2 : [], cancelToken);\n    }\n  }\n  toDiagnostic(severity, message, info) {\n    return {\n      message,\n      range: getDiagnosticRange(info),\n      severity: toDiagnosticSeverity(severity),\n      code: info.code,\n      codeDescription: info.codeDescription,\n      tags: info.tags,\n      relatedInformation: info.relatedInformation,\n      data: info.data,\n      source: this.getSource()\n    };\n  }\n  getSource() {\n    return this.metadata.languageId;\n  }\n}\nfunction getDiagnosticRange(info) {\n  if (info.range) {\n    return info.range;\n  }\n  let cstNode;\n  if (typeof info.property === \"string\") {\n    cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);\n  } else if (typeof info.keyword === \"string\") {\n    cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\n  }\n  cstNode !== null && cstNode !== void 0 ? cstNode : cstNode = info.node.$cstNode;\n  if (!cstNode) {\n    return {\n      start: { line: 0, character: 0 },\n      end: { line: 0, character: 0 }\n    };\n  }\n  return cstNode.range;\n}\nfunction toDiagnosticSeverity(severity) {\n  switch (severity) {\n    case \"error\":\n      return 1;\n    case \"warning\":\n      return 2;\n    case \"info\":\n      return 3;\n    case \"hint\":\n      return 4;\n    default:\n      throw new Error(\"Invalid diagnostic severity: \" + severity);\n  }\n}\nfunction toDiagnosticData(severity) {\n  switch (severity) {\n    case \"error\":\n      return diagnosticData(DocumentValidator.LexingError);\n    case \"warning\":\n      return diagnosticData(DocumentValidator.LexingWarning);\n    case \"info\":\n      return diagnosticData(DocumentValidator.LexingInfo);\n    case \"hint\":\n      return diagnosticData(DocumentValidator.LexingHint);\n    default:\n      throw new Error(\"Invalid diagnostic severity: \" + severity);\n  }\n}\nvar DocumentValidator;\n(function(DocumentValidator2) {\n  DocumentValidator2.LexingError = \"lexing-error\";\n  DocumentValidator2.LexingWarning = \"lexing-warning\";\n  DocumentValidator2.LexingInfo = \"lexing-info\";\n  DocumentValidator2.LexingHint = \"lexing-hint\";\n  DocumentValidator2.ParsingError = \"parsing-error\";\n  DocumentValidator2.LinkingError = \"linking-error\";\n})(DocumentValidator || (DocumentValidator = {}));\nclass DefaultAstNodeDescriptionProvider {\n  constructor(services) {\n    this.astNodeLocator = services.workspace.AstNodeLocator;\n    this.nameProvider = services.references.NameProvider;\n  }\n  createDescription(node, name, document) {\n    const doc = document !== null && document !== void 0 ? document : getDocument(node);\n    name !== null && name !== void 0 ? name : name = this.nameProvider.getName(node);\n    const path = this.astNodeLocator.getAstNodePath(node);\n    if (!name) {\n      throw new Error(`Node at path ${path} has no name.`);\n    }\n    let nameNodeSegment;\n    const nameSegmentGetter = () => {\n      var _a2;\n      return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : nameNodeSegment = toDocumentSegment((_a2 = this.nameProvider.getNameNode(node)) !== null && _a2 !== void 0 ? _a2 : node.$cstNode);\n    };\n    return {\n      node,\n      name,\n      get nameSegment() {\n        return nameSegmentGetter();\n      },\n      selectionSegment: toDocumentSegment(node.$cstNode),\n      type: node.$type,\n      documentUri: doc.uri,\n      path\n    };\n  }\n}\nclass DefaultReferenceDescriptionProvider {\n  constructor(services) {\n    this.nodeLocator = services.workspace.AstNodeLocator;\n  }\n  async createDescriptions(document, cancelToken = cancellationExports.CancellationToken.None) {\n    const descr = [];\n    const rootNode = document.parseResult.value;\n    for (const astNode of streamAst(rootNode)) {\n      await interruptAndCheck(cancelToken);\n      streamReferences(astNode).filter((refInfo) => !isLinkingError(refInfo)).forEach((refInfo) => {\n        const description = this.createDescription(refInfo);\n        if (description) {\n          descr.push(description);\n        }\n      });\n    }\n    return descr;\n  }\n  createDescription(refInfo) {\n    const targetNodeDescr = refInfo.reference.$nodeDescription;\n    const refCstNode = refInfo.reference.$refNode;\n    if (!targetNodeDescr || !refCstNode) {\n      return void 0;\n    }\n    const docUri = getDocument(refInfo.container).uri;\n    return {\n      sourceUri: docUri,\n      sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\n      targetUri: targetNodeDescr.documentUri,\n      targetPath: targetNodeDescr.path,\n      segment: toDocumentSegment(refCstNode),\n      local: UriUtils.equals(targetNodeDescr.documentUri, docUri)\n    };\n  }\n}\nclass DefaultAstNodeLocator {\n  constructor() {\n    this.segmentSeparator = \"/\";\n    this.indexSeparator = \"@\";\n  }\n  getAstNodePath(node) {\n    if (node.$container) {\n      const containerPath = this.getAstNodePath(node.$container);\n      const newSegment = this.getPathSegment(node);\n      const nodePath = containerPath + this.segmentSeparator + newSegment;\n      return nodePath;\n    }\n    return \"\";\n  }\n  getPathSegment({ $containerProperty, $containerIndex }) {\n    if (!$containerProperty) {\n      throw new Error(\"Missing '$containerProperty' in AST node.\");\n    }\n    if ($containerIndex !== void 0) {\n      return $containerProperty + this.indexSeparator + $containerIndex;\n    }\n    return $containerProperty;\n  }\n  getAstNode(node, path) {\n    const segments = path.split(this.segmentSeparator);\n    return segments.reduce((previousValue, currentValue) => {\n      if (!previousValue || currentValue.length === 0) {\n        return previousValue;\n      }\n      const propertyIndex = currentValue.indexOf(this.indexSeparator);\n      if (propertyIndex > 0) {\n        const property = currentValue.substring(0, propertyIndex);\n        const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\n        const array = previousValue[property];\n        return array === null || array === void 0 ? void 0 : array[arrayIndex];\n      }\n      return previousValue[currentValue];\n    }, node);\n  }\n}\nvar eventsExports = requireEvents();\nclass DefaultConfigurationProvider {\n  constructor(services) {\n    this._ready = new Deferred();\n    this.settings = {};\n    this.workspaceConfig = false;\n    this.onConfigurationSectionUpdateEmitter = new eventsExports.Emitter();\n    this.serviceRegistry = services.ServiceRegistry;\n  }\n  get ready() {\n    return this._ready.promise;\n  }\n  initialize(params) {\n    var _a2, _b2;\n    this.workspaceConfig = (_b2 = (_a2 = params.capabilities.workspace) === null || _a2 === void 0 ? void 0 : _a2.configuration) !== null && _b2 !== void 0 ? _b2 : false;\n  }\n  async initialized(params) {\n    if (this.workspaceConfig) {\n      if (params.register) {\n        const languages = this.serviceRegistry.all;\n        params.register({\n          // Listen to configuration changes for all languages\n          section: languages.map((lang) => this.toSectionName(lang.LanguageMetaData.languageId))\n        });\n      }\n      if (params.fetchConfiguration) {\n        const configToUpdate = this.serviceRegistry.all.map((lang) => ({\n          // Fetch the configuration changes for all languages\n          section: this.toSectionName(lang.LanguageMetaData.languageId)\n        }));\n        const configs = await params.fetchConfiguration(configToUpdate);\n        configToUpdate.forEach((conf, idx) => {\n          this.updateSectionConfiguration(conf.section, configs[idx]);\n        });\n      }\n    }\n    this._ready.resolve();\n  }\n  /**\n   *  Updates the cached configurations using the `change` notification parameters.\n   *\n   * @param change The parameters of a change configuration notification.\n   * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n   */\n  updateConfiguration(change) {\n    if (!change.settings) {\n      return;\n    }\n    Object.keys(change.settings).forEach((section) => {\n      const configuration = change.settings[section];\n      this.updateSectionConfiguration(section, configuration);\n      this.onConfigurationSectionUpdateEmitter.fire({ section, configuration });\n    });\n  }\n  updateSectionConfiguration(section, configuration) {\n    this.settings[section] = configuration;\n  }\n  /**\n  * Returns a configuration value stored for the given language.\n  *\n  * @param language The language id\n  * @param configuration Configuration name\n  */\n  async getConfiguration(language, configuration) {\n    await this.ready;\n    const sectionName = this.toSectionName(language);\n    if (this.settings[sectionName]) {\n      return this.settings[sectionName][configuration];\n    }\n  }\n  toSectionName(languageId) {\n    return `${languageId}`;\n  }\n  get onConfigurationSectionUpdate() {\n    return this.onConfigurationSectionUpdateEmitter.event;\n  }\n}\nvar Disposable;\n(function(Disposable2) {\n  function create(callback) {\n    return {\n      dispose: async () => await callback()\n    };\n  }\n  Disposable2.create = create;\n})(Disposable || (Disposable = {}));\nclass DefaultDocumentBuilder {\n  constructor(services) {\n    this.updateBuildOptions = {\n      // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\n      validation: {\n        categories: [\"built-in\", \"fast\"]\n      }\n    };\n    this.updateListeners = [];\n    this.buildPhaseListeners = new MultiMap();\n    this.documentPhaseListeners = new MultiMap();\n    this.buildState = /* @__PURE__ */ new Map();\n    this.documentBuildWaiters = /* @__PURE__ */ new Map();\n    this.currentState = DocumentState.Changed;\n    this.langiumDocuments = services.workspace.LangiumDocuments;\n    this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n    this.textDocuments = services.workspace.TextDocuments;\n    this.indexManager = services.workspace.IndexManager;\n    this.serviceRegistry = services.ServiceRegistry;\n  }\n  async build(documents, options = {}, cancelToken = cancellationExports.CancellationToken.None) {\n    var _a2, _b2;\n    for (const document of documents) {\n      const key = document.uri.toString();\n      if (document.state === DocumentState.Validated) {\n        if (typeof options.validation === \"boolean\" && options.validation) {\n          document.state = DocumentState.IndexedReferences;\n          document.diagnostics = void 0;\n          this.buildState.delete(key);\n        } else if (typeof options.validation === \"object\") {\n          const buildState = this.buildState.get(key);\n          const previousCategories = (_a2 = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a2 === void 0 ? void 0 : _a2.validationChecks;\n          if (previousCategories) {\n            const newCategories = (_b2 = options.validation.categories) !== null && _b2 !== void 0 ? _b2 : ValidationCategory.all;\n            const categories = newCategories.filter((c) => !previousCategories.includes(c));\n            if (categories.length > 0) {\n              this.buildState.set(key, {\n                completed: false,\n                options: {\n                  validation: Object.assign(Object.assign({}, options.validation), { categories })\n                },\n                result: buildState.result\n              });\n              document.state = DocumentState.IndexedReferences;\n            }\n          }\n        }\n      } else {\n        this.buildState.delete(key);\n      }\n    }\n    this.currentState = DocumentState.Changed;\n    await this.emitUpdate(documents.map((e) => e.uri), []);\n    await this.buildDocuments(documents, options, cancelToken);\n  }\n  async update(changed, deleted, cancelToken = cancellationExports.CancellationToken.None) {\n    this.currentState = DocumentState.Changed;\n    for (const deletedUri of deleted) {\n      this.langiumDocuments.deleteDocument(deletedUri);\n      this.buildState.delete(deletedUri.toString());\n      this.indexManager.remove(deletedUri);\n    }\n    for (const changedUri of changed) {\n      const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\n      if (!invalidated) {\n        const newDocument = this.langiumDocumentFactory.fromModel({ $type: \"INVALID\" }, changedUri);\n        newDocument.state = DocumentState.Changed;\n        this.langiumDocuments.addDocument(newDocument);\n      }\n      this.buildState.delete(changedUri.toString());\n    }\n    const allChangedUris = stream(changed).concat(deleted).map((uri) => uri.toString()).toSet();\n    this.langiumDocuments.all.filter((doc) => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris)).forEach((doc) => {\n      const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n      linker.unlink(doc);\n      doc.state = Math.min(doc.state, DocumentState.ComputedScopes);\n      doc.diagnostics = void 0;\n    });\n    await this.emitUpdate(changed, deleted);\n    await interruptAndCheck(cancelToken);\n    const rebuildDocuments = this.sortDocuments(this.langiumDocuments.all.filter((doc) => {\n      var _a2;\n      return doc.state < DocumentState.Linked || !((_a2 = this.buildState.get(doc.uri.toString())) === null || _a2 === void 0 ? void 0 : _a2.completed);\n    }).toArray());\n    await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\n  }\n  async emitUpdate(changed, deleted) {\n    await Promise.all(this.updateListeners.map((listener) => listener(changed, deleted)));\n  }\n  /**\n   * Sort the given documents by priority. By default, documents with an open text document are prioritized.\n   * This is useful to ensure that visible documents show their diagnostics before all other documents.\n   *\n   * This improves the responsiveness in large workspaces as users usually don't care about diagnostics\n   * in files that are currently not opened in the editor.\n   */\n  sortDocuments(documents) {\n    let left = 0;\n    let right = documents.length - 1;\n    while (left < right) {\n      while (left < documents.length && this.hasTextDocument(documents[left])) {\n        left++;\n      }\n      while (right >= 0 && !this.hasTextDocument(documents[right])) {\n        right--;\n      }\n      if (left < right) {\n        [documents[left], documents[right]] = [documents[right], documents[left]];\n      }\n    }\n    return documents;\n  }\n  hasTextDocument(doc) {\n    var _a2;\n    return Boolean((_a2 = this.textDocuments) === null || _a2 === void 0 ? void 0 : _a2.get(doc.uri));\n  }\n  /**\n   * Check whether the given document should be relinked after changes were found in the given URIs.\n   */\n  shouldRelink(document, changedUris) {\n    if (document.references.some((ref) => ref.error !== void 0)) {\n      return true;\n    }\n    return this.indexManager.isAffected(document, changedUris);\n  }\n  onUpdate(callback) {\n    this.updateListeners.push(callback);\n    return Disposable.create(() => {\n      const index = this.updateListeners.indexOf(callback);\n      if (index >= 0) {\n        this.updateListeners.splice(index, 1);\n      }\n    });\n  }\n  /**\n   * Build the given documents by stepping through all build phases. If a document's state indicates\n   * that a certain build phase is already done, the phase is skipped for that document.\n   *\n   * @param documents The documents to build.\n   * @param options the {@link BuildOptions} to use.\n   * @param cancelToken A cancellation token that can be used to cancel the build.\n   * @returns A promise that resolves when the build is done.\n   */\n  async buildDocuments(documents, options, cancelToken) {\n    this.prepareBuild(documents, options);\n    await this.runCancelable(documents, DocumentState.Parsed, cancelToken, (doc) => this.langiumDocumentFactory.update(doc, cancelToken));\n    await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, (doc) => this.indexManager.updateContent(doc, cancelToken));\n    await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async (doc) => {\n      const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\n      doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\n    });\n    await this.runCancelable(documents, DocumentState.Linked, cancelToken, (doc) => {\n      const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n      return linker.link(doc, cancelToken);\n    });\n    await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, (doc) => this.indexManager.updateReferences(doc, cancelToken));\n    const toBeValidated = documents.filter((doc) => this.shouldValidate(doc));\n    await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, (doc) => this.validate(doc, cancelToken));\n    for (const doc of documents) {\n      const state = this.buildState.get(doc.uri.toString());\n      if (state) {\n        state.completed = true;\n      }\n    }\n  }\n  /**\n   * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document\n   *\n   * @param documents collection of documents to be built\n   * @param options the {@link BuildOptions} to use\n   */\n  prepareBuild(documents, options) {\n    for (const doc of documents) {\n      const key = doc.uri.toString();\n      const state = this.buildState.get(key);\n      if (!state || state.completed) {\n        this.buildState.set(key, {\n          completed: false,\n          options,\n          result: state === null || state === void 0 ? void 0 : state.result\n        });\n      }\n    }\n  }\n  /**\n   * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.\n   *\n   * @param documents The array of documents to process.\n   * @param targetState The target {@link DocumentState} to bring the documents to.\n   * @param cancelToken A token that can be used to cancel the operation.\n   * @param callback A function to be called for each document.\n   * @returns A promise that resolves when all documents have been processed or the operation is canceled.\n   * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.\n   */\n  async runCancelable(documents, targetState, cancelToken, callback) {\n    const filtered = documents.filter((doc) => doc.state < targetState);\n    for (const document of filtered) {\n      await interruptAndCheck(cancelToken);\n      await callback(document);\n      document.state = targetState;\n      await this.notifyDocumentPhase(document, targetState, cancelToken);\n    }\n    const targetStateDocs = documents.filter((doc) => doc.state === targetState);\n    await this.notifyBuildPhase(targetStateDocs, targetState, cancelToken);\n    this.currentState = targetState;\n  }\n  onBuildPhase(targetState, callback) {\n    this.buildPhaseListeners.add(targetState, callback);\n    return Disposable.create(() => {\n      this.buildPhaseListeners.delete(targetState, callback);\n    });\n  }\n  onDocumentPhase(targetState, callback) {\n    this.documentPhaseListeners.add(targetState, callback);\n    return Disposable.create(() => {\n      this.documentPhaseListeners.delete(targetState, callback);\n    });\n  }\n  waitUntil(state, uriOrToken, cancelToken) {\n    let uri = void 0;\n    if (uriOrToken && \"path\" in uriOrToken) {\n      uri = uriOrToken;\n    } else {\n      cancelToken = uriOrToken;\n    }\n    cancelToken !== null && cancelToken !== void 0 ? cancelToken : cancelToken = cancellationExports.CancellationToken.None;\n    if (uri) {\n      const document = this.langiumDocuments.getDocument(uri);\n      if (document && document.state > state) {\n        return Promise.resolve(uri);\n      }\n    }\n    if (this.currentState >= state) {\n      return Promise.resolve(void 0);\n    } else if (cancelToken.isCancellationRequested) {\n      return Promise.reject(OperationCancelled);\n    }\n    return new Promise((resolve, reject2) => {\n      const buildDisposable = this.onBuildPhase(state, () => {\n        buildDisposable.dispose();\n        cancelDisposable.dispose();\n        if (uri) {\n          const document = this.langiumDocuments.getDocument(uri);\n          resolve(document === null || document === void 0 ? void 0 : document.uri);\n        } else {\n          resolve(void 0);\n        }\n      });\n      const cancelDisposable = cancelToken.onCancellationRequested(() => {\n        buildDisposable.dispose();\n        cancelDisposable.dispose();\n        reject2(OperationCancelled);\n      });\n    });\n  }\n  async notifyDocumentPhase(document, state, cancelToken) {\n    const listeners = this.documentPhaseListeners.get(state);\n    const listenersCopy = listeners.slice();\n    for (const listener of listenersCopy) {\n      try {\n        await listener(document, cancelToken);\n      } catch (err) {\n        if (!isOperationCancelled(err)) {\n          throw err;\n        }\n      }\n    }\n  }\n  async notifyBuildPhase(documents, state, cancelToken) {\n    if (documents.length === 0) {\n      return;\n    }\n    const listeners = this.buildPhaseListeners.get(state);\n    const listenersCopy = listeners.slice();\n    for (const listener of listenersCopy) {\n      await interruptAndCheck(cancelToken);\n      await listener(documents, cancelToken);\n    }\n  }\n  /**\n   * Determine whether the given document should be validated during a build. The default\n   * implementation checks the `validation` property of the build options. If it's set to `true`\n   * or a `ValidationOptions` object, the document is included in the validation phase.\n   */\n  shouldValidate(document) {\n    return Boolean(this.getBuildOptions(document).validation);\n  }\n  /**\n   * Run validation checks on the given document and store the resulting diagnostics in the document.\n   * If the document already contains diagnostics, the new ones are added to the list.\n   */\n  async validate(document, cancelToken) {\n    var _a2, _b2;\n    const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\n    const validationSetting = this.getBuildOptions(document).validation;\n    const options = typeof validationSetting === \"object\" ? validationSetting : void 0;\n    const diagnostics = await validator.validateDocument(document, options, cancelToken);\n    if (document.diagnostics) {\n      document.diagnostics.push(...diagnostics);\n    } else {\n      document.diagnostics = diagnostics;\n    }\n    const state = this.buildState.get(document.uri.toString());\n    if (state) {\n      (_a2 = state.result) !== null && _a2 !== void 0 ? _a2 : state.result = {};\n      const newCategories = (_b2 = options === null || options === void 0 ? void 0 : options.categories) !== null && _b2 !== void 0 ? _b2 : ValidationCategory.all;\n      if (state.result.validationChecks) {\n        state.result.validationChecks.push(...newCategories);\n      } else {\n        state.result.validationChecks = [...newCategories];\n      }\n    }\n  }\n  getBuildOptions(document) {\n    var _a2, _b2;\n    return (_b2 = (_a2 = this.buildState.get(document.uri.toString())) === null || _a2 === void 0 ? void 0 : _a2.options) !== null && _b2 !== void 0 ? _b2 : {};\n  }\n}\nclass DefaultIndexManager {\n  constructor(services) {\n    this.symbolIndex = /* @__PURE__ */ new Map();\n    this.symbolByTypeIndex = new ContextCache();\n    this.referenceIndex = /* @__PURE__ */ new Map();\n    this.documents = services.workspace.LangiumDocuments;\n    this.serviceRegistry = services.ServiceRegistry;\n    this.astReflection = services.AstReflection;\n  }\n  findAllReferences(targetNode, astNodePath) {\n    const targetDocUri = getDocument(targetNode).uri;\n    const result = [];\n    this.referenceIndex.forEach((docRefs) => {\n      docRefs.forEach((refDescr) => {\n        if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\n          result.push(refDescr);\n        }\n      });\n    });\n    return stream(result);\n  }\n  allElements(nodeType, uris) {\n    let documentUris = stream(this.symbolIndex.keys());\n    if (uris) {\n      documentUris = documentUris.filter((uri) => !uris || uris.has(uri));\n    }\n    return documentUris.map((uri) => this.getFileDescriptions(uri, nodeType)).flat();\n  }\n  getFileDescriptions(uri, nodeType) {\n    var _a2;\n    if (!nodeType) {\n      return (_a2 = this.symbolIndex.get(uri)) !== null && _a2 !== void 0 ? _a2 : [];\n    }\n    const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\n      var _a3;\n      const allFileDescriptions = (_a3 = this.symbolIndex.get(uri)) !== null && _a3 !== void 0 ? _a3 : [];\n      return allFileDescriptions.filter((e) => this.astReflection.isSubtype(e.type, nodeType));\n    });\n    return descriptions;\n  }\n  remove(uri) {\n    const uriString = uri.toString();\n    this.symbolIndex.delete(uriString);\n    this.symbolByTypeIndex.clear(uriString);\n    this.referenceIndex.delete(uriString);\n  }\n  async updateContent(document, cancelToken = cancellationExports.CancellationToken.None) {\n    const services = this.serviceRegistry.getServices(document.uri);\n    const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n    const uri = document.uri.toString();\n    this.symbolIndex.set(uri, exports);\n    this.symbolByTypeIndex.clear(uri);\n  }\n  async updateReferences(document, cancelToken = cancellationExports.CancellationToken.None) {\n    const services = this.serviceRegistry.getServices(document.uri);\n    const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n    this.referenceIndex.set(document.uri.toString(), indexData);\n  }\n  isAffected(document, changedUris) {\n    const references = this.referenceIndex.get(document.uri.toString());\n    if (!references) {\n      return false;\n    }\n    return references.some((ref) => !ref.local && changedUris.has(ref.targetUri.toString()));\n  }\n}\nclass DefaultWorkspaceManager {\n  constructor(services) {\n    this.initialBuildOptions = {};\n    this._ready = new Deferred();\n    this.serviceRegistry = services.ServiceRegistry;\n    this.langiumDocuments = services.workspace.LangiumDocuments;\n    this.documentBuilder = services.workspace.DocumentBuilder;\n    this.fileSystemProvider = services.workspace.FileSystemProvider;\n    this.mutex = services.workspace.WorkspaceLock;\n  }\n  get ready() {\n    return this._ready.promise;\n  }\n  get workspaceFolders() {\n    return this.folders;\n  }\n  initialize(params) {\n    var _a2;\n    this.folders = (_a2 = params.workspaceFolders) !== null && _a2 !== void 0 ? _a2 : void 0;\n  }\n  initialized(_params) {\n    return this.mutex.write((token) => {\n      var _a2;\n      return this.initializeWorkspace((_a2 = this.folders) !== null && _a2 !== void 0 ? _a2 : [], token);\n    });\n  }\n  async initializeWorkspace(folders, cancelToken = cancellationExports.CancellationToken.None) {\n    const documents = await this.performStartup(folders);\n    await interruptAndCheck(cancelToken);\n    await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\n  }\n  /**\n   * Performs the uninterruptable startup sequence of the workspace manager.\n   * This methods loads all documents in the workspace and other documents and returns them.\n   */\n  async performStartup(folders) {\n    const fileExtensions = this.serviceRegistry.all.flatMap((e) => e.LanguageMetaData.fileExtensions);\n    const documents = [];\n    const collector = (document) => {\n      documents.push(document);\n      if (!this.langiumDocuments.hasDocument(document.uri)) {\n        this.langiumDocuments.addDocument(document);\n      }\n    };\n    await this.loadAdditionalDocuments(folders, collector);\n    await Promise.all(folders.map((wf) => [wf, this.getRootFolder(wf)]).map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));\n    this._ready.resolve();\n    return documents;\n  }\n  /**\n   * Load all additional documents that shall be visible in the context of the given workspace\n   * folders and add them to the collector. This can be used to include built-in libraries of\n   * your language, which can be either loaded from provided files or constructed in memory.\n   */\n  loadAdditionalDocuments(_folders, _collector) {\n    return Promise.resolve();\n  }\n  /**\n   * Determine the root folder of the source documents in the given workspace folder.\n   * The default implementation returns the URI of the workspace folder, but you can override\n   * this to return a subfolder like `src` instead.\n   */\n  getRootFolder(workspaceFolder) {\n    return URI.parse(workspaceFolder.uri);\n  }\n  /**\n   * Traverse the file system folder identified by the given URI and its subfolders. All\n   * contained files that match the file extensions are added to the collector.\n   */\n  async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {\n    const content = await this.fileSystemProvider.readDirectory(folderPath);\n    await Promise.all(content.map(async (entry) => {\n      if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\n        if (entry.isDirectory) {\n          await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\n        } else if (entry.isFile) {\n          const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\n          collector(document);\n        }\n      }\n    }));\n  }\n  /**\n   * Determine whether the given folder entry shall be included while indexing the workspace.\n   */\n  includeEntry(_workspaceFolder, entry, fileExtensions) {\n    const name = UriUtils.basename(entry.uri);\n    if (name.startsWith(\".\")) {\n      return false;\n    }\n    if (entry.isDirectory) {\n      return name !== \"node_modules\" && name !== \"out\";\n    } else if (entry.isFile) {\n      const extname = UriUtils.extname(entry.uri);\n      return fileExtensions.includes(extname);\n    }\n    return false;\n  }\n}\nclass DefaultLexerErrorMessageProvider {\n  buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n    return defaultLexerErrorProvider.buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column);\n  }\n  buildUnableToPopLexerModeMessage(token) {\n    return defaultLexerErrorProvider.buildUnableToPopLexerModeMessage(token);\n  }\n}\nconst DEFAULT_TOKENIZE_OPTIONS = { mode: \"full\" };\nclass DefaultLexer {\n  constructor(services) {\n    this.errorMessageProvider = services.parser.LexerErrorMessageProvider;\n    this.tokenBuilder = services.parser.TokenBuilder;\n    const tokens = this.tokenBuilder.buildTokens(services.Grammar, {\n      caseInsensitive: services.LanguageMetaData.caseInsensitive\n    });\n    this.tokenTypes = this.toTokenTypeDictionary(tokens);\n    const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\n    const production = services.LanguageMetaData.mode === \"production\";\n    this.chevrotainLexer = new Lexer(lexerTokens, {\n      positionTracking: \"full\",\n      skipValidations: production,\n      errorMessageProvider: this.errorMessageProvider\n    });\n  }\n  get definition() {\n    return this.tokenTypes;\n  }\n  tokenize(text, _options = DEFAULT_TOKENIZE_OPTIONS) {\n    var _a2, _b2, _c2;\n    const chevrotainResult = this.chevrotainLexer.tokenize(text);\n    return {\n      tokens: chevrotainResult.tokens,\n      errors: chevrotainResult.errors,\n      hidden: (_a2 = chevrotainResult.groups.hidden) !== null && _a2 !== void 0 ? _a2 : [],\n      report: (_c2 = (_b2 = this.tokenBuilder).flushLexingReport) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, text)\n    };\n  }\n  toTokenTypeDictionary(buildTokens) {\n    if (isTokenTypeDictionary(buildTokens))\n      return buildTokens;\n    const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\n    const res = {};\n    tokens.forEach((token) => res[token.name] = token);\n    return res;\n  }\n}\nfunction isTokenTypeArray(tokenVocabulary) {\n  return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || \"name\" in tokenVocabulary[0]);\n}\nfunction isIMultiModeLexerDefinition(tokenVocabulary) {\n  return tokenVocabulary && \"modes\" in tokenVocabulary && \"defaultMode\" in tokenVocabulary;\n}\nfunction isTokenTypeDictionary(tokenVocabulary) {\n  return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\n}\nfunction parseJSDoc(node, start, options) {\n  let opts;\n  let position;\n  if (typeof node === \"string\") {\n    position = start;\n    opts = options;\n  } else {\n    position = node.range.start;\n    opts = start;\n  }\n  if (!position) {\n    position = Position.create(0, 0);\n  }\n  const lines = getLines(node);\n  const normalizedOptions = normalizeOptions(opts);\n  const tokens = tokenize({\n    lines,\n    position,\n    options: normalizedOptions\n  });\n  return parseJSDocComment({\n    index: 0,\n    tokens,\n    position\n  });\n}\nfunction isJSDoc(node, options) {\n  const normalizedOptions = normalizeOptions(options);\n  const lines = getLines(node);\n  if (lines.length === 0) {\n    return false;\n  }\n  const first2 = lines[0];\n  const last2 = lines[lines.length - 1];\n  const firstRegex = normalizedOptions.start;\n  const lastRegex = normalizedOptions.end;\n  return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first2)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last2));\n}\nfunction getLines(node) {\n  let content = \"\";\n  if (typeof node === \"string\") {\n    content = node;\n  } else {\n    content = node.text;\n  }\n  const lines = content.split(NEWLINE_REGEXP);\n  return lines;\n}\nconst tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\nconst inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\nfunction tokenize(context) {\n  var _a2, _b2, _c2;\n  const tokens = [];\n  let currentLine = context.position.line;\n  let currentCharacter = context.position.character;\n  for (let i = 0; i < context.lines.length; i++) {\n    const first2 = i === 0;\n    const last2 = i === context.lines.length - 1;\n    let line = context.lines[i];\n    let index = 0;\n    if (first2 && context.options.start) {\n      const match = (_a2 = context.options.start) === null || _a2 === void 0 ? void 0 : _a2.exec(line);\n      if (match) {\n        index = match.index + match[0].length;\n      }\n    } else {\n      const match = (_b2 = context.options.line) === null || _b2 === void 0 ? void 0 : _b2.exec(line);\n      if (match) {\n        index = match.index + match[0].length;\n      }\n    }\n    if (last2) {\n      const match = (_c2 = context.options.end) === null || _c2 === void 0 ? void 0 : _c2.exec(line);\n      if (match) {\n        line = line.substring(0, match.index);\n      }\n    }\n    line = line.substring(0, lastCharacter(line));\n    const whitespaceEnd = skipWhitespace(line, index);\n    if (whitespaceEnd >= line.length) {\n      if (tokens.length > 0) {\n        const position = Position.create(currentLine, currentCharacter);\n        tokens.push({\n          type: \"break\",\n          content: \"\",\n          range: Range.create(position, position)\n        });\n      }\n    } else {\n      tagRegex.lastIndex = index;\n      const tagMatch = tagRegex.exec(line);\n      if (tagMatch) {\n        const fullMatch = tagMatch[0];\n        const value = tagMatch[1];\n        const start = Position.create(currentLine, currentCharacter + index);\n        const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);\n        tokens.push({\n          type: \"tag\",\n          content: value,\n          range: Range.create(start, end)\n        });\n        index += fullMatch.length;\n        index = skipWhitespace(line, index);\n      }\n      if (index < line.length) {\n        const rest = line.substring(index);\n        const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\n        tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\n      }\n    }\n    currentLine++;\n    currentCharacter = 0;\n  }\n  if (tokens.length > 0 && tokens[tokens.length - 1].type === \"break\") {\n    return tokens.slice(0, -1);\n  }\n  return tokens;\n}\nfunction buildInlineTokens(tags, line, lineIndex, characterIndex) {\n  const tokens = [];\n  if (tags.length === 0) {\n    const start = Position.create(lineIndex, characterIndex);\n    const end = Position.create(lineIndex, characterIndex + line.length);\n    tokens.push({\n      type: \"text\",\n      content: line,\n      range: Range.create(start, end)\n    });\n  } else {\n    let lastIndex = 0;\n    for (const match of tags) {\n      const matchIndex = match.index;\n      const startContent = line.substring(lastIndex, matchIndex);\n      if (startContent.length > 0) {\n        tokens.push({\n          type: \"text\",\n          content: line.substring(lastIndex, matchIndex),\n          range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, matchIndex + characterIndex))\n        });\n      }\n      let offset = startContent.length + 1;\n      const tagName = match[1];\n      tokens.push({\n        type: \"inline-tag\",\n        content: tagName,\n        range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))\n      });\n      offset += tagName.length;\n      if (match.length === 4) {\n        offset += match[2].length;\n        const value = match[3];\n        tokens.push({\n          type: \"text\",\n          content: value,\n          range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))\n        });\n      } else {\n        tokens.push({\n          type: \"text\",\n          content: \"\",\n          range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + characterIndex))\n        });\n      }\n      lastIndex = matchIndex + match[0].length;\n    }\n    const endContent = line.substring(lastIndex);\n    if (endContent.length > 0) {\n      tokens.push({\n        type: \"text\",\n        content: endContent,\n        range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, lastIndex + characterIndex + endContent.length))\n      });\n    }\n  }\n  return tokens;\n}\nconst nonWhitespaceRegex = /\\S/;\nconst whitespaceEndRegex = /\\s*$/;\nfunction skipWhitespace(line, index) {\n  const match = line.substring(index).match(nonWhitespaceRegex);\n  if (match) {\n    return index + match.index;\n  } else {\n    return line.length;\n  }\n}\nfunction lastCharacter(line) {\n  const match = line.match(whitespaceEndRegex);\n  if (match && typeof match.index === \"number\") {\n    return match.index;\n  }\n  return void 0;\n}\nfunction parseJSDocComment(context) {\n  var _a2, _b2, _c2, _d2;\n  const startPosition = Position.create(context.position.line, context.position.character);\n  if (context.tokens.length === 0) {\n    return new JSDocCommentImpl([], Range.create(startPosition, startPosition));\n  }\n  const elements = [];\n  while (context.index < context.tokens.length) {\n    const element = parseJSDocElement(context, elements[elements.length - 1]);\n    if (element) {\n      elements.push(element);\n    }\n  }\n  const start = (_b2 = (_a2 = elements[0]) === null || _a2 === void 0 ? void 0 : _a2.range.start) !== null && _b2 !== void 0 ? _b2 : startPosition;\n  const end = (_d2 = (_c2 = elements[elements.length - 1]) === null || _c2 === void 0 ? void 0 : _c2.range.end) !== null && _d2 !== void 0 ? _d2 : startPosition;\n  return new JSDocCommentImpl(elements, Range.create(start, end));\n}\nfunction parseJSDocElement(context, last2) {\n  const next = context.tokens[context.index];\n  if (next.type === \"tag\") {\n    return parseJSDocTag(context, false);\n  } else if (next.type === \"text\" || next.type === \"inline-tag\") {\n    return parseJSDocText(context);\n  } else {\n    appendEmptyLine(next, last2);\n    context.index++;\n    return void 0;\n  }\n}\nfunction appendEmptyLine(token, element) {\n  if (element) {\n    const line = new JSDocLineImpl(\"\", token.range);\n    if (\"inlines\" in element) {\n      element.inlines.push(line);\n    } else {\n      element.content.inlines.push(line);\n    }\n  }\n}\nfunction parseJSDocText(context) {\n  let token = context.tokens[context.index];\n  const firstToken = token;\n  let lastToken = token;\n  const lines = [];\n  while (token && token.type !== \"break\" && token.type !== \"tag\") {\n    lines.push(parseJSDocInline(context));\n    lastToken = token;\n    token = context.tokens[context.index];\n  }\n  return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));\n}\nfunction parseJSDocInline(context) {\n  const token = context.tokens[context.index];\n  if (token.type === \"inline-tag\") {\n    return parseJSDocTag(context, true);\n  } else {\n    return parseJSDocLine(context);\n  }\n}\nfunction parseJSDocTag(context, inline) {\n  const tagToken = context.tokens[context.index++];\n  const name = tagToken.content.substring(1);\n  const nextToken = context.tokens[context.index];\n  if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === \"text\") {\n    if (inline) {\n      const docLine = parseJSDocLine(context);\n      return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, Range.create(tagToken.range.start, docLine.range.end));\n    } else {\n      const textDoc = parseJSDocText(context);\n      return new JSDocTagImpl(name, textDoc, inline, Range.create(tagToken.range.start, textDoc.range.end));\n    }\n  } else {\n    const range = tagToken.range;\n    return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\n  }\n}\nfunction parseJSDocLine(context) {\n  const token = context.tokens[context.index++];\n  return new JSDocLineImpl(token.content, token.range);\n}\nfunction normalizeOptions(options) {\n  if (!options) {\n    return normalizeOptions({\n      start: \"/**\",\n      end: \"*/\",\n      line: \"*\"\n    });\n  }\n  const { start, end, line } = options;\n  return {\n    start: normalizeOption(start, true),\n    end: normalizeOption(end, false),\n    line: normalizeOption(line, true)\n  };\n}\nfunction normalizeOption(option2, start) {\n  if (typeof option2 === \"string\" || typeof option2 === \"object\") {\n    const escaped = typeof option2 === \"string\" ? escapeRegExp(option2) : option2.source;\n    if (start) {\n      return new RegExp(`^\\\\s*${escaped}`);\n    } else {\n      return new RegExp(`\\\\s*${escaped}\\\\s*$`);\n    }\n  } else {\n    return option2;\n  }\n}\nclass JSDocCommentImpl {\n  constructor(elements, range) {\n    this.elements = elements;\n    this.range = range;\n  }\n  getTag(name) {\n    return this.getAllTags().find((e) => e.name === name);\n  }\n  getTags(name) {\n    return this.getAllTags().filter((e) => e.name === name);\n  }\n  getAllTags() {\n    return this.elements.filter((e) => \"name\" in e);\n  }\n  toString() {\n    let value = \"\";\n    for (const element of this.elements) {\n      if (value.length === 0) {\n        value = element.toString();\n      } else {\n        const text = element.toString();\n        value += fillNewlines(value) + text;\n      }\n    }\n    return value.trim();\n  }\n  toMarkdown(options) {\n    let value = \"\";\n    for (const element of this.elements) {\n      if (value.length === 0) {\n        value = element.toMarkdown(options);\n      } else {\n        const text = element.toMarkdown(options);\n        value += fillNewlines(value) + text;\n      }\n    }\n    return value.trim();\n  }\n}\nclass JSDocTagImpl {\n  constructor(name, content, inline, range) {\n    this.name = name;\n    this.content = content;\n    this.inline = inline;\n    this.range = range;\n  }\n  toString() {\n    let text = `@${this.name}`;\n    const content = this.content.toString();\n    if (this.content.inlines.length === 1) {\n      text = `${text} ${content}`;\n    } else if (this.content.inlines.length > 1) {\n      text = `${text}\n${content}`;\n    }\n    if (this.inline) {\n      return `{${text}}`;\n    } else {\n      return text;\n    }\n  }\n  toMarkdown(options) {\n    var _a2, _b2;\n    return (_b2 = (_a2 = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a2 === void 0 ? void 0 : _a2.call(options, this)) !== null && _b2 !== void 0 ? _b2 : this.toMarkdownDefault(options);\n  }\n  toMarkdownDefault(options) {\n    const content = this.content.toMarkdown(options);\n    if (this.inline) {\n      const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});\n      if (typeof rendered === \"string\") {\n        return rendered;\n      }\n    }\n    let marker = \"\";\n    if ((options === null || options === void 0 ? void 0 : options.tag) === \"italic\" || (options === null || options === void 0 ? void 0 : options.tag) === void 0) {\n      marker = \"*\";\n    } else if ((options === null || options === void 0 ? void 0 : options.tag) === \"bold\") {\n      marker = \"**\";\n    } else if ((options === null || options === void 0 ? void 0 : options.tag) === \"bold-italic\") {\n      marker = \"***\";\n    }\n    let text = `${marker}@${this.name}${marker}`;\n    if (this.content.inlines.length === 1) {\n      text = `${text} — ${content}`;\n    } else if (this.content.inlines.length > 1) {\n      text = `${text}\n${content}`;\n    }\n    if (this.inline) {\n      return `{${text}}`;\n    } else {\n      return text;\n    }\n  }\n}\nfunction renderInlineTag(tag, content, options) {\n  var _a2, _b2;\n  if (tag === \"linkplain\" || tag === \"linkcode\" || tag === \"link\") {\n    const index = content.indexOf(\" \");\n    let display = content;\n    if (index > 0) {\n      const displayStart = skipWhitespace(content, index);\n      display = content.substring(displayStart);\n      content = content.substring(0, index);\n    }\n    if (tag === \"linkcode\" || tag === \"link\" && options.link === \"code\") {\n      display = `\\`${display}\\``;\n    }\n    const renderedLink = (_b2 = (_a2 = options.renderLink) === null || _a2 === void 0 ? void 0 : _a2.call(options, content, display)) !== null && _b2 !== void 0 ? _b2 : renderLinkDefault(content, display);\n    return renderedLink;\n  }\n  return void 0;\n}\nfunction renderLinkDefault(content, display) {\n  try {\n    URI.parse(content, true);\n    return `[${display}](${content})`;\n  } catch (_a2) {\n    return content;\n  }\n}\nclass JSDocTextImpl {\n  constructor(lines, range) {\n    this.inlines = lines;\n    this.range = range;\n  }\n  toString() {\n    let text = \"\";\n    for (let i = 0; i < this.inlines.length; i++) {\n      const inline = this.inlines[i];\n      const next = this.inlines[i + 1];\n      text += inline.toString();\n      if (next && next.range.start.line > inline.range.start.line) {\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n  toMarkdown(options) {\n    let text = \"\";\n    for (let i = 0; i < this.inlines.length; i++) {\n      const inline = this.inlines[i];\n      const next = this.inlines[i + 1];\n      text += inline.toMarkdown(options);\n      if (next && next.range.start.line > inline.range.start.line) {\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n}\nclass JSDocLineImpl {\n  constructor(text, range) {\n    this.text = text;\n    this.range = range;\n  }\n  toString() {\n    return this.text;\n  }\n  toMarkdown() {\n    return this.text;\n  }\n}\nfunction fillNewlines(text) {\n  if (text.endsWith(\"\\n\")) {\n    return \"\\n\";\n  } else {\n    return \"\\n\\n\";\n  }\n}\nclass JSDocDocumentationProvider {\n  constructor(services) {\n    this.indexManager = services.shared.workspace.IndexManager;\n    this.commentProvider = services.documentation.CommentProvider;\n  }\n  getDocumentation(node) {\n    const comment = this.commentProvider.getComment(node);\n    if (comment && isJSDoc(comment)) {\n      const parsedJSDoc = parseJSDoc(comment);\n      return parsedJSDoc.toMarkdown({\n        renderLink: (link, display) => {\n          return this.documentationLinkRenderer(node, link, display);\n        },\n        renderTag: (tag) => {\n          return this.documentationTagRenderer(node, tag);\n        }\n      });\n    }\n    return void 0;\n  }\n  documentationLinkRenderer(node, name, display) {\n    var _a2;\n    const description = (_a2 = this.findNameInPrecomputedScopes(node, name)) !== null && _a2 !== void 0 ? _a2 : this.findNameInGlobalScope(node, name);\n    if (description && description.nameSegment) {\n      const line = description.nameSegment.range.start.line + 1;\n      const character = description.nameSegment.range.start.character + 1;\n      const uri = description.documentUri.with({ fragment: `L${line},${character}` });\n      return `[${display}](${uri.toString()})`;\n    } else {\n      return void 0;\n    }\n  }\n  documentationTagRenderer(_node, _tag) {\n    return void 0;\n  }\n  findNameInPrecomputedScopes(node, name) {\n    const document = getDocument(node);\n    const precomputed = document.precomputedScopes;\n    if (!precomputed) {\n      return void 0;\n    }\n    let currentNode = node;\n    do {\n      const allDescriptions = precomputed.get(currentNode);\n      const description = allDescriptions.find((e) => e.name === name);\n      if (description) {\n        return description;\n      }\n      currentNode = currentNode.$container;\n    } while (currentNode);\n    return void 0;\n  }\n  findNameInGlobalScope(node, name) {\n    const description = this.indexManager.allElements().find((e) => e.name === name);\n    return description;\n  }\n}\nclass DefaultCommentProvider {\n  constructor(services) {\n    this.grammarConfig = () => services.parser.GrammarConfig;\n  }\n  getComment(node) {\n    var _a2;\n    if (isAstNodeWithComment(node)) {\n      return node.$comment;\n    }\n    return (_a2 = findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a2 === void 0 ? void 0 : _a2.text;\n  }\n}\nclass DefaultAsyncParser {\n  constructor(services) {\n    this.syncParser = services.parser.LangiumParser;\n  }\n  parse(text, _cancelToken) {\n    return Promise.resolve(this.syncParser.parse(text));\n  }\n}\nclass DefaultWorkspaceLock {\n  constructor() {\n    this.previousTokenSource = new cancellationExports.CancellationTokenSource();\n    this.writeQueue = [];\n    this.readQueue = [];\n    this.done = true;\n  }\n  write(action) {\n    this.cancelWrite();\n    const tokenSource = startCancelableOperation();\n    this.previousTokenSource = tokenSource;\n    return this.enqueue(this.writeQueue, action, tokenSource.token);\n  }\n  read(action) {\n    return this.enqueue(this.readQueue, action);\n  }\n  enqueue(queue, action, cancellationToken = cancellationExports.CancellationToken.None) {\n    const deferred = new Deferred();\n    const entry = {\n      action,\n      deferred,\n      cancellationToken\n    };\n    queue.push(entry);\n    this.performNextOperation();\n    return deferred.promise;\n  }\n  async performNextOperation() {\n    if (!this.done) {\n      return;\n    }\n    const entries = [];\n    if (this.writeQueue.length > 0) {\n      entries.push(this.writeQueue.shift());\n    } else if (this.readQueue.length > 0) {\n      entries.push(...this.readQueue.splice(0, this.readQueue.length));\n    } else {\n      return;\n    }\n    this.done = false;\n    await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {\n      try {\n        const result = await Promise.resolve().then(() => action(cancellationToken));\n        deferred.resolve(result);\n      } catch (err) {\n        if (isOperationCancelled(err)) {\n          deferred.resolve(void 0);\n        } else {\n          deferred.reject(err);\n        }\n      }\n    }));\n    this.done = true;\n    this.performNextOperation();\n  }\n  cancelWrite() {\n    this.previousTokenSource.cancel();\n  }\n}\nclass DefaultHydrator {\n  constructor(services) {\n    this.grammarElementIdMap = new BiMap();\n    this.tokenTypeIdMap = new BiMap();\n    this.grammar = services.Grammar;\n    this.lexer = services.parser.Lexer;\n    this.linker = services.references.Linker;\n  }\n  dehydrate(result) {\n    return {\n      lexerErrors: result.lexerErrors,\n      lexerReport: result.lexerReport ? this.dehydrateLexerReport(result.lexerReport) : void 0,\n      // We need to create shallow copies of the errors\n      // The original errors inherit from the `Error` class, which is not transferable across worker threads\n      parserErrors: result.parserErrors.map((e) => Object.assign(Object.assign({}, e), { message: e.message })),\n      value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\n    };\n  }\n  dehydrateLexerReport(lexerReport) {\n    return lexerReport;\n  }\n  createDehyrationContext(node) {\n    const astNodes = /* @__PURE__ */ new Map();\n    const cstNodes = /* @__PURE__ */ new Map();\n    for (const astNode of streamAst(node)) {\n      astNodes.set(astNode, {});\n    }\n    if (node.$cstNode) {\n      for (const cstNode of streamCst(node.$cstNode)) {\n        cstNodes.set(cstNode, {});\n      }\n    }\n    return {\n      astNodes,\n      cstNodes\n    };\n  }\n  dehydrateAstNode(node, context) {\n    const obj = context.astNodes.get(node);\n    obj.$type = node.$type;\n    obj.$containerIndex = node.$containerIndex;\n    obj.$containerProperty = node.$containerProperty;\n    if (node.$cstNode !== void 0) {\n      obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\n    }\n    for (const [name, value] of Object.entries(node)) {\n      if (name.startsWith(\"$\")) {\n        continue;\n      }\n      if (Array.isArray(value)) {\n        const arr = [];\n        obj[name] = arr;\n        for (const item of value) {\n          if (isAstNode(item)) {\n            arr.push(this.dehydrateAstNode(item, context));\n          } else if (isReference(item)) {\n            arr.push(this.dehydrateReference(item, context));\n          } else {\n            arr.push(item);\n          }\n        }\n      } else if (isAstNode(value)) {\n        obj[name] = this.dehydrateAstNode(value, context);\n      } else if (isReference(value)) {\n        obj[name] = this.dehydrateReference(value, context);\n      } else if (value !== void 0) {\n        obj[name] = value;\n      }\n    }\n    return obj;\n  }\n  dehydrateReference(reference, context) {\n    const obj = {};\n    obj.$refText = reference.$refText;\n    if (reference.$refNode) {\n      obj.$refNode = context.cstNodes.get(reference.$refNode);\n    }\n    return obj;\n  }\n  dehydrateCstNode(node, context) {\n    const cstNode = context.cstNodes.get(node);\n    if (isRootCstNode(node)) {\n      cstNode.fullText = node.fullText;\n    } else {\n      cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\n    }\n    cstNode.hidden = node.hidden;\n    cstNode.astNode = context.astNodes.get(node.astNode);\n    if (isCompositeCstNode(node)) {\n      cstNode.content = node.content.map((child) => this.dehydrateCstNode(child, context));\n    } else if (isLeafCstNode(node)) {\n      cstNode.tokenType = node.tokenType.name;\n      cstNode.offset = node.offset;\n      cstNode.length = node.length;\n      cstNode.startLine = node.range.start.line;\n      cstNode.startColumn = node.range.start.character;\n      cstNode.endLine = node.range.end.line;\n      cstNode.endColumn = node.range.end.character;\n    }\n    return cstNode;\n  }\n  hydrate(result) {\n    const node = result.value;\n    const context = this.createHydrationContext(node);\n    if (\"$cstNode\" in node) {\n      this.hydrateCstNode(node.$cstNode, context);\n    }\n    return {\n      lexerErrors: result.lexerErrors,\n      lexerReport: result.lexerReport,\n      parserErrors: result.parserErrors,\n      value: this.hydrateAstNode(node, context)\n    };\n  }\n  createHydrationContext(node) {\n    const astNodes = /* @__PURE__ */ new Map();\n    const cstNodes = /* @__PURE__ */ new Map();\n    for (const astNode of streamAst(node)) {\n      astNodes.set(astNode, {});\n    }\n    let root;\n    if (node.$cstNode) {\n      for (const cstNode of streamCst(node.$cstNode)) {\n        let cst;\n        if (\"fullText\" in cstNode) {\n          cst = new RootCstNodeImpl(cstNode.fullText);\n          root = cst;\n        } else if (\"content\" in cstNode) {\n          cst = new CompositeCstNodeImpl();\n        } else if (\"tokenType\" in cstNode) {\n          cst = this.hydrateCstLeafNode(cstNode);\n        }\n        if (cst) {\n          cstNodes.set(cstNode, cst);\n          cst.root = root;\n        }\n      }\n    }\n    return {\n      astNodes,\n      cstNodes\n    };\n  }\n  hydrateAstNode(node, context) {\n    const astNode = context.astNodes.get(node);\n    astNode.$type = node.$type;\n    astNode.$containerIndex = node.$containerIndex;\n    astNode.$containerProperty = node.$containerProperty;\n    if (node.$cstNode) {\n      astNode.$cstNode = context.cstNodes.get(node.$cstNode);\n    }\n    for (const [name, value] of Object.entries(node)) {\n      if (name.startsWith(\"$\")) {\n        continue;\n      }\n      if (Array.isArray(value)) {\n        const arr = [];\n        astNode[name] = arr;\n        for (const item of value) {\n          if (isAstNode(item)) {\n            arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\n          } else if (isReference(item)) {\n            arr.push(this.hydrateReference(item, astNode, name, context));\n          } else {\n            arr.push(item);\n          }\n        }\n      } else if (isAstNode(value)) {\n        astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\n      } else if (isReference(value)) {\n        astNode[name] = this.hydrateReference(value, astNode, name, context);\n      } else if (value !== void 0) {\n        astNode[name] = value;\n      }\n    }\n    return astNode;\n  }\n  setParent(node, parent) {\n    node.$container = parent;\n    return node;\n  }\n  hydrateReference(reference, node, name, context) {\n    return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);\n  }\n  hydrateCstNode(cstNode, context, num = 0) {\n    const cstNodeObj = context.cstNodes.get(cstNode);\n    if (typeof cstNode.grammarSource === \"number\") {\n      cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\n    }\n    cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);\n    if (isCompositeCstNode(cstNodeObj)) {\n      for (const child of cstNode.content) {\n        const hydrated = this.hydrateCstNode(child, context, num++);\n        cstNodeObj.content.push(hydrated);\n      }\n    }\n    return cstNodeObj;\n  }\n  hydrateCstLeafNode(cstNode) {\n    const tokenType = this.getTokenType(cstNode.tokenType);\n    const offset = cstNode.offset;\n    const length = cstNode.length;\n    const startLine = cstNode.startLine;\n    const startColumn = cstNode.startColumn;\n    const endLine = cstNode.endLine;\n    const endColumn = cstNode.endColumn;\n    const hidden = cstNode.hidden;\n    const node = new LeafCstNodeImpl(offset, length, {\n      start: {\n        line: startLine,\n        character: startColumn\n      },\n      end: {\n        line: endLine,\n        character: endColumn\n      }\n    }, tokenType, hidden);\n    return node;\n  }\n  getTokenType(name) {\n    return this.lexer.definition[name];\n  }\n  getGrammarElementId(node) {\n    if (!node) {\n      return void 0;\n    }\n    if (this.grammarElementIdMap.size === 0) {\n      this.createGrammarElementIdMap();\n    }\n    return this.grammarElementIdMap.get(node);\n  }\n  getGrammarElement(id) {\n    if (this.grammarElementIdMap.size === 0) {\n      this.createGrammarElementIdMap();\n    }\n    const element = this.grammarElementIdMap.getKey(id);\n    return element;\n  }\n  createGrammarElementIdMap() {\n    let id = 0;\n    for (const element of streamAst(this.grammar)) {\n      if (isAbstractElement(element)) {\n        this.grammarElementIdMap.set(element, id++);\n      }\n    }\n  }\n}\nfunction createDefaultCoreModule(context) {\n  return {\n    documentation: {\n      CommentProvider: (services) => new DefaultCommentProvider(services),\n      DocumentationProvider: (services) => new JSDocDocumentationProvider(services)\n    },\n    parser: {\n      AsyncParser: (services) => new DefaultAsyncParser(services),\n      GrammarConfig: (services) => createGrammarConfig(services),\n      LangiumParser: (services) => createLangiumParser(services),\n      CompletionParser: (services) => createCompletionParser(services),\n      ValueConverter: () => new DefaultValueConverter(),\n      TokenBuilder: () => new DefaultTokenBuilder(),\n      Lexer: (services) => new DefaultLexer(services),\n      ParserErrorMessageProvider: () => new LangiumParserErrorMessageProvider(),\n      LexerErrorMessageProvider: () => new DefaultLexerErrorMessageProvider()\n    },\n    workspace: {\n      AstNodeLocator: () => new DefaultAstNodeLocator(),\n      AstNodeDescriptionProvider: (services) => new DefaultAstNodeDescriptionProvider(services),\n      ReferenceDescriptionProvider: (services) => new DefaultReferenceDescriptionProvider(services)\n    },\n    references: {\n      Linker: (services) => new DefaultLinker(services),\n      NameProvider: () => new DefaultNameProvider(),\n      ScopeProvider: (services) => new DefaultScopeProvider(services),\n      ScopeComputation: (services) => new DefaultScopeComputation(services),\n      References: (services) => new DefaultReferences(services)\n    },\n    serializer: {\n      Hydrator: (services) => new DefaultHydrator(services),\n      JsonSerializer: (services) => new DefaultJsonSerializer(services)\n    },\n    validation: {\n      DocumentValidator: (services) => new DefaultDocumentValidator(services),\n      ValidationRegistry: (services) => new ValidationRegistry(services)\n    },\n    shared: () => context.shared\n  };\n}\nfunction createDefaultSharedCoreModule(context) {\n  return {\n    ServiceRegistry: (services) => new DefaultServiceRegistry(services),\n    workspace: {\n      LangiumDocuments: (services) => new DefaultLangiumDocuments(services),\n      LangiumDocumentFactory: (services) => new DefaultLangiumDocumentFactory(services),\n      DocumentBuilder: (services) => new DefaultDocumentBuilder(services),\n      IndexManager: (services) => new DefaultIndexManager(services),\n      WorkspaceManager: (services) => new DefaultWorkspaceManager(services),\n      FileSystemProvider: (services) => context.fileSystemProvider(services),\n      WorkspaceLock: () => new DefaultWorkspaceLock(),\n      ConfigurationProvider: (services) => new DefaultConfigurationProvider(services)\n    }\n  };\n}\nvar Module;\n(function(Module2) {\n  Module2.merge = (m1, m2) => _merge(_merge({}, m1), m2);\n})(Module || (Module = {}));\nfunction inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {\n  const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});\n  return _inject(module);\n}\nconst isProxy = Symbol(\"isProxy\");\nfunction _inject(module, injector) {\n  const proxy = new Proxy({}, {\n    deleteProperty: () => false,\n    set: () => {\n      throw new Error(\"Cannot set property on injected service container\");\n    },\n    get: (obj, prop) => {\n      if (prop === isProxy) {\n        return true;\n      } else {\n        return _resolve(obj, prop, module, injector || proxy);\n      }\n    },\n    getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)),\n    // used by for..in\n    has: (_, prop) => prop in module,\n    // used by ..in..\n    ownKeys: () => [...Object.getOwnPropertyNames(module)]\n    // used by for..in\n  });\n  return proxy;\n}\nconst __requested__ = Symbol();\nfunction _resolve(obj, prop, module, injector) {\n  if (prop in obj) {\n    if (obj[prop] instanceof Error) {\n      throw new Error(\"Construction failure. Please make sure that your dependencies are constructable.\", { cause: obj[prop] });\n    }\n    if (obj[prop] === __requested__) {\n      throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');\n    }\n    return obj[prop];\n  } else if (prop in module) {\n    const value = module[prop];\n    obj[prop] = __requested__;\n    try {\n      obj[prop] = typeof value === \"function\" ? value(injector) : _inject(value, injector);\n    } catch (error) {\n      obj[prop] = error instanceof Error ? error : void 0;\n      throw error;\n    }\n    return obj[prop];\n  } else {\n    return void 0;\n  }\n}\nfunction _merge(target, source) {\n  if (source) {\n    for (const [key, value2] of Object.entries(source)) {\n      if (value2 !== void 0) {\n        const value1 = target[key];\n        if (value1 !== null && value2 !== null && typeof value1 === \"object\" && typeof value2 === \"object\") {\n          target[key] = _merge(value1, value2);\n        } else {\n          target[key] = value2;\n        }\n      }\n    }\n  }\n  return target;\n}\nclass EmptyFileSystemProvider {\n  readFile() {\n    throw new Error(\"No file system is available.\");\n  }\n  async readDirectory() {\n    return [];\n  }\n}\nconst EmptyFileSystem = {\n  fileSystemProvider: () => new EmptyFileSystemProvider()\n};\nconst minimalGrammarModule = {\n  Grammar: () => void 0,\n  LanguageMetaData: () => ({\n    caseInsensitive: false,\n    fileExtensions: [\".langium\"],\n    languageId: \"langium\"\n  })\n};\nconst minimalSharedGrammarModule = {\n  AstReflection: () => new LangiumGrammarAstReflection()\n};\nfunction createMinimalGrammarServices() {\n  const shared = inject(createDefaultSharedCoreModule(EmptyFileSystem), minimalSharedGrammarModule);\n  const grammar = inject(createDefaultCoreModule({ shared }), minimalGrammarModule);\n  shared.ServiceRegistry.register(grammar);\n  return grammar;\n}\nfunction loadGrammarFromJson(json) {\n  var _a2;\n  const services = createMinimalGrammarServices();\n  const astNode = services.serializer.JsonSerializer.deserialize(json);\n  services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI.parse(`memory://${(_a2 = astNode.name) !== null && _a2 !== void 0 ? _a2 : \"grammar\"}.langium`));\n  return astNode;\n}\nvar __defProp2 = Object.defineProperty;\nvar __name = (target, value) => __defProp2(target, \"name\", { value, configurable: true });\nvar Statement = \"Statement\";\nvar Architecture = \"Architecture\";\nfunction isArchitecture(item) {\n  return reflection.isInstance(item, Architecture);\n}\n__name(isArchitecture, \"isArchitecture\");\nvar Axis = \"Axis\";\nvar Branch = \"Branch\";\nfunction isBranch(item) {\n  return reflection.isInstance(item, Branch);\n}\n__name(isBranch, \"isBranch\");\nvar Checkout = \"Checkout\";\nvar CherryPicking = \"CherryPicking\";\nvar Commit = \"Commit\";\nfunction isCommit(item) {\n  return reflection.isInstance(item, Commit);\n}\n__name(isCommit, \"isCommit\");\nvar Common = \"Common\";\nfunction isCommon(item) {\n  return reflection.isInstance(item, Common);\n}\n__name(isCommon, \"isCommon\");\nvar Curve = \"Curve\";\nvar Edge = \"Edge\";\nvar Entry = \"Entry\";\nvar GitGraph = \"GitGraph\";\nfunction isGitGraph(item) {\n  return reflection.isInstance(item, GitGraph);\n}\n__name(isGitGraph, \"isGitGraph\");\nvar Group = \"Group\";\nvar Info = \"Info\";\nfunction isInfo(item) {\n  return reflection.isInstance(item, Info);\n}\n__name(isInfo, \"isInfo\");\nvar Junction = \"Junction\";\nvar Merge = \"Merge\";\nfunction isMerge(item) {\n  return reflection.isInstance(item, Merge);\n}\n__name(isMerge, \"isMerge\");\nvar Option2 = \"Option\";\nvar Packet = \"Packet\";\nfunction isPacket(item) {\n  return reflection.isInstance(item, Packet);\n}\n__name(isPacket, \"isPacket\");\nvar PacketBlock = \"PacketBlock\";\nfunction isPacketBlock(item) {\n  return reflection.isInstance(item, PacketBlock);\n}\n__name(isPacketBlock, \"isPacketBlock\");\nvar Pie = \"Pie\";\nfunction isPie(item) {\n  return reflection.isInstance(item, Pie);\n}\n__name(isPie, \"isPie\");\nvar PieSection = \"PieSection\";\nfunction isPieSection(item) {\n  return reflection.isInstance(item, PieSection);\n}\n__name(isPieSection, \"isPieSection\");\nvar Radar = \"Radar\";\nvar Service = \"Service\";\nvar Direction = \"Direction\";\nvar MermaidAstReflection = (_a = class extends AbstractAstReflection {\n  getAllTypes() {\n    return [Architecture, Axis, Branch, Checkout, CherryPicking, Commit, Common, Curve, Direction, Edge, Entry, GitGraph, Group, Info, Junction, Merge, Option2, Packet, PacketBlock, Pie, PieSection, Radar, Service, Statement];\n  }\n  computeIsSubtype(subtype, supertype) {\n    switch (subtype) {\n      case Branch:\n      case Checkout:\n      case CherryPicking:\n      case Commit:\n      case Merge: {\n        return this.isSubtype(Statement, supertype);\n      }\n      case Direction: {\n        return this.isSubtype(GitGraph, supertype);\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n  getReferenceType(refInfo) {\n    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n    switch (referenceId) {\n      case \"Entry:axis\": {\n        return Axis;\n      }\n      default: {\n        throw new Error(`${referenceId} is not a valid reference id.`);\n      }\n    }\n  }\n  getTypeMetaData(type) {\n    switch (type) {\n      case Architecture: {\n        return {\n          name: Architecture,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"edges\", defaultValue: [] },\n            { name: \"groups\", defaultValue: [] },\n            { name: \"junctions\", defaultValue: [] },\n            { name: \"services\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Axis: {\n        return {\n          name: Axis,\n          properties: [\n            { name: \"label\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Branch: {\n        return {\n          name: Branch,\n          properties: [\n            { name: \"name\" },\n            { name: \"order\" }\n          ]\n        };\n      }\n      case Checkout: {\n        return {\n          name: Checkout,\n          properties: [\n            { name: \"branch\" }\n          ]\n        };\n      }\n      case CherryPicking: {\n        return {\n          name: CherryPicking,\n          properties: [\n            { name: \"id\" },\n            { name: \"parent\" },\n            { name: \"tags\", defaultValue: [] }\n          ]\n        };\n      }\n      case Commit: {\n        return {\n          name: Commit,\n          properties: [\n            { name: \"id\" },\n            { name: \"message\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Common: {\n        return {\n          name: Common,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Curve: {\n        return {\n          name: Curve,\n          properties: [\n            { name: \"entries\", defaultValue: [] },\n            { name: \"label\" },\n            { name: \"name\" }\n          ]\n        };\n      }\n      case Edge: {\n        return {\n          name: Edge,\n          properties: [\n            { name: \"lhsDir\" },\n            { name: \"lhsGroup\", defaultValue: false },\n            { name: \"lhsId\" },\n            { name: \"lhsInto\", defaultValue: false },\n            { name: \"rhsDir\" },\n            { name: \"rhsGroup\", defaultValue: false },\n            { name: \"rhsId\" },\n            { name: \"rhsInto\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Entry: {\n        return {\n          name: Entry,\n          properties: [\n            { name: \"axis\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case GitGraph: {\n        return {\n          name: GitGraph,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Group: {\n        return {\n          name: Group,\n          properties: [\n            { name: \"icon\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Info: {\n        return {\n          name: Info,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Junction: {\n        return {\n          name: Junction,\n          properties: [\n            { name: \"id\" },\n            { name: \"in\" }\n          ]\n        };\n      }\n      case Merge: {\n        return {\n          name: Merge,\n          properties: [\n            { name: \"branch\" },\n            { name: \"id\" },\n            { name: \"tags\", defaultValue: [] },\n            { name: \"type\" }\n          ]\n        };\n      }\n      case Option2: {\n        return {\n          name: Option2,\n          properties: [\n            { name: \"name\" },\n            { name: \"value\", defaultValue: false }\n          ]\n        };\n      }\n      case Packet: {\n        return {\n          name: Packet,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"blocks\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case PacketBlock: {\n        return {\n          name: PacketBlock,\n          properties: [\n            { name: \"end\" },\n            { name: \"label\" },\n            { name: \"start\" }\n          ]\n        };\n      }\n      case Pie: {\n        return {\n          name: Pie,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"sections\", defaultValue: [] },\n            { name: \"showData\", defaultValue: false },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case PieSection: {\n        return {\n          name: PieSection,\n          properties: [\n            { name: \"label\" },\n            { name: \"value\" }\n          ]\n        };\n      }\n      case Radar: {\n        return {\n          name: Radar,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"axes\", defaultValue: [] },\n            { name: \"curves\", defaultValue: [] },\n            { name: \"options\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Service: {\n        return {\n          name: Service,\n          properties: [\n            { name: \"icon\" },\n            { name: \"iconText\" },\n            { name: \"id\" },\n            { name: \"in\" },\n            { name: \"title\" }\n          ]\n        };\n      }\n      case Direction: {\n        return {\n          name: Direction,\n          properties: [\n            { name: \"accDescr\" },\n            { name: \"accTitle\" },\n            { name: \"dir\" },\n            { name: \"statements\", defaultValue: [] },\n            { name: \"title\" }\n          ]\n        };\n      }\n      default: {\n        return {\n          name: type,\n          properties: []\n        };\n      }\n    }\n  }\n}, __name(_a, \"MermaidAstReflection\"), _a);\nvar reflection = new MermaidAstReflection();\nvar loadedInfoGrammar;\nvar InfoGrammar = /* @__PURE__ */ __name(() => loadedInfoGrammar ?? (loadedInfoGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Info\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Info\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"info\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"showInfo\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"InfoGrammar\");\nvar loadedPacketGrammar;\nvar PacketGrammar = /* @__PURE__ */ __name(() => loadedPacketGrammar ?? (loadedPacketGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Packet\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Packet\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"packet-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PacketBlock\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"start\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"end\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}`)), \"PacketGrammar\");\nvar loadedPieGrammar;\nvar PieGrammar = /* @__PURE__ */ __name(() => loadedPieGrammar ?? (loadedPieGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Pie\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Pie\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"pie\"},{\"$type\":\"Assignment\",\"feature\":\"showData\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showData\"},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PieSection\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_LABEL\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]+\\\\\"/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_VALUE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"PieGrammar\");\nvar loadedArchitectureGrammar;\nvar ArchitectureGrammar = /* @__PURE__ */ __name(() => loadedArchitectureGrammar ?? (loadedArchitectureGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Architecture\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Architecture\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"architecture-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"*\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"groups\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"services\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"junctions\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"edges\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"LeftPort\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"lhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"RightPort\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"rhsDir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Arrow\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"lhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"--\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"-\"}]}]},{\"$type\":\"Assignment\",\"feature\":\"rhsInto\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Group\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"group\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Service\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"service\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"iconText\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"icon\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Junction\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"junction\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"in\"},{\"$type\":\"Assignment\",\"feature\":\"in\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Edge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"lhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"lhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"rhsId\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"rhsGroup\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_DIRECTION\",\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"L\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"R\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"T\"}}]},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"B\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ID\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\w]+/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TEXT_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\(\\\\\"[^\\\\\"]+\\\\\"\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_ICON\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\([\\\\\\\\w-:]+\\\\\\\\)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARCH_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\[[\\\\\\\\w ]+\\\\\\\\]/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_GROUP\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\{group\\\\\\\\}/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ARROW_INTO\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/<|>/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}')), \"ArchitectureGrammar\");\nvar loadedGitGraphGrammar;\nvar GitGraphGrammar = /* @__PURE__ */ __name(() => loadedGitGraphGrammar ?? (loadedGitGraphGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"GitGraph\",\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"rules\":[{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"GitGraph\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"Keyword\",\"value\":\":\"}]},{\"$type\":\"Keyword\",\"value\":\"gitGraph:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"gitGraph\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@0\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"statements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Statement\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Direction\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"dir\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"LR\"},{\"$type\":\"Keyword\",\"value\":\"TB\"},{\"$type\":\"Keyword\",\"value\":\"BT\"}]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Commit\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"commit\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"msg:\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"message\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Branch\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"branch\"},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"order:\"},{\"$type\":\"Assignment\",\"feature\":\"order\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Merge\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"merge\"},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type:\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"NORMAL\"},{\"$type\":\"Keyword\",\"value\":\"REVERSE\"},{\"$type\":\"Keyword\",\"value\":\"HIGHLIGHT\"}]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Checkout\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"checkout\"},{\"$type\":\"Keyword\",\"value\":\"switch\"}]},{\"$type\":\"Assignment\",\"feature\":\"branch\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"CherryPicking\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"cherry-pick\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"id:\"},{\"$type\":\"Assignment\",\"feature\":\"id\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"tag:\"},{\"$type\":\"Assignment\",\"feature\":\"tags\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"parent:\"},{\"$type\":\"Assignment\",\"feature\":\"parent\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[0-9]+(?=\\\\\\\\s)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\w([-\\\\\\\\./\\\\\\\\w]*[-\\\\\\\\w])?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"types\":[],\"usedGrammars\":[]}`)), \"GitGraphGrammar\");\nvar loadedRadarGrammar;\nvar RadarGrammar = /* @__PURE__ */ __name(() => loadedRadarGrammar ?? (loadedRadarGrammar = loadGrammarFromJson(`{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Radar\",\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]},{\"$type\":\"Interface\",\"name\":\"Entry\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"axis\",\"isOptional\":true,\"type\":{\"$type\":\"ReferenceType\",\"referenceType\":{\"$type\":\"SimpleType\",\"typeRef\":{\"$ref\":\"#/rules@12\"}}}},{\"$type\":\"TypeAttribute\",\"name\":\"value\",\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"number\"},\"isOptional\":false}],\"superTypes\":[]}],\"rules\":[{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"TitleAndAccessibilities\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"EOL\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false},{\"$type\":\"ParserRule\",\"entry\":true,\"name\":\"Radar\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"radar-beta\"},{\"$type\":\"Keyword\",\"value\":\"radar-beta:\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"radar-beta\"},{\"$type\":\"Keyword\",\"value\":\":\"}]}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@0\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"axis\"},{\"$type\":\"Assignment\",\"feature\":\"axes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"axes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"curve\"},{\"$type\":\"Assignment\",\"feature\":\"curves\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"curves\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"options\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"options\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Label\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"[\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"]\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Axis\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Curve\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\"{\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\"}\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"fragment\":true,\"name\":\"Entries\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Assignment\",\"feature\":\"entries\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"DetailedEntry\",\"returnType\":{\"$ref\":\"#/interfaces@1\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"axis\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@12\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Keyword\",\"value\":\":\",\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"NumberEntry\",\"returnType\":{\"$ref\":\"#/interfaces@1\"},\"definition\":{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Option\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showLegend\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"ticks\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"max\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"min\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"graticule\"}},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NUMBER\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"BOOLEAN\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"boolean\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"false\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"GRATICULE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"TerminalAlternatives\",\"elements\":[{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"circle\"}},{\"$type\":\"CharacterRange\",\"left\":{\"$type\":\"Keyword\",\"value\":\"polygon\"}}]},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[a-zA-Z_][a-zA-Z0-9\\\\\\\\-_]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|'[^']*'/\"},\"fragment\":false,\"hidden\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"types\":[],\"usedGrammars\":[]}`)), \"RadarGrammar\");\nvar InfoLanguageMetaData = {\n  languageId: \"info\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar PacketLanguageMetaData = {\n  languageId: \"packet\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar PieLanguageMetaData = {\n  languageId: \"pie\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar ArchitectureLanguageMetaData = {\n  languageId: \"architecture\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar GitGraphLanguageMetaData = {\n  languageId: \"gitGraph\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar RadarLanguageMetaData = {\n  languageId: \"radar\",\n  fileExtensions: [\".mmd\", \".mermaid\"],\n  caseInsensitive: false,\n  mode: \"production\"\n};\nvar MermaidGeneratedSharedModule = {\n  AstReflection: /* @__PURE__ */ __name(() => new MermaidAstReflection(), \"AstReflection\")\n};\nvar InfoGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => InfoGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => InfoLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PacketGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PacketGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PacketLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar PieGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PieGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PieLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar ArchitectureGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => ArchitectureGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => ArchitectureLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar GitGraphGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => GitGraphGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => GitGraphLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar RadarGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => RadarGrammar(), \"Grammar\"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => RadarLanguageMetaData, \"LanguageMetaData\"),\n  parser: {}\n};\nvar accessibilityDescrRegex = /accDescr(?:[\\t ]*:([^\\n\\r]*)|\\s*{([^}]*)})/;\nvar accessibilityTitleRegex = /accTitle[\\t ]*:([^\\n\\r]*)/;\nvar titleRegex = /title([\\t ][^\\n\\r]*|)/;\nvar rulesRegexes = {\n  ACC_DESCR: accessibilityDescrRegex,\n  ACC_TITLE: accessibilityTitleRegex,\n  TITLE: titleRegex\n};\nvar AbstractMermaidValueConverter = (_b = class extends DefaultValueConverter {\n  runConverter(rule, input, cstNode) {\n    let value = this.runCommonConverter(rule, input, cstNode);\n    if (value === void 0) {\n      value = this.runCustomConverter(rule, input, cstNode);\n    }\n    if (value === void 0) {\n      return super.runConverter(rule, input, cstNode);\n    }\n    return value;\n  }\n  runCommonConverter(rule, input, _cstNode) {\n    const regex = rulesRegexes[rule.name];\n    if (regex === void 0) {\n      return void 0;\n    }\n    const match = regex.exec(input);\n    if (match === null) {\n      return void 0;\n    }\n    if (match[1] !== void 0) {\n      return match[1].trim().replace(/[\\t ]{2,}/gm, \" \");\n    }\n    if (match[2] !== void 0) {\n      return match[2].replace(/^\\s*/gm, \"\").replace(/\\s+$/gm, \"\").replace(/[\\t ]{2,}/gm, \" \").replace(/[\\n\\r]{2,}/gm, \"\\n\");\n    }\n    return void 0;\n  }\n}, __name(_b, \"AbstractMermaidValueConverter\"), _b);\nvar CommonValueConverter = (_c = class extends AbstractMermaidValueConverter {\n  runCustomConverter(_rule, _input, _cstNode) {\n    return void 0;\n  }\n}, __name(_c, \"CommonValueConverter\"), _c);\nvar AbstractMermaidTokenBuilder = (_d = class extends DefaultTokenBuilder {\n  constructor(keywords) {\n    super();\n    this.keywords = new Set(keywords);\n  }\n  buildKeywordTokens(rules, terminalTokens, options) {\n    const tokenTypes = super.buildKeywordTokens(rules, terminalTokens, options);\n    tokenTypes.forEach((tokenType) => {\n      if (this.keywords.has(tokenType.name) && tokenType.PATTERN !== void 0) {\n        tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + \"(?:(?=%%)|(?!\\\\S))\");\n      }\n    });\n    return tokenTypes;\n  }\n}, __name(_d, \"AbstractMermaidTokenBuilder\"), _d);\n_e = class extends AbstractMermaidTokenBuilder {\n}, __name(_e, \"CommonTokenBuilder\"), _e;\nvar GitGraphTokenBuilder = (_f = class extends AbstractMermaidTokenBuilder {\n  constructor() {\n    super([\"gitGraph\"]);\n  }\n}, __name(_f, \"GitGraphTokenBuilder\"), _f);\nvar GitGraphModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new GitGraphTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createGitGraphServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const GitGraph2 = inject(\n    createDefaultCoreModule({ shared }),\n    GitGraphGeneratedModule,\n    GitGraphModule\n  );\n  shared.ServiceRegistry.register(GitGraph2);\n  return { shared, GitGraph: GitGraph2 };\n}\n__name(createGitGraphServices, \"createGitGraphServices\");\nvar InfoTokenBuilder = (_g = class extends AbstractMermaidTokenBuilder {\n  constructor() {\n    super([\"info\", \"showInfo\"]);\n  }\n}, __name(_g, \"InfoTokenBuilder\"), _g);\nvar InfoModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new InfoTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createInfoServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Info2 = inject(\n    createDefaultCoreModule({ shared }),\n    InfoGeneratedModule,\n    InfoModule\n  );\n  shared.ServiceRegistry.register(Info2);\n  return { shared, Info: Info2 };\n}\n__name(createInfoServices, \"createInfoServices\");\nvar PacketTokenBuilder = (_h = class extends AbstractMermaidTokenBuilder {\n  constructor() {\n    super([\"packet-beta\"]);\n  }\n}, __name(_h, \"PacketTokenBuilder\"), _h);\nvar PacketModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new PacketTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPacketServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Packet2 = inject(\n    createDefaultCoreModule({ shared }),\n    PacketGeneratedModule,\n    PacketModule\n  );\n  shared.ServiceRegistry.register(Packet2);\n  return { shared, Packet: Packet2 };\n}\n__name(createPacketServices, \"createPacketServices\");\nvar PieTokenBuilder = (_i = class extends AbstractMermaidTokenBuilder {\n  constructor() {\n    super([\"pie\", \"showData\"]);\n  }\n}, __name(_i, \"PieTokenBuilder\"), _i);\nvar PieValueConverter = (_j = class extends AbstractMermaidValueConverter {\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name !== \"PIE_SECTION_LABEL\") {\n      return void 0;\n    }\n    return input.replace(/\"/g, \"\").trim();\n  }\n}, __name(_j, \"PieValueConverter\"), _j);\nvar PieModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new PieTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new PieValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createPieServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Pie2 = inject(\n    createDefaultCoreModule({ shared }),\n    PieGeneratedModule,\n    PieModule\n  );\n  shared.ServiceRegistry.register(Pie2);\n  return { shared, Pie: Pie2 };\n}\n__name(createPieServices, \"createPieServices\");\nvar ArchitectureTokenBuilder = (_k = class extends AbstractMermaidTokenBuilder {\n  constructor() {\n    super([\"architecture\"]);\n  }\n}, __name(_k, \"ArchitectureTokenBuilder\"), _k);\nvar ArchitectureValueConverter = (_l = class extends AbstractMermaidValueConverter {\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name === \"ARCH_ICON\") {\n      return input.replace(/[()]/g, \"\").trim();\n    } else if (rule.name === \"ARCH_TEXT_ICON\") {\n      return input.replace(/[\"()]/g, \"\");\n    } else if (rule.name === \"ARCH_TITLE\") {\n      return input.replace(/[[\\]]/g, \"\").trim();\n    }\n    return void 0;\n  }\n}, __name(_l, \"ArchitectureValueConverter\"), _l);\nvar ArchitectureModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new ArchitectureTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new ArchitectureValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createArchitectureServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Architecture2 = inject(\n    createDefaultCoreModule({ shared }),\n    ArchitectureGeneratedModule,\n    ArchitectureModule\n  );\n  shared.ServiceRegistry.register(Architecture2);\n  return { shared, Architecture: Architecture2 };\n}\n__name(createArchitectureServices, \"createArchitectureServices\");\nvar RadarTokenBuilder = (_m = class extends AbstractMermaidTokenBuilder {\n  constructor() {\n    super([\"radar-beta\"]);\n  }\n}, __name(_m, \"RadarTokenBuilder\"), _m);\nvar RadarModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ __name(() => new RadarTokenBuilder(), \"TokenBuilder\"),\n    ValueConverter: /* @__PURE__ */ __name(() => new CommonValueConverter(), \"ValueConverter\")\n  }\n};\nfunction createRadarServices(context = EmptyFileSystem) {\n  const shared = inject(\n    createDefaultSharedCoreModule(context),\n    MermaidGeneratedSharedModule\n  );\n  const Radar2 = inject(\n    createDefaultCoreModule({ shared }),\n    RadarGeneratedModule,\n    RadarModule\n  );\n  shared.ServiceRegistry.register(Radar2);\n  return { shared, Radar: Radar2 };\n}\n__name(createRadarServices, \"createRadarServices\");\nvar parsers = {};\nvar initializers = {\n  info: /* @__PURE__ */ __name(async () => {\n    const { createInfoServices: createInfoServices2 } = await import(\"./info-4N47QTOZ-DheTaZEm.js\");\n    const parser = createInfoServices2().Info.parser.LangiumParser;\n    parsers.info = parser;\n  }, \"info\"),\n  packet: /* @__PURE__ */ __name(async () => {\n    const { createPacketServices: createPacketServices2 } = await import(\"./packet-KVYON367-pofk52jv.js\");\n    const parser = createPacketServices2().Packet.parser.LangiumParser;\n    parsers.packet = parser;\n  }, \"packet\"),\n  pie: /* @__PURE__ */ __name(async () => {\n    const { createPieServices: createPieServices2 } = await import(\"./pie-R6RNRRYF-DWEpuQ_Q.js\");\n    const parser = createPieServices2().Pie.parser.LangiumParser;\n    parsers.pie = parser;\n  }, \"pie\"),\n  architecture: /* @__PURE__ */ __name(async () => {\n    const { createArchitectureServices: createArchitectureServices2 } = await import(\"./architecture-4AB2E3PP-B4sZMi_M.js\");\n    const parser = createArchitectureServices2().Architecture.parser.LangiumParser;\n    parsers.architecture = parser;\n  }, \"architecture\"),\n  gitGraph: /* @__PURE__ */ __name(async () => {\n    const { createGitGraphServices: createGitGraphServices2 } = await import(\"./gitGraph-O2Q2CXLX-B9G9FYQ5.js\");\n    const parser = createGitGraphServices2().GitGraph.parser.LangiumParser;\n    parsers.gitGraph = parser;\n  }, \"gitGraph\"),\n  radar: /* @__PURE__ */ __name(async () => {\n    const { createRadarServices: createRadarServices2 } = await import(\"./radar-MK3ICKWK-CiNWpY4n.js\");\n    const parser = createRadarServices2().Radar.parser.LangiumParser;\n    parsers.radar = parser;\n  }, \"radar\")\n};\nasync function parse(diagramType, text) {\n  const initializer = initializers[diagramType];\n  if (!initializer) {\n    throw new Error(`Unknown diagram type: ${diagramType}`);\n  }\n  if (!parsers[diagramType]) {\n    await initializer();\n  }\n  const parser = parsers[diagramType];\n  const result = parser.parse(text);\n  if (result.lexerErrors.length > 0 || result.parserErrors.length > 0) {\n    throw new MermaidParseError(result);\n  }\n  return result.value;\n}\n__name(parse, \"parse\");\nvar MermaidParseError = (_n = class extends Error {\n  constructor(result) {\n    const lexerErrors = result.lexerErrors.map((err) => err.message).join(\"\\n\");\n    const parserErrors = result.parserErrors.map((err) => err.message).join(\"\\n\");\n    super(`Parsing failed: ${lexerErrors} ${parserErrors}`);\n    this.result = result;\n  }\n}, __name(_n, \"MermaidParseError\"), _n);\nexport {\n  ArchitectureModule as A,\n  GitGraphModule as G,\n  InfoModule as I,\n  PacketModule as P,\n  RadarModule as R,\n  createPacketServices as a,\n  PieModule as b,\n  createInfoServices as c,\n  createPieServices as d,\n  createArchitectureServices as e,\n  createGitGraphServices as f,\n  createRadarServices as g,\n  parse as p\n};\n//# sourceMappingURL=mermaid-parser.core-BjtFtmpl.js.map\n"],
  "mappings": "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",
  "names": []
}
